{
  "version": 3,
  "file": "/home/kuranes/sketchfab/osgjs_orig/osgjs/builds/dist/OSG.js",
  "sources": [
    "../tools/build/almond.js",
    "osgNameSpace.js",
    "osgUtil/osgPool.js",
    "osg/StateGraph.js",
    "osg/Notify.js",
    "osg/Utils.js",
    "osg/Object.js",
    "osg/StateAttribute.js",
    "osg/Vec4.js",
    "osg/BlendColor.js",
    "osg/BlendFunc.js",
    "osg/BoundingBox.js",
    "osg/Vec3.js",
    "osg/BoundingSphere.js",
    "osg/BufferArray.js",
    "osg/Map.js",
    "osg/StateSet.js",
    "osg/FrameStamp.js",
    "osg/NodeVisitor.js",
    "osg/Quat.js",
    "osg/Matrix.js",
    "osg/TransformEnums.js",
    "osg/ComputeMatrixFromNodePath.js",
    "osg/Node.js",
    "osg/Transform.js",
    "osg/CullSettings.js",
    "osg/Camera.js",
    "osg/CullFace.js",
    "osg/CullStack.js",
    "osg/MatrixTransform.js",
    "osg/Projection.js",
    "osg/LightSource.js",
    "osg/Geometry.js",
    "osg/RenderBin.js",
    "osg/FrameBufferObject.js",
    "osg/RenderStage.js",
    "osg/Lod.js",
    "vendors/Q.js",
    "osg/PagedLOD.js",
    "osg/CullVisitor.js",
    "osg/Depth.js",
    "osg/DrawArrayLengths.js",
    "osg/PrimitiveSet.js",
    "osg/DrawArrays.js",
    "osg/DrawElements.js",
    "osg/EllipsoidModel.js",
    "osg/Image.js",
    "osg/TriangleIndexFunctor.js",
    "osgUtil/TriangleIntersect.js",
    "osg/KdTree.js",
    "osg/KdTreeBuilder.js",
    "osg/Uniform.js",
    "osg/Light.js",
    "osg/LineWidth.js",
    "osg/Program.js",
    "osg/Shader.js",
    "osg/TextureManager.js",
    "osgDB/Options.js",
    "osgDB/Input.js",
    "osgDB/ReaderParser.js",
    "osg/Texture.js",
    "osgShader/utils/sprintf.js",
    "osgShader/shaderNode/Node.js",
    "osgShader/shaderNode/data.js",
    "osgShader/shaderNode/textures.js",
    "osgShader/shaderNode/functions.js",
    "osgShader/shaderNode/operations.js",
    "osgShader/shaderNode/lights.js",
    "osgShader/ShaderNode.js",
    "vendors/require/text.js",
    "osgShader/shaderNode/functions.glsl!text",
    "osgShader/shaderNode/lights.glsl!text",
    "osgShader/shaderNode/textures.glsl!text",
    "osgShader/ShaderLib.js",
    "osgShader/ShaderProcessor.js",
    "osgShader/shaderGenerator/Compiler.js",
    "osgShader/shaderGenerator/ShaderGenerator.js",
    "osgShader/shaderGenerator/CompilerMaterial.js",
    "osgShader/shaderGenerator/ShaderGeneratorMaterial.js",
    "osgShader/shaderGenerator/CompilerShadeless.js",
    "osgShader/shaderGenerator/ShaderGeneratorShadeless.js",
    "osgShader/shaderGenerator/ShaderGeneratorStateSet.js",
    "osgShader/ShaderGeneratorProxy.js",
    "osg/Material.js",
    "osg/Math.js",
    "osgShader/shaderNode/environment.js",
    "osgShader/shaderNode/shadows.js",
    "osg/Shape.js",
    "osg/Stack.js",
    "osg/State.js",
    "osg/TextureCubeMap.js",
    "osg/UpdateVisitor.js",
    "osg/Vec2.js",
    "osg/Viewport.js",
    "osg/WebGLCaps.js",
    "osg/osg.js",
    "osgAnimation/Animation.js",
    "osgAnimation/AnimationUpdateCallback.js",
    "osgAnimation/BasicAnimationManager.js",
    "osgAnimation/Channel.js",
    "osgAnimation/Easing.js",
    "osgAnimation/Sampler.js",
    "osgAnimation/Interpolator.js",
    "osgAnimation/Target.js",
    "osgAnimation/FloatTarget.js",
    "osgAnimation/FloatLerpChannel.js",
    "osgAnimation/Keyframe.js",
    "osgAnimation/LinkVisitor.js",
    "osgAnimation/QuatTarget.js",
    "osgAnimation/QuatLerpChannel.js",
    "osgAnimation/QuatSlerpChannel.js",
    "osgAnimation/StackedQuaternion.js",
    "osgAnimation/Vec3Target.js",
    "osgAnimation/StackedRotateAxis.js",
    "osgAnimation/StackedTranslate.js",
    "osgAnimation/UpdateMatrixTransform.js",
    "osgAnimation/Vec3LerpChannel.js",
    "osgAnimation/osgAnimation.js",
    "osgWrappers/serializers/osg.js",
    "osgWrappers/serializers/osgAnimation.js",
    "osgDB/osgDB.js",
    "vendors/Hammer.js",
    "osgGA/Manipulator.js",
    "osgGA/OrbitManipulatorLeapMotionController.js",
    "osgGA/OrbitManipulatorEnums.js",
    "osgGA/OrbitManipulatorMouseKeyboardController.js",
    "osgGA/OrbitManipulatorHammerController.js",
    "osgGA/OrbitManipulatorGamePadController.js",
    "osgGA/OrbitManipulator.js",
    "osgGA/FirstPersonManipulatorMouseKeyboardController.js",
    "osgGA/FirstPersonManipulatorOculusController.js",
    "osgGA/FirstPersonManipulator.js",
    "osgGA/SwitchManipulator.js",
    "osgGA/osgGA.js",
    "osgUtil/Composer.js",
    "osgUtil/IntersectVisitor.js",
    "osgUtil/ParameterVisitor.js",
    "osgUtil/Oculus.js",
    "osgUtil/WebVR.js",
    "osgUtil/osgUtil.js",
    "osgViewer/View.js",
    "osgViewer/eventProxy/GamePad.js",
    "osgViewer/eventProxy/Hammer.js",
    "vendors/Leap.js",
    "osgViewer/eventProxy/LeapMotion.js",
    "osgViewer/eventProxy/StandardMouseKeyboard.js",
    "osgViewer/eventProxy/Oculus.js",
    "osgViewer/eventProxy/EventProxy.js",
    "osgViewer/webgl-utils.js",
    "osgViewer/webgl-debug.js",
    "osgViewer/stats.js",
    "osgViewer/Viewer.js",
    "osgViewer/osgViewer.js",
    "OSG.js"
  ],
  "names": [],
  "mappings": "AAAA;AACA;AACA;AACA;AACA,ACJA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA;AACA,ACHA;AACA;AACA;AACA,ACHA;AACA;AACA;ACFA,ADGA;ACFA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;ACDA,ADEA;ACDA;AACA,ACFA;AACA;ACDA,ADEA;ACDA;AACA",
  "sourcesContent": [
    "eval(\"/**\\n * almond 0.2.7 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/jrburke/almond for details\\n */\\n//Going sloppy to avoid \\'use strict\\' string cost, but strict practices should\\n//be followed.\\n/*jslint sloppy: true */\\n/*global setTimeout: false */\\n\\nvar requirejs, require, define;\\n(function (undef) {\\n    var main, req, makeMap, handlers,\\n        defined = {},\\n        waiting = {},\\n        config = {},\\n        defining = {},\\n        hasOwn = Object.prototype.hasOwnProperty,\\n        aps = [].slice;\\n\\n    function hasProp(obj, prop) {\\n        return hasOwn.call(obj, prop);\\n    }\\n\\n    /**\\n     * Given a relative module name, like ./something, normalize it to\\n     * a real name that can be mapped to a path.\\n     * @param {String} name the relative name\\n     * @param {String} baseName a real name that the name arg is relative\\n     * to.\\n     * @returns {String} normalized name\\n     */\\n    function normalize(name, baseName) {\\n        var nameParts, nameSegment, mapValue, foundMap,\\n            foundI, foundStarMap, starI, i, j, part,\\n            baseParts = baseName && baseName.split(\\\"/\\\"),\\n            map = config.map,\\n            starMap = (map && map[\\'*\\']) || {};\\n\\n        //Adjust any relative paths.\\n        if (name && name.charAt(0) === \\\".\\\") {\\n            //If have a base name, try to normalize against it,\\n            //otherwise, assume it is a top-level require that will\\n            //be relative to baseUrl in the end.\\n            if (baseName) {\\n                //Convert baseName to array, and lop off the last part,\\n                //so that . matches that \\\"directory\\\" and not name of the baseName\\'s\\n                //module. For instance, baseName of \\\"one/two/three\\\", maps to\\n                //\\\"one/two/three.js\\\", but we want the directory, \\\"one/two\\\" for\\n                //this normalization.\\n                baseParts = baseParts.slice(0, baseParts.length - 1);\\n\\n                name = baseParts.concat(name.split(\\\"/\\\"));\\n\\n                //start trimDots\\n                for (i = 0; i < name.length; i += 1) {\\n                    part = name[i];\\n                    if (part === \\\".\\\") {\\n                        name.splice(i, 1);\\n                        i -= 1;\\n                    } else if (part === \\\"..\\\") {\\n                        if (i === 1 && (name[2] === \\'..\\' || name[0] === \\'..\\')) {\\n                            //End of the line. Keep at least one non-dot\\n                            //path segment at the front so it can be mapped\\n                            //correctly to disk. Otherwise, there is likely\\n                            //no path mapping for a path starting with \\'..\\'.\\n                            //This can still fail, but catches the most reasonable\\n                            //uses of ..\\n                            break;\\n                        } else if (i > 0) {\\n                            name.splice(i - 1, 2);\\n                            i -= 2;\\n                        }\\n                    }\\n                }\\n                //end trimDots\\n\\n                name = name.join(\\\"/\\\");\\n            } else if (name.indexOf(\\'./\\') === 0) {\\n                // No baseName, so this is ID is resolved relative\\n                // to baseUrl, pull off the leading dot.\\n                name = name.substring(2);\\n            }\\n        }\\n\\n        //Apply map config if available.\\n        if ((baseParts || starMap) && map) {\\n            nameParts = name.split(\\'/\\');\\n\\n            for (i = nameParts.length; i > 0; i -= 1) {\\n                nameSegment = nameParts.slice(0, i).join(\\\"/\\\");\\n\\n                if (baseParts) {\\n                    //Find the longest baseName segment match in the config.\\n                    //So, do joins on the biggest to smallest lengths of baseParts.\\n                    for (j = baseParts.length; j > 0; j -= 1) {\\n                        mapValue = map[baseParts.slice(0, j).join(\\'/\\')];\\n\\n                        //baseName segment has  config, find if it has one for\\n                        //this name.\\n                        if (mapValue) {\\n                            mapValue = mapValue[nameSegment];\\n                            if (mapValue) {\\n                                //Match, update name to the new value.\\n                                foundMap = mapValue;\\n                                foundI = i;\\n                                break;\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                if (foundMap) {\\n                    break;\\n                }\\n\\n                //Check for a star map match, but just hold on to it,\\n                //if there is a shorter segment match later in a matching\\n                //config, then favor over this star map.\\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\\n                    foundStarMap = starMap[nameSegment];\\n                    starI = i;\\n                }\\n            }\\n\\n            if (!foundMap && foundStarMap) {\\n                foundMap = foundStarMap;\\n                foundI = starI;\\n            }\\n\\n            if (foundMap) {\\n                nameParts.splice(0, foundI, foundMap);\\n                name = nameParts.join(\\'/\\');\\n            }\\n        }\\n\\n        return name;\\n    }\\n\\n    function makeRequire(relName, forceSync) {\\n        return function () {\\n            //A version of a require function that passes a moduleName\\n            //value for items that may need to\\n            //look up paths relative to the moduleName\\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\\n        };\\n    }\\n\\n    function makeNormalize(relName) {\\n        return function (name) {\\n            return normalize(name, relName);\\n        };\\n    }\\n\\n    function makeLoad(depName) {\\n        return function (value) {\\n            defined[depName] = value;\\n        };\\n    }\\n\\n    function callDep(name) {\\n        if (hasProp(waiting, name)) {\\n            var args = waiting[name];\\n            delete waiting[name];\\n            defining[name] = true;\\n            main.apply(undef, args);\\n        }\\n\\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\\n            throw new Error(\\'No \\' + name);\\n        }\\n        return defined[name];\\n    }\\n\\n    //Turns a plugin!resource to [plugin, resource]\\n    //with the plugin being undefined if the name\\n    //did not have a plugin prefix.\\n    function splitPrefix(name) {\\n        var prefix,\\n            index = name ? name.indexOf(\\'!\\') : -1;\\n        if (index > -1) {\\n            prefix = name.substring(0, index);\\n            name = name.substring(index + 1, name.length);\\n        }\\n        return [prefix, name];\\n    }\\n\\n    /**\\n     * Makes a name map, normalizing the name, and using a plugin\\n     * for normalization if necessary. Grabs a ref to plugin\\n     * too, as an optimization.\\n     */\\n    makeMap = function (name, relName) {\\n        var plugin,\\n            parts = splitPrefix(name),\\n            prefix = parts[0];\\n\\n        name = parts[1];\\n\\n        if (prefix) {\\n            prefix = normalize(prefix, relName);\\n            plugin = callDep(prefix);\\n        }\\n\\n        //Normalize according\\n        if (prefix) {\\n            if (plugin && plugin.normalize) {\\n                name = plugin.normalize(name, makeNormalize(relName));\\n            } else {\\n                name = normalize(name, relName);\\n            }\\n        } else {\\n            name = normalize(name, relName);\\n            parts = splitPrefix(name);\\n            prefix = parts[0];\\n            name = parts[1];\\n            if (prefix) {\\n                plugin = callDep(prefix);\\n            }\\n        }\\n\\n        //Using ridiculous property names for space reasons\\n        return {\\n            f: prefix ? prefix + \\'!\\' + name : name, //fullName\\n            n: name,\\n            pr: prefix,\\n            p: plugin\\n        };\\n    };\\n\\n    function makeConfig(name) {\\n        return function () {\\n            return (config && config.config && config.config[name]) || {};\\n        };\\n    }\\n\\n    handlers = {\\n        require: function (name) {\\n            return makeRequire(name);\\n        },\\n        exports: function (name) {\\n            var e = defined[name];\\n            if (typeof e !== \\'undefined\\') {\\n                return e;\\n            } else {\\n                return (defined[name] = {});\\n            }\\n        },\\n        module: function (name) {\\n            return {\\n                id: name,\\n                uri: \\'\\',\\n                exports: defined[name],\\n                config: makeConfig(name)\\n            };\\n        }\\n    };\\n\\n    main = function (name, deps, callback, relName) {\\n        var cjsModule, depName, ret, map, i,\\n            args = [],\\n            callbackType = typeof callback,\\n            usingExports;\\n\\n        //Use name if no relName\\n        relName = relName || name;\\n\\n        //Call the callback to define the module, if necessary.\\n        if (callbackType === \\'undefined\\' || callbackType === \\'function\\') {\\n            //Pull out the defined dependencies and pass the ordered\\n            //values to the callback.\\n            //Default to [require, exports, module] if no deps\\n            deps = !deps.length && callback.length ? [\\'require\\', \\'exports\\', \\'module\\'] : deps;\\n            for (i = 0; i < deps.length; i += 1) {\\n                map = makeMap(deps[i], relName);\\n                depName = map.f;\\n\\n                //Fast path CommonJS standard dependencies.\\n                if (depName === \\\"require\\\") {\\n                    args[i] = handlers.require(name);\\n                } else if (depName === \\\"exports\\\") {\\n                    //CommonJS module spec 1.1\\n                    args[i] = handlers.exports(name);\\n                    usingExports = true;\\n                } else if (depName === \\\"module\\\") {\\n                    //CommonJS module spec 1.1\\n                    cjsModule = args[i] = handlers.module(name);\\n                } else if (hasProp(defined, depName) ||\\n                           hasProp(waiting, depName) ||\\n                           hasProp(defining, depName)) {\\n                    args[i] = callDep(depName);\\n                } else if (map.p) {\\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\\n                    args[i] = defined[depName];\\n                } else {\\n                    throw new Error(name + \\' missing \\' + depName);\\n                }\\n            }\\n\\n            ret = callback ? callback.apply(defined[name], args) : undefined;\\n\\n            if (name) {\\n                //If setting exports via \\\"module\\\" is in play,\\n                //favor that over return value and exports. After that,\\n                //favor a non-undefined return value over exports use.\\n                if (cjsModule && cjsModule.exports !== undef &&\\n                        cjsModule.exports !== defined[name]) {\\n                    defined[name] = cjsModule.exports;\\n                } else if (ret !== undef || !usingExports) {\\n                    //Use the return value from the function.\\n                    defined[name] = ret;\\n                }\\n            }\\n        } else if (name) {\\n            //May just be an object definition for the module. Only\\n            //worry about defining if have a module name.\\n            defined[name] = callback;\\n        }\\n    };\\n\\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\\n        if (typeof deps === \\\"string\\\") {\\n            if (handlers[deps]) {\\n                //callback in this case is really relName\\n                return handlers[deps](callback);\\n            }\\n            //Just return the module wanted. In this scenario, the\\n            //deps arg is the module name, and second arg (if passed)\\n            //is just the relName.\\n            //Normalize module name, if it contains . or ..\\n            return callDep(makeMap(deps, callback).f);\\n        } else if (!deps.splice) {\\n            //deps is a config object, not an array.\\n            config = deps;\\n            if (callback.splice) {\\n                //callback is an array, which means it is a dependency list.\\n                //Adjust args if there are dependencies\\n                deps = callback;\\n                callback = relName;\\n                relName = null;\\n            } else {\\n                deps = undef;\\n            }\\n        }\\n\\n        //Support require([\\'a\\'])\\n        callback = callback || function () {};\\n\\n        //If relName is a function, it is an errback handler,\\n        //so remove it.\\n        if (typeof relName === \\'function\\') {\\n            relName = forceSync;\\n            forceSync = alt;\\n        }\\n\\n        //Simulate async callback;\\n        if (forceSync) {\\n            main(undef, deps, callback, relName);\\n        } else {\\n            //Using a non-zero value because of concern for what old browsers\\n            //do, and latest browsers \\\"upgrade\\\" to 4 if lower value is used:\\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\\n            //If want a value immediately, use require(\\'id\\') instead -- something\\n            //that works in almond on the global level, but not guaranteed and\\n            //unlikely to work in other AMD implementations.\\n            setTimeout(function () {\\n                main(undef, deps, callback, relName);\\n            }, 4);\\n        }\\n\\n        return req;\\n    };\\n\\n    /**\\n     * Just drops the config on the floor, but returns req in case\\n     * the config return value is used.\\n     */\\n    req.config = function (cfg) {\\n        config = cfg;\\n        if (config.deps) {\\n            req(config.deps, config.callback);\\n        }\\n        return req;\\n    };\\n\\n    /**\\n     * Expose module registry for debugging and tooling\\n     */\\n    requirejs._defined = defined;\\n\\n    define = function (name, deps, callback) {\\n\\n        //This module may not have dependencies\\n        if (!deps.splice) {\\n            //deps is not an array, so probably means\\n            //an object literal or factory function for\\n            //the value. Adjust args.\\n            callback = deps;\\n            deps = [];\\n        }\\n\\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\\n            waiting[name] = [name, deps, callback];\\n        }\\n    };\\n\\n    define.amd = {\\n        jQuery: true\\n    };\\n}());\\n\\n//# sourceURL=/../tools/build/almond.js\");\n\ndefine(\"../tools/build/almond\", function(){});\n\n",
    "eval(\"define( \\'osgNameSpace\\',[\\n], function ( ) {\\n    return {};\\n} );\\n\\n//# sourceURL=/osgNameSpace.js\");\n\n",
    "eval(\"define( \\'osgUtil/osgPool\\',[], function () {\\n\\n    /**\\n     * Authors:\\n     *  Tuan.kuranes <tuan.kuranes@gmail.com> Jerome Etienne <Jerome.etienne@gmail.com>\\n     */\\n\\n    var osgPool = {};\\n    osgPool.memoryPools = {};\\n\\n    /*\\n     *  TODO: Add stats & reports for developper per application  finer calibration (max, min, average)\\n     *  TODO: Debug Mode: check if not putting object twice, etc.\\n     *  USAGE: osg.memoryPools.stateGraph = new OsgObjectMemoryPool(osg.StateGraph).grow(50);\\n     */\\n    osgPool.OsgObjectMemoryPool = function ( ObjectClassName ) {\\n        return {\\n            _memPool: [],\\n            reset: function () {\\n                this._memPool = [];\\n                return this;\\n            },\\n            put: function ( obj ) {\\n                this._memPool.push( obj );\\n            },\\n            get: function () {\\n                if ( this._memPool.length > 0 ) return this._memPool.pop();\\n                this.grow();\\n                return this.get();\\n            },\\n            grow: function ( sizeAdd ) {\\n                if ( sizeAdd === undefined ) sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 20;\\n                var i = this._memPool.length;\\n                while ( i++ < sizeAdd ) this._memPool.push( new ObjectClassName() );\\n                return this;\\n            }\\n        };\\n    };\\n\\n    /*\\n     *  TODO: the same for  TypedArrays.\\n     *  TODO: Add stats reports for developper per application  finer calibration (max, min, average)\\n     *  TODO: Debug Mode: check if not putting object twice, etc.\\n     *  USAGE: osg.memoryPools.arrayPool = new OsgArrayMemoryPool();\\n     *  mymatrix = osg.memoryPools.arrayPool.get(16);\\n     *  // do use matrix, etc..\\n     *  osg.memoryPools.arrayPool.put(mymatrix);\\n     */\\n    osgPool.OsgArrayMemoryPool = function () {\\n        return {\\n            _mempoolofPools: [],\\n            reset: function () {\\n                this._memPoolofPools = {};\\n                return this;\\n            },\\n            put: function ( obj ) {\\n                if ( !this._memPoolofPools[ obj.length ] )\\n                    this._memPoolofPools[ obj.length ] = [];\\n                this._memPoolofPools[ obj.length ].push( obj );\\n            },\\n            get: function ( arraySize ) {\\n                if ( !this._memPoolofPools[ arraySize ] )\\n                    this._memPoolofPools[ arraySize ] = [];\\n                else if ( this._memPoolofPools.length > 0 )\\n                    return this._memPool.pop();\\n                this.grow( arraySize );\\n                return this.get();\\n            },\\n            grow: function ( arraySize, sizeAdd ) {\\n                if ( sizeAdd === undefined ) sizeAdd = ( this._memPool.length > 0 ) ? this._memPool.length * 2 : 20;\\n                var i = this._memPool.length;\\n                while ( i++ < sizeAdd ) this._memPool.push( new Array( arraySize ) );\\n                return this;\\n            }\\n        };\\n    };\\n\\n    return osgPool;\\n} );\\n\\n//# sourceURL=/osgUtil/osgPool.js\");\n\n",
    "eval(\"define( \\'osg/StateGraph\\',[\\n    \\'osgUtil/osgPool\\'\\n], function ( osgPool ) {\\n\\n    var StateGraph = function () {\\n        this.depth = 0;\\n        this.children = {};\\n        this.children.keys = [];\\n        this.leafs = [];\\n        this.stateset = undefined;\\n        this.parent = undefined;\\n    };\\n\\n    StateGraph.prototype = {\\n        clean: function () {\\n            this.leafs.splice( 0, this.leafs.length );\\n            this.stateset = undefined;\\n            this.parent = undefined;\\n            this.depth = 0;\\n            var key, keys = this.children.keys;\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                key = keys[ i ];\\n                this.children[ key ].clean();\\n                osgPool.memoryPools.stateGraph.put( this.children[ key ] );\\n            }\\n            this.children = {};\\n            keys.splice( 0, keys.length );\\n            this.children.keys = keys;\\n        },\\n        getStateSet: function () {\\n            return this.stateset;\\n        },\\n        findOrInsert: function ( stateset ) {\\n            var sg;\\n            if ( !this.children[ stateset.id ] ) {\\n\\n                //sg = new StateGraph();\\n                sg = osgPool.memoryPools.stateGraph.get();\\n\\n                sg.parent = this;\\n                sg.depth = this.depth + 1;\\n                sg.stateset = stateset;\\n                this.children[ stateset.id ] = sg;\\n                this.children.keys.push( stateset.id );\\n            } else {\\n                sg = this.children[ stateset.id ];\\n            }\\n            return sg;\\n        },\\n        moveToRootStateGraph: function ( state, sgCurrent ) {\\n            // need to pop back all statesets and matrices.\\n            while ( sgCurrent ) {\\n                if ( sgCurrent.stateSet ) {\\n                    state.popStateSet();\\n                }\\n                sgCurrent = sgCurrent._parent;\\n            }\\n        },\\n        moveStateGraph: function ( state, sgCurrent, sgNew ) {\\n            var stack = [];\\n            var i, l;\\n            if ( sgNew === sgCurrent || sgNew === undefined ) {\\n                return;\\n            }\\n\\n            if ( sgCurrent === undefined ) {\\n                // push stateset from sgNew to root, and apply\\n                // stateset from root to sgNew\\n                do {\\n                    if ( sgNew.stateset !== undefined ) {\\n                        stack.push( sgNew.stateset );\\n                    }\\n                    sgNew = sgNew.parent;\\n                } while ( sgNew );\\n\\n                for ( i = stack.length - 1, l = 0; i >= l; --i ) {\\n                    state.pushStateSet( stack[ i ] );\\n                }\\n                return;\\n            } else if ( sgCurrent.parent === sgNew.parent ) {\\n                // first handle the typical case which is two state groups\\n                // are neighbours.\\n\\n                // state has changed so need to pop old state.\\n                if ( sgCurrent.stateset !== undefined ) {\\n                    state.popStateSet();\\n                }\\n                // and push new state.\\n                if ( sgNew.stateset !== undefined ) {\\n                    state.pushStateSet( sgNew.stateset );\\n                }\\n                return;\\n            }\\n\\n            // need to pop back up to the same depth as the new state group.\\n            while ( sgCurrent.depth > sgNew.depth ) {\\n                if ( sgCurrent.stateset !== undefined ) {\\n                    state.popStateSet();\\n                }\\n                sgCurrent = sgCurrent.parent;\\n            }\\n\\n            // use return path to trace back steps to sgNew.\\n            stack = [];\\n\\n            // need to pop back up to the same depth as the curr state group.\\n            while ( sgNew.depth > sgCurrent.depth ) {\\n                if ( sgNew.stateset !== undefined ) {\\n                    stack.push( sgNew.stateset );\\n                }\\n                sgNew = sgNew.parent;\\n            }\\n\\n            // now pop back up both parent paths until they agree.\\n\\n            // DRT - 10/22/02\\n            // should be this to conform with above case where two StateGraph\\n            // nodes have the same parent\\n            while ( sgCurrent !== sgNew ) {\\n                if ( sgCurrent.stateset !== undefined ) {\\n                    state.popStateSet();\\n                }\\n                sgCurrent = sgCurrent.parent;\\n\\n                if ( sgNew.stateset !== undefined ) {\\n                    stack.push( sgNew.stateset );\\n                }\\n                sgNew = sgNew.parent;\\n            }\\n\\n            for ( i = stack.length - 1, l = 0; i >= l; --i ) {\\n                state.pushStateSet( stack[ i ] );\\n            }\\n        }\\n    };\\n\\n    return StateGraph;\\n} );\\n\\n//# sourceURL=/osg/StateGraph.js\");\n\n",
    "eval(\"define( \\'osg/Notify\\',[], function () {\\n\\n    var Notify = {};\\n\\n    Notify.DEBUG = 0;\\n    Notify.INFO = 1;\\n    Notify.NOTICE = 2;\\n    Notify.WARN = 3;\\n    Notify.ERROR = 4;\\n\\n    Notify.console = window.console;\\n\\n    // #FIXME getStackTrace was initially in webgl-utils (as a global function) but only used in this file\\n    /** Obtain a stacktrace from the current stack http://eriwen.com/javascript/js-stack-trace/\\n     */\\n    function getStackTrace( err ) {\\n        if (Notify.console && Notify.console.trace){\\n            Notify.console.trace();\\n            return \\'\\';\\n        }\\n        var callstack = [];\\n        try {\\n            if ( arguments.length === 1 ) {\\n                throw err;\\n            } else {\\n                throw new Error();\\n            }\\n        } catch ( error ) {\\n            if ( error.stack ) { //Firefox and Chrome\\n                callstack = ( error.stack + \\'\\\\n\\' ).replace( /^\\\\S[^\\\\(]+?[\\\\n$]/gm, \\'\\' ).\\n                replace( /^\\\\s+(at eval )?at\\\\s+/gm, \\'\\' ).\\n                replace( /^([^\\\\(]+?)([\\\\n$])/gm, \\'{anonymous}()@$1$2\\' ).\\n                replace( /^Object.<anonymous>\\\\s*\\\\(([^\\\\)]+)\\\\)/gm, \\'{anonymous}()@$1\\' ).split( \\'\\\\n\\' );\\n                // Remove call to this function\\n                callstack.shift();\\n\\n            }\\n        }\\n        // Remove empty entries\\n        for ( var i = 0; i < callstack.length; ++i ) {\\n            if ( callstack[ i ] === \\'\\' ) {\\n                callstack.splice( i, 1 );\\n                --i;\\n            }\\n        }\\n\\n        return callstack;\\n    }\\n\\n    Notify.setNotifyLevel = function ( level ) {\\n\\n        var log = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.log( str, getStackTrace() );\\n            }\\n        };\\n\\n        var info = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.info( str, getStackTrace() );\\n            }\\n        };\\n\\n        var warn = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.warn( str, getStackTrace() );\\n            }\\n        };\\n\\n        var error = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.error( str, getStackTrace() );\\n            }\\n        };\\n\\n        var debug = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.debug( str, getStackTrace() );\\n            }\\n        };\\n\\n        var assert = function ( str ) {\\n            if ( this.console !== undefined ) {\\n                this.console.assert( str, getStackTrace() );\\n            }\\n        };\\n\\n        var dummy = function () {};\\n\\n        Notify.assert = dummy;\\n        Notify.debug = dummy;\\n        Notify.info = dummy;\\n        Notify.log = Notify.notice = dummy;\\n        Notify.warn = dummy;\\n        Notify.error = dummy;\\n\\n        if ( level <= Notify.DEBUG ) {\\n            Notify.debug = debug;\\n            Notify.assert = assert;\\n        }\\n        if ( level <= Notify.INFO ) {\\n            Notify.info = info;\\n        }\\n        if ( level <= Notify.NOTICE ) {\\n            Notify.log = Notify.notice = log;\\n        }\\n        if ( level <= Notify.WARN ) {\\n            Notify.warn = warn;\\n        }\\n        if ( level <= Notify.ERROR ) {\\n            Notify.error = error;\\n        }\\n    };\\n\\n    Notify.setNotifyLevel( Notify.NOTICE );\\n\\n    Notify.reportWebGLError = false;\\n\\n    Notify.setConsole = function( replacement ) {\\n        Notify.console = replacement;\\n    };\\n\\n    return Notify;\\n} );\\n\\n//# sourceURL=/osg/Notify.js\");\n\n",
    "eval(\"define( \\'osg/Utils\\',[\\n    \\'osgUtil/osgPool\\',\\n    \\'osg/StateGraph\\',\\n    \\'osg/Notify\\'\\n], function ( osgPool, StateGraph, Notify ) {\\n\\n    // make the warning about StateGraph desappear\\n    Object.keys( StateGraph );\\n\\n    var Utils = {};\\n\\n    Utils.init = function () {\\n        var StateGraphClass = require( \\'osg/StateGraph\\' );\\n        osgPool.memoryPools.stateGraph = new osgPool.OsgObjectMemoryPool( StateGraphClass ).grow( 50 );\\n    };\\n\\n    var toString = Object.prototype.toString;\\n    Utils.isArray = function ( obj ) {\\n        return toString.call( obj ) === \\'[object Array]\\';\\n    };\\n\\n    Utils.extend = function () {\\n        // Save a reference to some core methods\\n        var toString = Object.prototype.toString,\\n            hasOwnPropertyFunc = Object.prototype.hasOwnProperty;\\n\\n        var isFunction = function ( obj ) {\\n            return toString.call( obj ) === \\'[object Function]\\';\\n        };\\n        var isArray = Utils.isArray;\\n        var isPlainObject = function ( obj ) {\\n            // Must be an Object.\\n            // Because of IE, we also have to check the presence of the constructor property.\\n            // Make sure that DOM nodes and window objects don\\'t pass through, as well\\n            if ( !obj || toString.call( obj ) !== \\'[object Object]\\' || obj.nodeType || obj.setInterval ) {\\n                return false;\\n            }\\n\\n            // Not own constructor property must be Object\\n            if ( obj.constructor && !hasOwnPropertyFunc.call( obj, \\'constructor\\' ) && !hasOwnPropertyFunc.call( obj.constructor.prototype, \\'isPrototypeOf\\' ) ) {\\n                return false;\\n            }\\n\\n            // Own properties are enumerated firstly, so to speed up,\\n            // if last one is own, then all properties are own.\\n\\n            var key;\\n            for ( key in obj ) {}\\n\\n            return key === undefined || hasOwnPropertyFunc.call( obj, key );\\n        };\\n\\n        // copy reference to target object\\n        var target = arguments[ 0 ] || {}, i = 1,\\n            length = arguments.length,\\n            deep = false,\\n            options, name, src, copy;\\n\\n        // Handle a deep copy situation\\n        if ( typeof target === \\'boolean\\' ) {\\n            deep = target;\\n            target = arguments[ 1 ] || {};\\n            // skip the boolean and the target\\n            i = 2;\\n        }\\n\\n        // Handle case when target is a string or something (possible in deep copy)\\n        if ( typeof target !== \\'object\\' && !isFunction( target ) ) {\\n            target = {};\\n        }\\n\\n        // extend jQuery itself if only one argument is passed\\n        if ( length === i ) {\\n            target = this;\\n            --i;\\n        }\\n\\n        for ( ; i < length; i++ ) {\\n            // Only deal with non-null/undefined values\\n            if ( ( options = arguments[ i ] ) !== null ) {\\n                // Extend the base object\\n                for ( name in options ) {\\n                    src = target[ name ];\\n                    copy = options[ name ];\\n\\n                    // Prevent never-ending loop\\n                    if ( target === copy ) {\\n                        continue;\\n                    }\\n\\n                    // Recurse if we\\'re merging object literal values or arrays\\n                    if ( deep && copy && ( isPlainObject( copy ) || isArray( copy ) ) ) {\\n                        var clone = src && ( isPlainObject( src ) || isArray( src ) ) ? src : isArray( copy ) ? [] : {};\\n\\n                        // Never move original objects, clone them\\n                        target[ name ] = Utils.extend( deep, clone, copy );\\n\\n                        // Don\\'t bring in undefined values\\n                    } else if ( copy !== undefined ) {\\n                        target[ name ] = copy;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the modified object\\n        return target;\\n    };\\n\\n    Utils.objectInehrit = Utils.objectInherit = function ( base /*, extras*/ ) {\\n        function F() {}\\n        F.prototype = base;\\n        var obj = new F();\\n\\n        // let augment object with multiple arguement\\n        for ( var i = 1; i < arguments.length; i++ ) {\\n            Utils.objectMix( obj, arguments[ i ], false );\\n        }\\n        return obj;\\n    };\\n    Utils.objectMix = function ( obj, properties, test ) {\\n        for ( var key in properties ) {\\n            if ( !( test && obj[ key ] ) ) {\\n                obj[ key ] = properties[ key ];\\n            }\\n        }\\n        return obj;\\n    };\\n\\n    Utils.objectType = {};\\n    Utils.objectType.type = 0;\\n    Utils.objectType.generate = function ( arg ) {\\n        var t = Utils.objectType.type;\\n        Utils.objectType[ t ] = arg;\\n        Utils.objectType[ arg ] = t;\\n        Utils.objectType.type += 1;\\n        return t;\\n    };\\n\\n    Utils.objectLibraryClass = function ( object, libName, className ) {\\n        object.className = function () {\\n            return className;\\n        };\\n        object.libraryName = function () {\\n            return libName;\\n        };\\n        var libraryClassName = libName + \\'::\\' + className;\\n        object.libraryClassName = function () {\\n            return libraryClassName;\\n        };\\n\\n        return object;\\n    };\\n    Utils.setTypeID = function ( classObject ) {\\n        var className = classObject.prototype.className();\\n        var typeID = Utils.objectType.generate( className );\\n        classObject.typeID = classObject.prototype.typeID = typeID;\\n    };\\n\\n    Utils.Float32Array = typeof Float32Array !== \\'undefined\\' ? Float32Array : null;\\n    Utils.Int32Array = typeof Int32Array !== \\'undefined\\' ? Int32Array : null;\\n    Utils.Uint16Array = typeof Uint16Array !== \\'undefined\\' ? Uint16Array : null;\\n    Utils.Uint32Array = typeof Uint32Array !== \\'undefined\\' ? Uint32Array : null;\\n\\n    Utils.performance = {};\\n    Utils.performance.now = ( function () {\\n        // if no window.performance\\n        if ( window.performance === undefined ) {\\n            return function () {\\n                return Date.now();\\n            };\\n        }\\n\\n        var fn = window.performance.now || window.performance.mozNow || window.performance.msNow || window.performance.oNow || window.performance.webkitNow ||\\n                function () {\\n                    return Date.now();\\n            };\\n        return function () {\\n            return fn.apply( window.performance, arguments );\\n        };\\n    } )();\\n\\n    Utils.timeStamp = function () {\\n\\n        var fn = Notify.console.timeStamp || Notify.console.markTimeline || function () {};\\n        return fn.apply( Notify.console, arguments );\\n\\n    };\\n\\n    var times = {};\\n\\n    Utils.time = function () {\\n\\n        var fn = Notify.console.time || function ( name ) {\\n            times[ name ] = Utils.performance.now();\\n        };\\n        return fn.apply( Notify.console, arguments );\\n\\n    };\\n\\n    Utils.timeEnd = function () {\\n\\n        var fn = Notify.console.timeEnd || function ( name ) {\\n\\n            if ( times[ name ] === undefined )\\n                return;\\n\\n            var now = Utils.performance.now();\\n            var duration = now - times[ name ];\\n\\n            Notify.debug( name + \\': \\' + duration + \\'ms\\');\\n            times[ name ] = undefined;\\n\\n        };\\n        return fn.apply( Notify.console, arguments );\\n\\n    };\\n\\n    Utils.profile = ( function () {\\n\\n        var fn = Notify.console.profile || function () {};\\n        return function () {\\n            return fn.apply( Notify.console, arguments );\\n        };\\n\\n    } )();\\n\\n    Utils.profileEnd = ( function () {\\n\\n        var fn = Notify.console.profileEnd || function () {};\\n        return function () {\\n            return fn.apply( Notify.console, arguments );\\n        };\\n\\n    } )();\\n\\n    return Utils;\\n} );\\n\\n//# sourceURL=/osg/Utils.js\");\n\n",
    "eval(\"define( \\'osg/Object\\',[\\n    \\'osg/Utils\\'\\n], function ( MACROUTILS ) {\\n\\n        /**\\n     *  Object class\\n     *  @class Object\\n     */\\n    var Object = function () {\\n        this._name = undefined;\\n        this._userdata = undefined;\\n        this._instanceID = Object.getInstanceID();\\n    };\\n\\n    /** @lends Object.prototype */\\n    Object.prototype = MACROUTILS.objectLibraryClass( {\\n            getInstanceID: function () {\\n                return this._instanceID;\\n            },\\n            setName: function ( name ) {\\n                this._name = name;\\n            },\\n            getName: function () {\\n                return this._name;\\n            },\\n            setUserData: function ( data ) {\\n                this._userdata = data;\\n            },\\n            getUserData: function () {\\n                return this._userdata;\\n            }\\n        },\\n        \\'osg\\', \\'Object\\' );\\n\\n\\n    // get an instanceID for each object\\n    ( function () {\\n        var instanceID = 0;\\n        Object.getInstanceID = function () {\\n            instanceID += 1;\\n            return instanceID;\\n        };\\n    } )();\\n\\n    return Object;\\n} );\\n\\n//# sourceURL=/osg/Object.js\");\n\n",
    "eval(\"define( \\'osg/StateAttribute\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( MACROUTILS, Object ) {\\n\\n    /**\\n     * StateAttribute base class\\n     * @class StateAttribute\\n     */\\n    var StateAttribute = function () {\\n        Object.call( this );\\n        this._dirty = true;\\n    };\\n\\n    /** @lends StateAttribute.prototype */\\n    StateAttribute.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\\n        isDirty: function () {\\n            return this._dirty;\\n        },\\n        dirty: function () {\\n            this._dirty = true;\\n        },\\n        setDirty: function ( dirty ) {\\n            this._dirty = dirty;\\n        }\\n    } ), \\'osg\\', \\'StateAttribute\\' );\\n\\n    StateAttribute.OFF = 0;\\n    StateAttribute.ON = 1;\\n    StateAttribute.OVERRIDE = 2;\\n    StateAttribute.PROTECTED = 4;\\n    StateAttribute.INHERIT = 8;\\n\\n    return StateAttribute;\\n} );\\n\\n//# sourceURL=/osg/StateAttribute.js\");\n\n",
    "eval(\"define( \\'osg/Vec4\\',[], function () {\\n\\n    /** @class Vec4 Operations */\\n    var Vec4 = {\\n\\n        create: function () {\\n            return [ 0.0, 0.0, 0.0, 0.0 ];\\n        },\\n\\n        init: function ( a ) {\\n            a[ 0 ] = 0.0;\\n            a[ 1 ] = 0.0;\\n            a[ 2 ] = 0.0;\\n            a[ 3 ] = 0.0;\\n            return a;\\n        },\\n\\n        dot: function ( a, b ) {\\n            return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ] + a[ 3 ] * b[ 3 ];\\n        },\\n\\n        copy: function ( a, r ) {\\n            r[ 0 ] = a[ 0 ];\\n            r[ 1 ] = a[ 1 ];\\n            r[ 2 ] = a[ 2 ];\\n            r[ 3 ] = a[ 3 ];\\n            return r;\\n        },\\n\\n        sub: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] - b[ 0 ];\\n            r[ 1 ] = a[ 1 ] - b[ 1 ];\\n            r[ 2 ] = a[ 2 ] - b[ 2 ];\\n            r[ 3 ] = a[ 3 ] - b[ 3 ];\\n            return r;\\n        },\\n\\n        mult: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] * b;\\n            r[ 1 ] = a[ 1 ] * b;\\n            r[ 2 ] = a[ 2 ] * b;\\n            r[ 3 ] = a[ 3 ] * b;\\n            return r;\\n        },\\n\\n        add: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] + b[ 0 ];\\n            r[ 1 ] = a[ 1 ] + b[ 1 ];\\n            r[ 2 ] = a[ 2 ] + b[ 2 ];\\n            r[ 3 ] = a[ 3 ] + b[ 3 ];\\n            return r;\\n        },\\n\\n        neg: function ( a, r ) {\\n            r[ 0 ] = -a[ 0 ];\\n            r[ 1 ] = -a[ 1 ];\\n            r[ 2 ] = -a[ 2 ];\\n            r[ 3 ] = -a[ 3 ];\\n            return r;\\n        },\\n\\n        lerp: function ( t, a, b, r ) {\\n            var tmp = 1.0 - t;\\n            r[ 0 ] = a[ 0 ] * tmp + t * b[ 0 ];\\n            r[ 1 ] = a[ 1 ] * tmp + t * b[ 1 ];\\n            r[ 2 ] = a[ 2 ] * tmp + t * b[ 2 ];\\n            r[ 3 ] = a[ 3 ] * tmp + t * b[ 3 ];\\n            return r;\\n        }\\n    };\\n\\n    return Vec4;\\n} );\\n\\n//# sourceURL=/osg/Vec4.js\");\n\n",
    "eval(\"define( \\'osg/BlendColor\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Vec4\\'\\n], function ( MACROUTILS, StateAttribute, Vec4 ) {\\n\\n    /**\\n     *  Manage BlendColor attribute\\n     *  @class BlendColor\\n     */\\n    var BlendColor = function ( color ) {\\n        StateAttribute.call( this );\\n        this._constantColor = new Array( 4 );\\n        this._constantColor[ 0 ] = this._constantColor[ 1 ] = this._constantColor[ 2 ] = this._constantColor[ 3 ] = 1.0;\\n        if ( color !== undefined ) {\\n            this.setConstantColor( color );\\n        }\\n    };\\n\\n    /** @lends BlendColor.prototype */\\n    BlendColor.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'BlendColor\\',\\n        cloneType: function () {\\n            return new BlendColor();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setConstantColor: function ( color ) {\\n            Vec4.copy( color, this._constantColor );\\n        },\\n        getConstantColor: function () {\\n            return this._constantColor;\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            gl.blendColor( this._constantColor[ 0 ],\\n                this._constantColor[ 1 ],\\n                this._constantColor[ 2 ],\\n                this._constantColor[ 3 ] );\\n            this._dirty = false;\\n        }\\n    } ), \\'osg\\', \\'BlendColor\\' );\\n\\n    return BlendColor;\\n} );\\n\\n//# sourceURL=/osg/BlendColor.js\");\n\n",
    "eval(\"define( \\'osg/BlendFunc\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\'\\n], function ( MACROUTILS, StateAttribute ) {\\n\\n    /**\\n     *  Manage Blending mode\\n     *  @class BlendFunc\\n     */\\n    var BlendFunc = function ( sourceRGB, destinationRGB, sourceAlpha, destinationAlpha ) {\\n        StateAttribute.call( this );\\n        this._sourceFactor = BlendFunc.ONE;\\n        this._destinationFactor = BlendFunc.ZERO;\\n        this._sourceFactorAlpha = this._sourceFactor;\\n        this._destinationFactorAlpha = this._destinationFactor;\\n        this._separate = false;\\n        if ( sourceRGB !== undefined ) {\\n            this.setSource( sourceRGB );\\n        }\\n        if ( destinationRGB !== undefined ) {\\n            this.setDestination( destinationRGB );\\n        }\\n\\n        if ( sourceAlpha !== undefined ) {\\n            this.setSourceAlpha( sourceAlpha );\\n        }\\n        if ( destinationAlpha !== undefined ) {\\n            this.setDestinationAlpha( destinationAlpha );\\n        }\\n    };\\n\\n    BlendFunc.ZERO = 0;\\n    BlendFunc.ONE = 1;\\n    BlendFunc.SRC_COLOR = 0x0300;\\n    BlendFunc.ONE_MINUS_SRC_COLOR = 0x0301;\\n    BlendFunc.SRC_ALPHA = 0x0302;\\n    BlendFunc.ONE_MINUS_SRC_ALPHA = 0x0303;\\n    BlendFunc.DST_ALPHA = 0x0304;\\n    BlendFunc.ONE_MINUS_DST_ALPHA = 0x0305;\\n    BlendFunc.DST_COLOR = 0x0306;\\n    BlendFunc.ONE_MINUS_DST_COLOR = 0x0307;\\n    BlendFunc.SRC_ALPHA_SATURATE = 0x0308;\\n\\n    /* Separate Blend Functions */\\n    BlendFunc.BLEND_DST_RGB = 0x80C8;\\n    BlendFunc.BLEND_SRC_RGB = 0x80C9;\\n    BlendFunc.BLEND_DST_ALPHA = 0x80CA;\\n    BlendFunc.BLEND_SRC_ALPHA = 0x80CB;\\n    BlendFunc.CONSTANT_COLOR = 0x8001;\\n    BlendFunc.ONE_MINUS_CONSTANT_COLOR = 0x8002;\\n    BlendFunc.CONSTANT_ALPHA = 0x8003;\\n    BlendFunc.ONE_MINUS_CONSTANT_ALPHA = 0x8004;\\n    BlendFunc.BLEND_COLOR = 0x8005;\\n\\n\\n    /** @lends BlendFunc.prototype */\\n    BlendFunc.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        /**\\n    StateAttribute type of BlendFunc\\n    @type String\\n     */\\n        attributeType: \\'BlendFunc\\',\\n        /**\\n        Create an instance of this StateAttribute\\n        */\\n        cloneType: function () /**BlendFunc*/ {\\n            return new BlendFunc();\\n        },\\n        /**\\n        @type String\\n        */\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        /**\\n        @type String\\n        */\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setSource: function ( f ) {\\n            this.setSourceRGB( f );\\n            this.setSourceAlpha( f );\\n        },\\n        setDestination: function ( f ) {\\n            this.setDestinationRGB( f );\\n            this.setDestinationAlpha( f );\\n        },\\n        checkSeparate: function () {\\n            return ( this._sourceFactor !== this._sourceFactorAlpha ||\\n                this._destinationFactor !== this._destinationFactorAlpha );\\n        },\\n        setSourceRGB: function ( f ) {\\n            if ( typeof f === \\'string\\' ) {\\n                this._sourceFactor = BlendFunc[ f ];\\n            } else {\\n                this._sourceFactor = f;\\n            }\\n            this._separate = this.checkSeparate();\\n        },\\n        setSourceAlpha: function ( f ) {\\n            if ( typeof f === \\'string\\' ) {\\n                this._sourceFactorAlpha = BlendFunc[ f ];\\n            } else {\\n                this._sourceFactorAlpha = f;\\n            }\\n            this._separate = this.checkSeparate();\\n        },\\n        setDestinationRGB: function ( f ) {\\n            if ( typeof f === \\'string\\' ) {\\n                this._destinationFactor = BlendFunc[ f ];\\n            } else {\\n                this._destinationFactor = f;\\n            }\\n            this._separate = this.checkSeparate();\\n        },\\n        setDestinationAlpha: function ( f ) {\\n            if ( typeof f === \\'string\\' ) {\\n                this._destinationFactorAlpha = BlendFunc[ f ];\\n            } else {\\n                this._destinationFactorAlpha = f;\\n            }\\n            this._separate = this.checkSeparate();\\n        },\\n\\n        /**\\n        Apply the mode, must be called in the draw traversal\\n        @param state\\n    */\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            gl.enable( gl.BLEND );\\n            if ( this._separate ) {\\n                gl.blendFuncSeparate( this._sourceFactor, this._destinationFactor,\\n                    this._sourceFactorAlpha, this._destinationFactorAlpha );\\n            } else {\\n                gl.blendFunc( this._sourceFactor, this._destinationFactor );\\n            }\\n        }\\n    } ), \\'osg\\', \\'BlendFunc\\' );\\n\\n    return BlendFunc;\\n} );\\n\\n//# sourceURL=/osg/BlendFunc.js\");\n\n",
    "eval(\"define( \\'osg/BoundingBox\\',[\\n    \\'osg/Utils\\'\\n], function ( MACROUTILS ) {\\n\\n    var BoundingBox = function () {\\n        this.init();\\n    };\\n    BoundingBox.prototype = MACROUTILS.objectLibraryClass( {\\n        _cacheRadius2: [ 0.0, 0.0, 0.0 ],\\n\\n        init: function () {\\n            this._min = [ Infinity, Infinity, Infinity ];\\n            this._max = [ -Infinity, -Infinity, -Infinity ];\\n        },\\n\\n        copy: function ( bbox ) {\\n            var min = this._min;\\n            var bmin = bbox._min;\\n            min[ 0 ] = bmin[ 0 ];\\n            min[ 1 ] = bmin[ 1 ];\\n            min[ 2 ] = bmin[ 2 ];\\n\\n            var max = this._max;\\n            var bmax = bbox._max;\\n            max[ 0 ] = bmax[ 0 ];\\n            max[ 1 ] = bmax[ 1 ];\\n            max[ 2 ] = bmax[ 2 ];\\n        },\\n\\n        valid: function () {\\n            return ( this._max[ 0 ] >= this._min[ 0 ] && this._max[ 1 ] >= this._min[ 1 ] && this._max[ 2 ] >= this._min[ 2 ] );\\n        },\\n\\n        expandBySphere: function ( sh ) {\\n            if ( !sh.valid() ) {\\n                return;\\n            }\\n            var max = this._max;\\n            var min = this._min;\\n            min[ 0 ] = Math.min( min[ 0 ], sh._center[ 0 ] - sh._radius );\\n            min[ 1 ] = Math.min( min[ 1 ], sh._center[ 1 ] - sh._radius );\\n            min[ 2 ] = Math.min( min[ 2 ], sh._center[ 2 ] - sh._radius );\\n\\n            max[ 0 ] = Math.max( max[ 0 ], sh._center[ 0 ] + sh._radius );\\n            max[ 1 ] = Math.max( max[ 1 ], sh._center[ 1 ] + sh._radius );\\n            max[ 2 ] = Math.max( max[ 2 ], sh._center[ 2 ] + sh._radius );\\n        },\\n\\n        expandByVec3: function ( v ) {\\n            var min = this._min;\\n            var max = this._max;\\n            min[ 0 ] = Math.min( min[ 0 ], v[ 0 ] );\\n            min[ 1 ] = Math.min( min[ 1 ], v[ 1 ] );\\n            min[ 2 ] = Math.min( min[ 2 ], v[ 2 ] );\\n\\n            max[ 0 ] = Math.max( max[ 0 ], v[ 0 ] );\\n            max[ 1 ] = Math.max( max[ 1 ], v[ 1 ] );\\n            max[ 2 ] = Math.max( max[ 2 ], v[ 2 ] );\\n        },\\n\\n        expandByBoundingBox: function ( bb ) {\\n            if ( !bb.valid() )\\n                return;\\n\\n            var min = this._min;\\n            var max = this._max;\\n            var bbmin = bb._min;\\n            var bbmax = bb._max;\\n\\n            if ( bbmin[ 0 ] < min[ 0 ] ) min[ 0 ] = bbmin[ 0 ];\\n            if ( bbmax[ 0 ] > max[ 0 ] ) max[ 0 ] = bbmax[ 0 ];\\n\\n            if ( bbmin[ 1 ] < min[ 1 ] ) min[ 1 ] = bbmin[ 1 ];\\n            if ( bbmax[ 1 ] > max[ 1 ] ) max[ 1 ] = bbmax[ 1 ];\\n\\n            if ( bbmin[ 2 ] < min[ 2 ] ) min[ 2 ] = bbmin[ 2 ];\\n            if ( bbmax[ 2 ] > max[ 2 ] ) max[ 2 ] = bbmax[ 2 ];\\n        },\\n\\n        center: function () {\\n            var min = this._min;\\n            var max = this._max;\\n            return [ ( min[ 0 ] + max[ 0 ] ) * 0.5, ( min[ 1 ] + max[ 1 ] ) * 0.5, ( min[ 2 ] + max[ 2 ] ) * 0.5 ];\\n        },\\n\\n        radius: function () {\\n            return Math.sqrt( this.radius2() );\\n        },\\n\\n        radius2: function () {\\n            var min = this._min;\\n            var max = this._max;\\n            var cache = this._cacheRadius2;\\n            cache[ 0 ] = max[ 0 ] - min[ 0 ];\\n            cache[ 1 ] = max[ 1 ] - min[ 1 ];\\n            cache[ 2 ] = max[ 2 ] - min[ 2 ];\\n            return 0.25 * ( cache[ 0 ] * cache[ 0 ] + cache[ 1 ] * cache[ 1 ] + cache[ 2 ] * cache[ 2 ] );\\n        },\\n        corner: function ( pos ) {\\n            /*jshint bitwise: false */\\n            var ret = [ 0.0, 0.0, 0.0 ];\\n            if ( pos & 1 ) {\\n                ret[ 0 ] = this._max[ 0 ];\\n            } else {\\n                ret[ 0 ] = this._min[ 0 ];\\n            }\\n            if ( pos & 2 ) {\\n                ret[ 1 ] = this._max[ 1 ];\\n            } else {\\n                ret[ 1 ] = this._min[ 1 ];\\n            }\\n            if ( pos & 4 ) {\\n                ret[ 2 ] = this._max[ 2 ];\\n            } else {\\n                ret[ 2 ] = this._min[ 2 ];\\n            }\\n            return ret;\\n            /*jshint bitwise: true */\\n        }\\n    }, \\'osg\\', \\'BoundingBox\\' );\\n\\n    return BoundingBox;\\n} );\\n\\n//# sourceURL=/osg/BoundingBox.js\");\n\n",
    "eval(\"define( \\'osg/Vec3\\',[], function () {\\n\\n    /** @class Vec3 Operations */\\n    var Vec3 = {\\n\\n        create: function () {\\n            return [ 0.0, 0.0, 0.0 ];\\n        },\\n\\n        init: function ( a ) {\\n            a[ 0 ] = 0.0;\\n            a[ 1 ] = 0.0;\\n            a[ 2 ] = 0.0;\\n            return a;\\n        },\\n\\n        copy: function ( a, r ) {\\n            r[ 0 ] = a[ 0 ];\\n            r[ 1 ] = a[ 1 ];\\n            r[ 2 ] = a[ 2 ];\\n            return r;\\n        },\\n\\n        cross: function ( a, b, r ) {\\n            var x = a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ];\\n            var y = a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ];\\n            var z = a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ];\\n            r[ 0 ] = x;\\n            r[ 1 ] = y;\\n            r[ 2 ] = z;\\n            return r;\\n        },\\n\\n        valid: function ( a ) {\\n            if ( isNaN( a[ 0 ] ) ) {\\n                return false;\\n            }\\n            if ( isNaN( a[ 1 ] ) ) {\\n                return false;\\n            }\\n            if ( isNaN( a[ 2 ] ) ) {\\n                return false;\\n            }\\n            return true;\\n        },\\n\\n        mult: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] * b;\\n            r[ 1 ] = a[ 1 ] * b;\\n            r[ 2 ] = a[ 2 ] * b;\\n            return r;\\n        },\\n\\n        length2: function ( a ) {\\n            return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ];\\n        },\\n\\n        length: function ( a ) {\\n            return Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\\n        },\\n\\n        distance2: function ( a, b ) {\\n            var x = a[ 0 ] - b[ 0 ];\\n            var y = a[ 1 ] - b[ 1 ];\\n            var z = a[ 2 ] - b[ 2 ];\\n            return x * x + y * y + z * z;\\n        },\\n\\n        distance: function ( a, b ) {\\n            var x = a[ 0 ] - b[ 0 ];\\n            var y = a[ 1 ] - b[ 1 ];\\n            var z = a[ 2 ] - b[ 2 ];\\n            return Math.sqrt( x * x + y * y + z * z );\\n        },\\n\\n        normalize: function ( a, r ) {\\n            var norm = this.length2( a );\\n            if ( norm > 0.0 ) {\\n                var inv = 1.0 / Math.sqrt( norm );\\n                r[ 0 ] = a[ 0 ] * inv;\\n                r[ 1 ] = a[ 1 ] * inv;\\n                r[ 2 ] = a[ 2 ] * inv;\\n            } else {\\n                r[ 0 ] = a[ 0 ];\\n                r[ 1 ] = a[ 1 ];\\n                r[ 2 ] = a[ 2 ];\\n            }\\n            return r;\\n        },\\n\\n        dot: function ( a, b ) {\\n            return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ];\\n        },\\n\\n        sub: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] - b[ 0 ];\\n            r[ 1 ] = a[ 1 ] - b[ 1 ];\\n            r[ 2 ] = a[ 2 ] - b[ 2 ];\\n            return r;\\n        },\\n\\n        add: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] + b[ 0 ];\\n            r[ 1 ] = a[ 1 ] + b[ 1 ];\\n            r[ 2 ] = a[ 2 ] + b[ 2 ];\\n            return r;\\n        },\\n\\n        neg: function ( a, r ) {\\n            r[ 0 ] = -a[ 0 ];\\n            r[ 1 ] = -a[ 1 ];\\n            r[ 2 ] = -a[ 2 ];\\n            return r;\\n        },\\n\\n        lerp: function ( t, a, b, r ) {\\n            r[ 0 ] = a[ 0 ] + ( b[ 0 ] - a[ 0 ] ) * t;\\n            r[ 1 ] = a[ 1 ] + ( b[ 1 ] - a[ 1 ] ) * t;\\n            r[ 2 ] = a[ 2 ] + ( b[ 2 ] - a[ 2 ] ) * t;\\n            return r;\\n        }\\n\\n    };\\n\\n    return Vec3;\\n} );\\n\\n//# sourceURL=/osg/Vec3.js\");\n\n",
    "eval(\"define( \\'osg/BoundingSphere\\',[\\n    \\'osg/Vec3\\',\\n    \\'osg/BoundingBox\\'\\n], function ( Vec3, BoundingBox ) {\\n\\n    var BoundingSphere = function () {\\n        this._center = [ 0.0, 0.0, 0.0 ];\\n        this._radius = -1;\\n    };\\n\\n    BoundingSphere.prototype = {\\n        init: function () {\\n            Vec3.init( this._center );\\n            this._radius = -1;\\n        },\\n        valid: function () {\\n            return this._radius >= 0.0;\\n        },\\n        set: function ( center, radius ) {\\n            this._center = center;\\n            this._radius = radius;\\n        },\\n        center: function () {\\n            return this._center;\\n        },\\n        radius: function () {\\n            return this._radius;\\n        },\\n        radius2: function () {\\n            return this._radius * this._radius;\\n        },\\n\\n        expandByBox: ( function () {\\n            var v = [ 0.0, 0.0, 0.0 ];\\n            var newbb = new BoundingBox();\\n            return function ( bb ) {\\n                if ( !bb.valid() )\\n                    return;\\n\\n                var c;\\n                if ( this.valid() ) {\\n                    newbb._min[ 0 ] = bb._min[ 0 ];\\n                    newbb._min[ 1 ] = bb._min[ 1 ];\\n                    newbb._min[ 2 ] = bb._min[ 2 ];\\n                    newbb._max[ 0 ] = bb._max[ 0 ];\\n                    newbb._max[ 1 ] = bb._max[ 1 ];\\n                    newbb._max[ 2 ] = bb._max[ 2 ];\\n\\n                    for ( var i = 0; i < 8; i++ ) {\\n                        Vec3.sub( bb.corner( c ), this._center, v ); // get the direction vector from corner\\n                        Vec3.normalize( v, v ); // normalise it.\\n                        v[ 0 ] *= -this._radius; // move the vector in the opposite direction distance radius.\\n                        v[ 1 ] *= -this._radius; // move the vector in the opposite direction distance radius.\\n                        v[ 2 ] *= -this._radius; // move the vector in the opposite direction distance radius.\\n                        v[ 0 ] += this._center[ 0 ]; // move to absolute position.\\n                        v[ 1 ] += this._center[ 1 ]; // move to absolute position.\\n                        v[ 2 ] += this._center[ 2 ]; // move to absolute position.\\n                        newbb.expandBy( v ); // add it into the new bounding box.\\n                    }\\n\\n                    c = newbb.center();\\n                    this._center[ 0 ] = c[ 0 ];\\n                    this._center[ 1 ] = c[ 1 ];\\n                    this._center[ 2 ] = c[ 2 ];\\n                    this._radius = newbb.radius();\\n                } else {\\n                    c = bb.center();\\n                    this._center[ 0 ] = c[ 0 ];\\n                    this._center[ 1 ] = c[ 1 ];\\n                    this._center[ 2 ] = c[ 2 ];\\n                    this._radius = bb.radius();\\n                }\\n            };\\n        } )(),\\n\\n        expandByVec3: ( function () {\\n            var dv = [ 0.0, 0.0, 0.0 ];\\n            return function ( v ) {\\n                if ( this.valid() ) {\\n                    Vec3.sub( v, this.center(), dv );\\n                    var r = Vec3.length( dv );\\n                    if ( r > this.radius() ) {\\n                        var dr = ( r - this.radius() ) * 0.5;\\n                        this._center[ 0 ] += dv[ 0 ] * ( dr / r );\\n                        this._center[ 1 ] += dv[ 1 ] * ( dr / r );\\n                        this._center[ 2 ] += dv[ 2 ] * ( dr / r );\\n                        this._radius += dr;\\n                    }\\n                } else {\\n                    this._center[ 0 ] = v[ 0 ];\\n                    this._center[ 1 ] = v[ 1 ];\\n                    this._center[ 2 ] = v[ 2 ];\\n                    this._radius = 0.0;\\n                }\\n            };\\n        } )(),\\n\\n        expandRadiusBySphere: function ( sh ) {\\n            if ( sh.valid() ) {\\n                if ( this.valid() ) {\\n                    var r = Vec3.distance( sh._center, this._center ) + sh._radius;\\n                    if ( r > this._radius ) {\\n                        this._radius = r;\\n                    }\\n                    // else do nothing as vertex is within sphere.\\n                } else {\\n                    Vec3.copy( sh._center, this._center );\\n                    this._radius = sh._radius;\\n                }\\n            }\\n        },\\n        expandBy: function ( sh ) {\\n            // ignore operation if incomming BoundingSphere is invalid.\\n            if ( !sh.valid() ) {\\n                return;\\n            }\\n\\n            // This sphere is not set so use the inbound sphere\\n            if ( !this.valid() ) {\\n                this._center[ 0 ] = sh._center[ 0 ];\\n                this._center[ 1 ] = sh._center[ 1 ];\\n                this._center[ 2 ] = sh._center[ 2 ];\\n                this._radius = sh.radius();\\n\\n                return;\\n            }\\n\\n            // Calculate d == The distance between the sphere centers\\n            var d = Vec3.distance( this.center(), sh.center() );\\n\\n            // New sphere is already inside this one\\n            if ( d + sh.radius() <= this.radius() ) {\\n                return;\\n            }\\n\\n            //  New sphere completely contains this one\\n            if ( d + this.radius() <= sh.radius() ) {\\n                this._center[ 0 ] = sh._center[ 0 ];\\n                this._center[ 1 ] = sh._center[ 1 ];\\n                this._center[ 2 ] = sh._center[ 2 ];\\n                this._radius = sh._radius;\\n                return;\\n            }\\n\\n\\n            // Build a new sphere that completely contains the other two:\\n            //\\n            // The center point lies halfway along the line between the furthest\\n            // points on the edges of the two spheres.\\n            //\\n            // Computing those two points is ugly - so we\\'ll use similar triangles\\n            var newRadius = ( this.radius() + d + sh.radius() ) * 0.5;\\n            var ratio = ( newRadius - this.radius() ) / d;\\n\\n            this._center[ 0 ] += ( sh._center[ 0 ] - this._center[ 0 ] ) * ratio;\\n            this._center[ 1 ] += ( sh._center[ 1 ] - this._center[ 1 ] ) * ratio;\\n            this._center[ 2 ] += ( sh._center[ 2 ] - this._center[ 2 ] ) * ratio;\\n\\n            this._radius = newRadius;\\n        },\\n        contains: function ( v ) {\\n            if ( !this.valid() )\\n                return false;\\n            return Vec3.distance2( v, this.center() ) <= this.radius2();\\n        },\\n        intersects: function ( bs ) {\\n            if ( !this.valid() )\\n                return false;\\n            if ( !bs.valid() )\\n                return false;\\n            var lc = Vec3.distance2( this.center(), bs.center() );\\n            var r = this.radius() + bs.radius();\\n            return lc <= r;\\n        }\\n    };\\n\\n    return BoundingSphere;\\n} );\\n\\n//# sourceURL=/osg/BoundingSphere.js\");\n\n",
    "eval(\"define( \\'osg/BufferArray\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Object\\'\\n\\n], function ( MACROUTILS, Notify, Object ) {\\n\\n    /**\\n     * BufferArray manage vertex / normal / ... array used by webgl.\\n     * @class BufferArray\\n     */\\n    var BufferArray = function ( type, elements, itemSize ) {\\n\\n        // maybe could inherit from Object\\n        this._instanceID = Object.getInstanceID();\\n\\n        this.dirty();\\n\\n        this._itemSize = itemSize;\\n        if ( typeof ( type ) === \\'string\\' ) {\\n            type = BufferArray[ type ];\\n        }\\n        this._type = type;\\n\\n        if ( elements !== undefined ) {\\n            if ( this._type === BufferArray.ELEMENT_ARRAY_BUFFER ) {\\n                this._elements = new MACROUTILS.Uint16Array( elements );\\n            } else {\\n                this._elements = new MACROUTILS.Float32Array( elements );\\n            }\\n        }\\n    };\\n\\n    BufferArray.ELEMENT_ARRAY_BUFFER = 0x8893;\\n    BufferArray.ARRAY_BUFFER = 0x8892;\\n\\n\\n    /** @lends BufferArray.prototype */\\n    BufferArray.prototype = {\\n        setItemSize: function ( size ) {\\n            this._itemSize = size;\\n        },\\n        isValid: function () {\\n            if ( this._buffer !== undefined ||\\n                this._elements !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        },\\n\\n        releaseGLObjects: function ( gl ) {\\n            if ( this._buffer !== undefined && this._buffer !== null ) {\\n                gl.deleteBuffer( this._buffer );\\n            }\\n            this._buffer = undefined;\\n        },\\n\\n        bind: function ( gl ) {\\n\\n            var type = this._type;\\n            var buffer = this._buffer;\\n\\n            if ( buffer ) {\\n                gl.bindBuffer( type, buffer );\\n                return;\\n            }\\n\\n            if ( !buffer && this._elements.length > 0 ) {\\n                this._buffer = gl.createBuffer();\\n                this._numItems = this._elements.length / this._itemSize;\\n                gl.bindBuffer( type, this._buffer );\\n            }\\n        },\\n        getItemSize: function () {\\n            return this._itemSize;\\n        },\\n        dirty: function () {\\n            this._dirty = true;\\n        },\\n        isDirty: function () {\\n            return this._dirty;\\n        },\\n        compile: function ( gl ) {\\n            if ( this._dirty ) {\\n                MACROUTILS.timeStamp( \\'osgjs.metrics:bufferData\\' );\\n                gl.bufferData( this._type, this._elements, gl.STATIC_DRAW );\\n                this._dirty = false;\\n            }\\n        },\\n        getElements: function () {\\n            return this._elements;\\n        },\\n        setElements: function ( elements ) {\\n            this._elements = elements;\\n            this._dirty = true;\\n        }\\n    };\\n\\n    BufferArray.create = function ( type, elements, itemSize ) {\\n        Notify.log( \\'BufferArray.create is deprecated, use new BufferArray with same arguments instead\\' );\\n        return new BufferArray( type, elements, itemSize );\\n    };\\n\\n    return BufferArray;\\n} );\\n\\n//# sourceURL=/osg/BufferArray.js\");\n\n",
    "eval(\"define( \\'osg/Map\\',[\\n\\n], function () {\\n    \\'use strict\\';\\n\\n    var Map = function( obj ) {\\n\\n        Object.defineProperty ( this, \\'_dirty\\', {\\n            configurable: true,\\n            enumerable: false,\\n            writable: true,\\n            value: true\\n        });\\n\\n        Object.defineProperty ( this, \\'_keys\\', {\\n            configurable: true,\\n            enumerable: false,\\n            writable: true,\\n            value: undefined\\n        });\\n\\n        if ( obj ) this.setMap( obj );\\n    };\\n\\n    Map.prototype = {\\n\\n        getKeys: function() {\\n            if ( this._dirty ) {\\n                this._keys = Object.keys( this );\\n                this._dirty = false;\\n            }\\n            return this._keys;\\n        },\\n\\n        dirty: function() {\\n            this._dirty = true;\\n        },\\n\\n\\n        setMap: function( map ) {\\n\\n            var i,l;\\n            // remove all\\n            var keys = Object.keys( this );\\n            if ( keys.length > 0) {\\n                for ( i = 0, l = keys.length; i < l; i++)\\n                    delete this[ keys[i] ];\\n            }\\n\\n            // add new\\n            keys = Object.keys( map );\\n            if ( keys.length > 0) {\\n                for ( i = 0, l = keys.length; i < l; i++ ) {\\n                    var key = keys[ i ];\\n                    this[ key ] = map[ key ];\\n                }\\n            }\\n\\n            this.dirty();\\n        }\\n\\n    };\\n\\n    return Map;\\n\\n});\\n\\n//# sourceURL=/osg/Map.js\");\n\n",
    "eval(\"define( \\'osg/StateSet\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Object\\',\\n    \\'osg/Map\\'\\n], function ( MACROUTILS, StateAttribute, Object, Map ) {\\n\\n    \\'use strict\\';\\n\\n    /**\\n     * StateSet encapsulate StateAttribute\\n     * @class StateSet\\n     */\\n    var StateSet = function () {\\n        Object.call( this );\\n        this.id = StateSet.instance++;\\n\\n        this.attributeMap = new Map();\\n\\n        this.textureAttributeMapList = [];\\n\\n        this._binName = undefined;\\n        this._binNumber = 0;\\n\\n        this._shaderGenerator = undefined;\\n        this._updateCallbackList = [];\\n\\n        this.uniforms = new Map();\\n\\n    };\\n    StateSet.instance = 0;\\n\\n    StateSet.AttributePair = function ( attr, value ) {\\n        this._object = attr;\\n        this._value = value;\\n    };\\n    StateSet.AttributePair.prototype = {\\n        getAttribute: function () {\\n            return this._object;\\n        },\\n        getUniform: function () {\\n            return this._object;\\n        },\\n        getValue: function () {\\n            return this._value;\\n        }\\n    };\\n\\n    /** @lends StateSet.prototype */\\n    StateSet.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Object.prototype, {\\n        getAttributePair: function ( attribute, value ) {\\n            return new StateSet.AttributePair( attribute, value );\\n        },\\n        addUniform: function ( uniform, mode ) {\\n            if ( mode === undefined ) {\\n                mode = StateAttribute.ON;\\n            }\\n\\n            var name = uniform.name;\\n            this.uniforms[ name ] = this.getAttributePair( uniform, mode );\\n            this.uniforms.dirty();\\n        },\\n        getUniform: function ( uniform ) {\\n            var uniformMap = this.uniforms;\\n            if ( uniformMap[ uniform ] ) return uniformMap[ uniform ].getAttribute();\\n\\n            return undefined;\\n        },\\n        getUniformList: function () {\\n            return this.uniforms;\\n        },\\n\\n        setTextureAttributeAndMode: function ( unit, attribute, mode ) {\\n            if ( mode === undefined ) {\\n                mode = StateAttribute.ON;\\n            }\\n            this._setTextureAttribute( unit, this.getAttributePair( attribute, mode ) );\\n        },\\n        getNumTextureAttributeLists: function () {\\n            return this.textureAttributeMapList.length;\\n        },\\n        getTextureAttribute: function ( unit, attribute ) {\\n            if ( this.textureAttributeMapList[ unit ] === undefined ) return undefined;\\n\\n            var textureMap = this.textureAttributeMapList[ unit ];\\n            if ( textureMap[ attribute ] === undefined ) return undefined;\\n\\n            return textureMap[ attribute ].getAttribute();\\n        },\\n\\n        removeTextureAttribute: function ( unit, attributeName ) {\\n            if ( this.textureAttributeMapList[ unit ] === undefined ) return;\\n\\n            var textureAttributeMap = this.textureAttributeMapList[ unit ];\\n            if ( textureAttributeMap[ attributeName ] === undefined ) return;\\n\\n\\n            delete textureAttributeMap[ attributeName ];\\n            this.textureAttributeMapList[ unit ].dirty();\\n        },\\n\\n        getAttribute: function ( attributeType ) {\\n            if ( this.attributeMap[ attributeType ] === undefined ) {\\n                return undefined;\\n            }\\n            return this.attributeMap[ attributeType ].getAttribute();\\n        },\\n\\n        setAttributeAndMode: function ( attribute, mode ) {\\n            if ( mode === undefined ) {\\n                mode = StateAttribute.ON;\\n            }\\n            this._setAttribute( this.getAttributePair( attribute, mode ) );\\n        },\\n        setAttribute: function ( attribute, mode ) {\\n            if ( mode === undefined ) {\\n                mode = StateAttribute.ON;\\n            }\\n            this._setAttribute( this.getAttributePair( attribute, mode ) );\\n        },\\n\\n        // TODO: check if it\\'s an attribute type or a attribute to remove it\\n        removeAttribute: function ( attributeName ) {\\n\\n            if ( this.attributeMap[ attributeName ] !== undefined ) {\\n                delete this.attributeMap[ attributeName ];\\n                this.attributeMap.dirty();\\n            }\\n        },\\n\\n        setRenderingHint: function ( hint ) {\\n            if ( hint === \\'OPAQUE_BIN\\' ) {\\n                this.setRenderBinDetails( 0, \\'RenderBin\\' );\\n            } else if ( hint === \\'TRANSPARENT_BIN\\' ) {\\n                this.setRenderBinDetails( 10, \\'DepthSortedBin\\' );\\n            } else {\\n                this.setRenderBinDetails( 0, \\'\\' );\\n            }\\n        },\\n\\n        getUpdateCallbackList: function () {\\n            return this._updateCallbackList;\\n        },\\n        removeUpdateCallback: function ( cb ) {\\n            var arrayIdx = this._updateCallbackList.indexOf( cb );\\n            if ( arrayIdx !== -1 )\\n                this._updateCallbackList.splice( arrayIdx, 1 );\\n        },\\n        addUpdateCallback: function ( cb ) {\\n            this._updateCallbackList.push( cb );\\n        },\\n        hasUpdateCallback: function ( cb ) {\\n            return this._updateCallbackList.indexOf( cb ) !== -1;\\n        },\\n\\n        setRenderBinDetails: function ( num, binName ) {\\n            this._binNumber = num;\\n            this._binName = binName;\\n        },\\n        getAttributeMap: function () {\\n            return this.attributeMap;\\n        },\\n        getBinNumber: function () {\\n            return this._binNumber;\\n        },\\n        getBinName: function () {\\n            return this._binName;\\n        },\\n        setBinNumber: function ( binNum ) {\\n            this._binNumber = binNum;\\n        },\\n        setBinName: function ( binName ) {\\n            this._binName = binName;\\n        },\\n        getAttributeList: function () {\\n            var attributeMap = this.attributeMap;\\n            var attributeMapKeys = attributeMap.getKeys();\\n\\n            var l = attributeMapKeys.length;\\n            var list = [];\\n            for ( var i = 0; i < l; i++ ) {\\n                list.push( attributeMap[ attributeMapKeys[ i ] ] );\\n            }\\n            return list;\\n        },\\n        setShaderGenerator: function ( generator ) {\\n            this._shaderGenerator = generator;\\n        },\\n        getShaderGenerator: function () {\\n            return this._shaderGenerator;\\n        },\\n        _getUniformMap: function () {\\n            return this.uniforms;\\n        },\\n\\n        // for internal use, you should not call it directly\\n        _setTextureAttribute: function ( unit, attributePair ) {\\n\\n            if ( this.textureAttributeMapList[ unit ] === undefined ) {\\n                this.textureAttributeMapList[ unit ] = new Map();\\n            }\\n\\n            var name = attributePair.getAttribute().getTypeMember();\\n            var textureUnitAttributeMap = this.textureAttributeMapList[ unit ];\\n\\n            textureUnitAttributeMap[ name ] = attributePair;\\n            textureUnitAttributeMap.dirty();\\n\\n        },\\n\\n        // for internal use, you should not call it directly\\n        _setAttribute: function ( attributePair ) {\\n\\n            var name = attributePair.getAttribute().getTypeMember();\\n            this.attributeMap[ name ] = attributePair;\\n            this.attributeMap.dirty();\\n\\n        }\\n\\n    } ), \\'osg\\', \\'StateSet\\' );\\n    StateSet.prototype.setTextureAttributeAndModes = StateSet.prototype.setTextureAttributeAndMode;\\n    StateSet.prototype.setAttributeAndModes = StateSet.prototype.setAttributeAndMode;\\n\\n    return StateSet;\\n} );\\n\\n//# sourceURL=/osg/StateSet.js\");\n\n",
    "eval(\"define( \\'osg/FrameStamp\\',[\\n], function () {\\n\\n    var FrameStamp = function () {\\n        var frame = 0;\\n        var startSimulation = 0.0;\\n        var currentSimulation = 0.0;\\n\\n        this.setReferenceTime = function ( s ) {\\n            startSimulation = s;\\n        };\\n        this.setSimulationTime = function ( s ) {\\n            currentSimulation = s;\\n        };\\n        this.getReferenceTime = function () {\\n            return startSimulation;\\n        };\\n        this.getSimulationTime = function () {\\n            return currentSimulation;\\n        };\\n        this.setFrameNumber = function ( n ) {\\n            frame = n;\\n        };\\n        this.getFrameNumber = function () {\\n            return frame;\\n        };\\n    };\\n\\n    return FrameStamp;\\n} );\\n\\n//# sourceURL=/osg/FrameStamp.js\");\n\n",
    "eval(\"define( \\'osg/NodeVisitor\\',[ \\'osg/FrameStamp\\' ], function ( FrameStamp ) {\\n\\n    var NodeVisitor = function ( traversalMode ) {\\n        /*jshint bitwise: false */\\n        this.traversalMask = ~0x0;\\n        /*jshint bitwise: true */\\n        this.nodeMaskOverride = 0;\\n        this.traversalMode = traversalMode;\\n        if ( traversalMode === undefined ) {\\n            this.traversalMode = NodeVisitor.TRAVERSE_ALL_CHILDREN;\\n        }\\n        this.nodePath = [];\\n        this.visitorType = NodeVisitor.NODE_VISITOR;\\n\\n        var framestamp = new FrameStamp();\\n        this.getFrameStamp = function () {\\n            return framestamp;\\n        };\\n        this.setFrameStamp = function ( s ) {\\n            framestamp = s;\\n        };\\n    };\\n    //NodeVisitor.TRAVERSE_NONE = 0;\\n    NodeVisitor.TRAVERSE_PARENTS = 1;\\n    NodeVisitor.TRAVERSE_ALL_CHILDREN = 2;\\n    NodeVisitor.TRAVERSE_ACTIVE_CHILDREN = 3;\\n    NodeVisitor.NODE_VISITOR = 0;\\n    NodeVisitor.UPDATE_VISITOR = 1;\\n    NodeVisitor.CULL_VISITOR = 2;\\n\\n    \\n    NodeVisitor._traversalFunctions = {};\\n    NodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_PARENTS ] = function ( node ) {\\n        node.ascend( this );\\n    };\\n    NodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function ( node ) {\\n        node.traverse( this );\\n    };\\n\\tNodeVisitor._traversalFunctions[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function ( node ) {\\n        node.traverse( this );\\n    };\\n\\t\\n\\t\\n    NodeVisitor._pushOntoNodePath = {};\\n    NodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_PARENTS ] = function ( node ) {\\n        this.nodePath.unshift( node );\\n    };\\n    NodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function ( node ) {\\n        this.nodePath.push( node );\\n    };\\n\\tNodeVisitor._pushOntoNodePath[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function ( node ) {\\n        this.nodePath.push( node );\\n    };\\n    NodeVisitor._popFromNodePath = {};\\n    NodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_PARENTS ] = function () {\\n        return this.nodePath.shift();\\n    };\\n    NodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_ALL_CHILDREN ] = function () {\\n        this.nodePath.pop();\\n    };\\n\\tNodeVisitor._popFromNodePath[ NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ] = function () {\\n        this.nodePath.pop();\\n    };\\n\\n    NodeVisitor.prototype = {\\n        setNodeMaskOverride: function ( m ) {\\n            this.nodeMaskOverride = m;\\n        },\\n        getNodeMaskOverride: function () {\\n            return this.nodeMaskOverride;\\n        },\\n\\n        setTraversalMask: function ( m ) {\\n            this.traversalMask = m;\\n        },\\n        getTraversalMask: function () {\\n            return this.traversalMask;\\n        },\\n\\n        pushOntoNodePath: function ( node ) {\\n            NodeVisitor._pushOntoNodePath[ this.traversalMode ].call( this, node );\\n        },\\n        popFromNodePath: function () {\\n            NodeVisitor._popFromNodePath[ this.traversalMode ].call( this );\\n        },\\n        validNodeMask: function ( node ) {\\n            var nm = node.getNodeMask();\\n            /*jshint bitwise: false */\\n            return ( ( this.traversalMask & ( this.nodeMaskOverride | nm ) ) !== 0 );\\n            /*jshint bitwise: true */\\n        },\\n        apply: function ( node ) {\\n            this.traverse( node );\\n        },\\n        traverse: function ( node ) {\\n            NodeVisitor._traversalFunctions[ this.traversalMode ].call( this, node );\\n        },\\n        getVisitorType: function ( ) {\\n            return this.visitorType;\\n        }\\n    };\\n\\n    return NodeVisitor;\\n} );\\n\\n//# sourceURL=/osg/NodeVisitor.js\");\n\n",
    "eval(\"define( \\'osg/Quat\\',[\\n    \\'osg/Vec3\\',\\n    \\'osg/Notify\\'\\n], function ( Vec3, Notify ) {\\n\\n    /** @class Quaternion Operations */\\n    var Quat = {\\n        create: function () {\\n            return [ 0.0, 0.0, 0.0, 1.0 ];\\n        },\\n        copy: function ( s, d ) {\\n            d[ 0 ] = s[ 0 ];\\n            d[ 1 ] = s[ 1 ];\\n            d[ 2 ] = s[ 2 ];\\n            d[ 3 ] = s[ 3 ];\\n            return d;\\n        },\\n        makeIdentity: function ( element ) {\\n            return Quat.init( element );\\n        },\\n        zeroRotation: function ( element ) {\\n            return Quat.init( element );\\n        },\\n\\n        init: function ( element ) {\\n            element[ 0 ] = 0.0;\\n            element[ 1 ] = 0.0;\\n            element[ 2 ] = 0.0;\\n            element[ 3 ] = 1.0;\\n            return element;\\n        },\\n\\n        sub: function ( a, b, result ) {\\n            result[ 0 ] = a[ 0 ] - b[ 0 ];\\n            result[ 1 ] = a[ 1 ] - b[ 1 ];\\n            result[ 2 ] = a[ 2 ] - b[ 2 ];\\n            result[ 3 ] = a[ 3 ] - b[ 3 ];\\n            return result;\\n        },\\n\\n        add: function ( a, b, result ) {\\n            result[ 0 ] = a[ 0 ] + b[ 0 ];\\n            result[ 1 ] = a[ 1 ] + b[ 1 ];\\n            result[ 2 ] = a[ 2 ] + b[ 2 ];\\n            result[ 3 ] = a[ 3 ] + b[ 3 ];\\n            return result;\\n        },\\n\\n        dot: function ( a, b ) {\\n            return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ] + a[ 2 ] * b[ 2 ] + a[ 3 ] * b[ 3 ];\\n        },\\n\\n        length2: function ( a ) {\\n            return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] + a[ 3 ] * a[ 3 ];\\n        },\\n\\n        neg: function ( a, result ) {\\n            result[ 0 ] = -a[ 0 ];\\n            result[ 1 ] = -a[ 1 ];\\n            result[ 2 ] = -a[ 2 ];\\n            result[ 3 ] = -a[ 3 ];\\n            return result;\\n        },\\n\\n        makeRotate: function ( angle, x, y, z, result ) {\\n            if ( result === undefined ) {\\n                result = [ 0.0, 0.0, 0.0, 0.0 ];\\n            }\\n\\n            var epsilon = 0.0000001;\\n            var length = Math.sqrt( x * x + y * y + z * z );\\n            if ( length < epsilon ) {\\n                return this.init( result );\\n            }\\n\\n            var inversenorm = 1.0 / length;\\n            var coshalfangle = Math.cos( 0.5 * angle );\\n            var sinhalfangle = Math.sin( 0.5 * angle );\\n\\n            result[ 0 ] = x * sinhalfangle * inversenorm;\\n            result[ 1 ] = y * sinhalfangle * inversenorm;\\n            result[ 2 ] = z * sinhalfangle * inversenorm;\\n            result[ 3 ] = coshalfangle;\\n            return result;\\n        },\\n\\n        lerp: function ( t, a, b, r ) {\\n            r[ 0 ] = a[ 0 ] + ( b[ 0 ] - a[ 0 ] ) * t;\\n            r[ 1 ] = a[ 1 ] + ( b[ 1 ] - a[ 1 ] ) * t;\\n            r[ 2 ] = a[ 2 ] + ( b[ 2 ] - a[ 2 ] ) * t;\\n            r[ 3 ] = a[ 3 ] + ( b[ 3 ] - a[ 3 ] ) * t;\\n            return r;\\n        },\\n\\n        slerp: function ( t, from, to, result ) {\\n            var epsilon = 0.00001;\\n\\n            var quatTo = to;\\n            var cosomega = this.dot( from, quatTo );\\n            if ( cosomega < 0.0 ) {\\n                cosomega = -cosomega;\\n                this.neg( to, quatTo );\\n            }\\n\\n            var omega;\\n            var sinomega;\\n            var scaleFrom;\\n            var scaleTo;\\n            if ( ( 1.0 - cosomega ) > epsilon ) {\\n                omega = Math.acos( cosomega ); // 0 <= omega <= Pi (see man acos)\\n                sinomega = Math.sin( omega ); // this sinomega should always be +ve so\\n                // could try sinomega=sqrt(1-cosomega*cosomega) to avoid a sin()?\\n                scaleFrom = Math.sin( ( 1.0 - t ) * omega ) / sinomega;\\n                scaleTo = Math.sin( t * omega ) / sinomega;\\n            } else {\\n                /* --------------------------------------------------\\n             The ends of the vectors are very close\\n             we can use simple linear interpolation - no need\\n             to worry about the \\'spherical\\' interpolation\\n             -------------------------------------------------- */\\n                scaleFrom = 1.0 - t;\\n                scaleTo = t;\\n            }\\n\\n            result[ 0 ] = from[ 0 ] * scaleFrom + quatTo[ 0 ] * scaleTo;\\n            result[ 1 ] = from[ 1 ] * scaleFrom + quatTo[ 1 ] * scaleTo;\\n            result[ 2 ] = from[ 2 ] * scaleFrom + quatTo[ 2 ] * scaleTo;\\n            result[ 3 ] = from[ 3 ] * scaleFrom + quatTo[ 3 ] * scaleTo;\\n            return result;\\n        },\\n\\n        transformVec3: ( function () {\\n            var uv = [ 0.0, 0.0, 0.0 ];\\n            return function ( q, vec, result ) {\\n                // nVidia SDK implementation\\n                Vec3.cross( q, vec, uv );\\n                Vec3.cross( q, uv, result );\\n                Vec3.mult( uv, 2.0 * q[ 3 ], uv );\\n                Vec3.mult( result, 2.0, result );\\n                Vec3.add( result, uv, result );\\n                Vec3.add( result, vec, result );\\n                return result;\\n            };\\n        } )(),\\n\\n        normalize: function ( q, qr ) {\\n            var div = 1.0 / this.length2( q );\\n            qr[ 0 ] = q[ 0 ] * div;\\n            qr[ 1 ] = q[ 1 ] * div;\\n            qr[ 2 ] = q[ 2 ] * div;\\n            qr[ 3 ] = q[ 3 ] * div;\\n            return qr;\\n        },\\n\\n        // we suppose to have unit quaternion\\n        conj: function ( a, result ) {\\n            result[ 0 ] = -a[ 0 ];\\n            result[ 1 ] = -a[ 1 ];\\n            result[ 2 ] = -a[ 2 ];\\n            result[ 3 ] = a[ 3 ];\\n            return result;\\n        },\\n\\n        inverse: function ( a, result ) {\\n            var div = 1.0 / this.length2( a );\\n            this.conj( a, result );\\n            result[ 0 ] *= div;\\n            result[ 1 ] *= div;\\n            result[ 2 ] *= div;\\n            result[ 3 ] *= div;\\n            return result;\\n        },\\n\\n        // we suppose to have unit quaternion\\n        // multiply 2 quaternions\\n        mult: function ( a, b, result ) {\\n            result[ 0 ] = a[ 0 ] * b[ 3 ] + a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ] + a[ 3 ] * b[ 0 ];\\n            result[ 1 ] = -a[ 0 ] * b[ 2 ] + a[ 1 ] * b[ 3 ] + a[ 2 ] * b[ 0 ] + a[ 3 ] * b[ 1 ];\\n            result[ 2 ] = a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] + a[ 2 ] * b[ 3 ] + a[ 3 ] * b[ 2 ];\\n            result[ 3 ] = -a[ 0 ] * b[ 0 ] - a[ 1 ] * b[ 1 ] - a[ 2 ] * b[ 2 ] + a[ 3 ] * b[ 3 ];\\n            return result;\\n        },\\n        div: function ( a, b, result ) {\\n            var d = 1.0 / b;\\n            result[ 0 ] = a[ 0 ] * d;\\n            result[ 1 ] = a[ 1 ] * d;\\n            result[ 2 ] = a[ 2 ] * d;\\n            result[ 3 ] = a[ 3 ] * d;\\n            return result;\\n        },\\n        exp: function ( a, res ) {\\n            var r = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );\\n            var et = Math.exp( a[ 3 ] );\\n            var s = 0;\\n            if ( r > 0.00001 ) {\\n                s = et * Math.sin( r ) / r;\\n            }\\n            if ( res === undefined ) {\\n                Notify.warn( \\'no quat destination !\\' );\\n                res = Quat.create();\\n            }\\n            res[ 0 ] = s * a[ 0 ];\\n            res[ 1 ] = s * a[ 1 ];\\n            res[ 2 ] = s * a[ 2 ];\\n            res[ 3 ] = et * Math.cos( r );\\n            return res;\\n        },\\n\\n        ln: function ( a, res ) {\\n            var n = a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ];\\n            var r = Math.sqrt( n );\\n            var t = 0;\\n            if ( r > 0.00001 ) {\\n                t = Math.atan2( r, a[ 3 ] ) / r;\\n            }\\n            if ( res === undefined ) {\\n                Notify.warn( \\'no quat destination !\\' );\\n                res = Quat.create();\\n            }\\n            n += a[ 3 ] * a[ 3 ];\\n            res[ 0 ] = t * a[ 0 ];\\n            res[ 1 ] = t * a[ 1 ];\\n            res[ 2 ] = t * a[ 2 ];\\n            res[ 3 ] = 0.5 * Math.log( n );\\n            return res;\\n        },\\n\\n\\n        //http://theory.org/software/qfa/writeup/node12.html\\n        //http://www.ece.uwaterloo.ca/~dwharder/C++/CQOST/src/\\n        //http://willperone.net/Code/quaternion.php\\n\\n        // a is computeTangent(q1-1,q1,q2)\\n        // b is computeTangent(q2-1,q2,q2+1)\\n        squad: function ( t, q1, a, b, q2, r ) {\\n            var r1 = this.slerp( t, q1, q2 );\\n            var r2 = this.slerp( t, a, b );\\n            return this.slerp( 2.0 * t * ( 1.0 - t ), r1, r2, r );\\n        },\\n\\n        // qcur is current\\n        // q0 is qcur-1\\n        // q2 is qcur+1\\n        // compute tangent in of q1\\n        computeTangent: function ( q0, qcur, q2, r ) {\\n\\n            // first step\\n            var invq = this.inv( qcur );\\n            var qa, qb;\\n\\n            this.mult( q2, invq, qa );\\n            this.ln( qa, qa );\\n\\n            this.mult( q0, invq, qb );\\n            this.ln( qb, qb );\\n\\n            this.add( qa, qb, qa );\\n            this.div( qa, -4.0, qa );\\n            this.exp( qa, qb );\\n            return this.mult( qb, qcur, r );\\n        }\\n\\n    };\\n\\n    return Quat;\\n} );\\n\\n//# sourceURL=/osg/Quat.js\");\n\n",
    "eval(\"define( \\'osg/Matrix\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Vec4\\',\\n    \\'osg/Quat\\'\\n], function ( Notify, Vec3, Vec4, Quat ) {\\n\\n    /** @class Matrix Operations */\\n    var Matrix = {\\n\\n        create: function () {\\n            return [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ];\\n        },\\n\\n        valid: function ( matrix ) {\\n            for ( var i = 0; i < 16; i++ ) {\\n                if ( isNaN( matrix[ i ] ) ) {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        },\\n        setRow: function ( matrix, row, v0, v1, v2, v3 ) {\\n            var rowIndex = row * 4;\\n            matrix[ rowIndex + 0 ] = v0;\\n            matrix[ rowIndex + 1 ] = v1;\\n            matrix[ rowIndex + 2 ] = v2;\\n            matrix[ rowIndex + 3 ] = v3;\\n        },\\n        innerProduct: function ( a, b, r, c ) {\\n            var rIndex = r * 4;\\n            return ( ( a[ rIndex + 0 ] * b[ 0 + c ] ) + ( a[ rIndex + 1 ] * b[ 4 + c ] ) + ( a[ rIndex + 2 ] * b[ 8 + c ] ) + ( a[ rIndex + 3 ] * b[ 12 + c ] ) );\\n        },\\n\\n        set: function ( matrix, row, col, value ) {\\n            matrix[ row * 4 + col ] = value;\\n            return value;\\n        },\\n\\n        get: function ( matrix, row, col ) {\\n            return matrix[ row * 4 + col ];\\n        },\\n\\n        makeIdentity: function ( matrix ) {\\n            if ( matrix === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                return Matrix.create();\\n            }\\n            Matrix.setRow( matrix, 0, 1.0, 0.0, 0.0, 0.0 );\\n            Matrix.setRow( matrix, 1, 0.0, 1.0, 0.0, 0.0 );\\n            Matrix.setRow( matrix, 2, 0.0, 0.0, 1.0, 0.0 );\\n            Matrix.setRow( matrix, 3, 0.0, 0.0, 0.0, 1.0 );\\n            return matrix;\\n        },\\n\\n        /**\\n         * @param {Number} x position\\n         * @param {Number} y position\\n         * @param {Number} z position\\n         * @param {Array} matrix to write result\\n         */\\n        makeTranslate: function ( x, y, z, matrix ) {\\n            if ( matrix === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                matrix = Matrix.create();\\n                Matrix.setRow( matrix, 3, x, y, z, 1.0 );\\n                return matrix;\\n            }\\n            Matrix.setRow( matrix, 0, 1.0, 0.0, 0.0, 0.0 );\\n            Matrix.setRow( matrix, 1, 0.0, 1.0, 0.0, 0.0 );\\n            Matrix.setRow( matrix, 2, 0.0, 0.0, 1.0, 0.0 );\\n            Matrix.setRow( matrix, 3, x, y, z, 1.0 );\\n            return matrix;\\n        },\\n\\n        setTrans: function ( matrix, x, y, z ) {\\n            matrix[ 12 ] = x;\\n            matrix[ 13 ] = y;\\n            matrix[ 14 ] = z;\\n            return matrix;\\n        },\\n\\n        getTrans: function ( matrix, result ) {\\n            result[ 0 ] = matrix[ 12 ];\\n            result[ 1 ] = matrix[ 13 ];\\n            result[ 2 ] = matrix[ 14 ];\\n            return result;\\n        },\\n\\n        // do a * b and result in a\\n        preMult: function ( a, b ) {\\n            var atmp0, atmp1, atmp2, atmp3;\\n\\n            atmp0 = ( b[ 0 ] * a[ 0 ] ) + ( b[ 1 ] * a[ 4 ] ) + ( b[ 2 ] * a[ 8 ] ) + ( b[ 3 ] * a[ 12 ] );\\n            atmp1 = ( b[ 4 ] * a[ 0 ] ) + ( b[ 5 ] * a[ 4 ] ) + ( b[ 6 ] * a[ 8 ] ) + ( b[ 7 ] * a[ 12 ] );\\n            atmp2 = ( b[ 8 ] * a[ 0 ] ) + ( b[ 9 ] * a[ 4 ] ) + ( b[ 10 ] * a[ 8 ] ) + ( b[ 11 ] * a[ 12 ] );\\n            atmp3 = ( b[ 12 ] * a[ 0 ] ) + ( b[ 13 ] * a[ 4 ] ) + ( b[ 14 ] * a[ 8 ] ) + ( b[ 15 ] * a[ 12 ] );\\n            a[ 0 ] = atmp0;\\n            a[ 4 ] = atmp1;\\n            a[ 8 ] = atmp2;\\n            a[ 12 ] = atmp3;\\n\\n            atmp0 = ( b[ 0 ] * a[ 1 ] ) + ( b[ 1 ] * a[ 5 ] ) + ( b[ 2 ] * a[ 9 ] ) + ( b[ 3 ] * a[ 13 ] );\\n            atmp1 = ( b[ 4 ] * a[ 1 ] ) + ( b[ 5 ] * a[ 5 ] ) + ( b[ 6 ] * a[ 9 ] ) + ( b[ 7 ] * a[ 13 ] );\\n            atmp2 = ( b[ 8 ] * a[ 1 ] ) + ( b[ 9 ] * a[ 5 ] ) + ( b[ 10 ] * a[ 9 ] ) + ( b[ 11 ] * a[ 13 ] );\\n            atmp3 = ( b[ 12 ] * a[ 1 ] ) + ( b[ 13 ] * a[ 5 ] ) + ( b[ 14 ] * a[ 9 ] ) + ( b[ 15 ] * a[ 13 ] );\\n            a[ 1 ] = atmp0;\\n            a[ 5 ] = atmp1;\\n            a[ 9 ] = atmp2;\\n            a[ 13 ] = atmp3;\\n\\n            atmp0 = ( b[ 0 ] * a[ 2 ] ) + ( b[ 1 ] * a[ 6 ] ) + ( b[ 2 ] * a[ 10 ] ) + ( b[ 3 ] * a[ 14 ] );\\n            atmp1 = ( b[ 4 ] * a[ 2 ] ) + ( b[ 5 ] * a[ 6 ] ) + ( b[ 6 ] * a[ 10 ] ) + ( b[ 7 ] * a[ 14 ] );\\n            atmp2 = ( b[ 8 ] * a[ 2 ] ) + ( b[ 9 ] * a[ 6 ] ) + ( b[ 10 ] * a[ 10 ] ) + ( b[ 11 ] * a[ 14 ] );\\n            atmp3 = ( b[ 12 ] * a[ 2 ] ) + ( b[ 13 ] * a[ 6 ] ) + ( b[ 14 ] * a[ 10 ] ) + ( b[ 15 ] * a[ 14 ] );\\n            a[ 2 ] = atmp0;\\n            a[ 6 ] = atmp1;\\n            a[ 10 ] = atmp2;\\n            a[ 14 ] = atmp3;\\n\\n            atmp0 = ( b[ 0 ] * a[ 3 ] ) + ( b[ 1 ] * a[ 7 ] ) + ( b[ 2 ] * a[ 11 ] ) + ( b[ 3 ] * a[ 15 ] );\\n            atmp1 = ( b[ 4 ] * a[ 3 ] ) + ( b[ 5 ] * a[ 7 ] ) + ( b[ 6 ] * a[ 11 ] ) + ( b[ 7 ] * a[ 15 ] );\\n            atmp2 = ( b[ 8 ] * a[ 3 ] ) + ( b[ 9 ] * a[ 7 ] ) + ( b[ 10 ] * a[ 11 ] ) + ( b[ 11 ] * a[ 15 ] );\\n            atmp3 = ( b[ 12 ] * a[ 3 ] ) + ( b[ 13 ] * a[ 7 ] ) + ( b[ 14 ] * a[ 11 ] ) + ( b[ 15 ] * a[ 15 ] );\\n            a[ 3 ] = atmp0;\\n            a[ 7 ] = atmp1;\\n            a[ 11 ] = atmp2;\\n            a[ 15 ] = atmp3;\\n\\n            return a;\\n        },\\n\\n        // do a * b and result in b\\n        postMult: function ( a, b ) {\\n            var btmp0, btmp1, btmp2, btmp3;\\n            // post mult\\n            btmp0 = ( b[ 0 ] * a[ 0 ] ) + ( b[ 1 ] * a[ 4 ] ) + ( b[ 2 ] * a[ 8 ] ) + ( b[ 3 ] * a[ 12 ] );\\n            btmp1 = ( b[ 0 ] * a[ 1 ] ) + ( b[ 1 ] * a[ 5 ] ) + ( b[ 2 ] * a[ 9 ] ) + ( b[ 3 ] * a[ 13 ] );\\n            btmp2 = ( b[ 0 ] * a[ 2 ] ) + ( b[ 1 ] * a[ 6 ] ) + ( b[ 2 ] * a[ 10 ] ) + ( b[ 3 ] * a[ 14 ] );\\n            btmp3 = ( b[ 0 ] * a[ 3 ] ) + ( b[ 1 ] * a[ 7 ] ) + ( b[ 2 ] * a[ 11 ] ) + ( b[ 3 ] * a[ 15 ] );\\n            b[ 0 ] = btmp0;\\n            b[ 1 ] = btmp1;\\n            b[ 2 ] = btmp2;\\n            b[ 3 ] = btmp3;\\n\\n            btmp0 = ( b[ 4 ] * a[ 0 ] ) + ( b[ 5 ] * a[ 4 ] ) + ( b[ 6 ] * a[ 8 ] ) + ( b[ 7 ] * a[ 12 ] );\\n            btmp1 = ( b[ 4 ] * a[ 1 ] ) + ( b[ 5 ] * a[ 5 ] ) + ( b[ 6 ] * a[ 9 ] ) + ( b[ 7 ] * a[ 13 ] );\\n            btmp2 = ( b[ 4 ] * a[ 2 ] ) + ( b[ 5 ] * a[ 6 ] ) + ( b[ 6 ] * a[ 10 ] ) + ( b[ 7 ] * a[ 14 ] );\\n            btmp3 = ( b[ 4 ] * a[ 3 ] ) + ( b[ 5 ] * a[ 7 ] ) + ( b[ 6 ] * a[ 11 ] ) + ( b[ 7 ] * a[ 15 ] );\\n            b[ 4 ] = btmp0;\\n            b[ 5 ] = btmp1;\\n            b[ 6 ] = btmp2;\\n            b[ 7 ] = btmp3;\\n\\n            btmp0 = ( b[ 8 ] * a[ 0 ] ) + ( b[ 9 ] * a[ 4 ] ) + ( b[ 10 ] * a[ 8 ] ) + ( b[ 11 ] * a[ 12 ] );\\n            btmp1 = ( b[ 8 ] * a[ 1 ] ) + ( b[ 9 ] * a[ 5 ] ) + ( b[ 10 ] * a[ 9 ] ) + ( b[ 11 ] * a[ 13 ] );\\n            btmp2 = ( b[ 8 ] * a[ 2 ] ) + ( b[ 9 ] * a[ 6 ] ) + ( b[ 10 ] * a[ 10 ] ) + ( b[ 11 ] * a[ 14 ] );\\n            btmp3 = ( b[ 8 ] * a[ 3 ] ) + ( b[ 9 ] * a[ 7 ] ) + ( b[ 10 ] * a[ 11 ] ) + ( b[ 11 ] * a[ 15 ] );\\n            b[ 8 ] = btmp0;\\n            b[ 9 ] = btmp1;\\n            b[ 10 ] = btmp2;\\n            b[ 11 ] = btmp3;\\n\\n            btmp0 = ( b[ 12 ] * a[ 0 ] ) + ( b[ 13 ] * a[ 4 ] ) + ( b[ 14 ] * a[ 8 ] ) + ( b[ 15 ] * a[ 12 ] );\\n            btmp1 = ( b[ 12 ] * a[ 1 ] ) + ( b[ 13 ] * a[ 5 ] ) + ( b[ 14 ] * a[ 9 ] ) + ( b[ 15 ] * a[ 13 ] );\\n            btmp2 = ( b[ 12 ] * a[ 2 ] ) + ( b[ 13 ] * a[ 6 ] ) + ( b[ 14 ] * a[ 10 ] ) + ( b[ 15 ] * a[ 14 ] );\\n            btmp3 = ( b[ 12 ] * a[ 3 ] ) + ( b[ 13 ] * a[ 7 ] ) + ( b[ 14 ] * a[ 11 ] ) + ( b[ 15 ] * a[ 15 ] );\\n            b[ 12 ] = btmp0;\\n            b[ 13 ] = btmp1;\\n            b[ 14 ] = btmp2;\\n            b[ 15 ] = btmp3;\\n\\n            return b;\\n        },\\n        multa: function ( a, b, r ) {\\n            if ( r === a ) {\\n                return Matrix.preMult( a, b );\\n            } else if ( r === b ) {\\n                return Matrix.postMult( a, b );\\n            } else {\\n                if ( r === undefined ) {\\n                    Notify.warn( \\'no matrix destination !\\' );\\n                    r = Matrix.create();\\n                }\\n                r[ 0 ] = b[ 0 ] * a[ 0 ] + b[ 1 ] * a[ 4 ] + b[ 2 ] * a[ 8 ] + b[ 3 ] * a[ 12 ];\\n                r[ 1 ] = b[ 0 ] * a[ 1 ] + b[ 1 ] * a[ 5 ] + b[ 2 ] * a[ 9 ] + b[ 3 ] * a[ 13 ];\\n                r[ 2 ] = b[ 0 ] * a[ 2 ] + b[ 1 ] * a[ 6 ] + b[ 2 ] * a[ 10 ] + b[ 3 ] * a[ 14 ];\\n                r[ 3 ] = b[ 0 ] * a[ 3 ] + b[ 1 ] * a[ 7 ] + b[ 2 ] * a[ 11 ] + b[ 3 ] * a[ 15 ];\\n\\n                r[ 4 ] = b[ 4 ] * a[ 0 ] + b[ 5 ] * a[ 4 ] + b[ 6 ] * a[ 8 ] + b[ 7 ] * a[ 12 ];\\n                r[ 5 ] = b[ 4 ] * a[ 1 ] + b[ 5 ] * a[ 5 ] + b[ 6 ] * a[ 9 ] + b[ 7 ] * a[ 13 ];\\n                r[ 6 ] = b[ 4 ] * a[ 2 ] + b[ 5 ] * a[ 6 ] + b[ 6 ] * a[ 10 ] + b[ 7 ] * a[ 14 ];\\n                r[ 7 ] = b[ 4 ] * a[ 3 ] + b[ 5 ] * a[ 7 ] + b[ 6 ] * a[ 11 ] + b[ 7 ] * a[ 15 ];\\n\\n                r[ 8 ] = b[ 8 ] * a[ 0 ] + b[ 9 ] * a[ 4 ] + b[ 10 ] * a[ 8 ] + b[ 11 ] * a[ 12 ];\\n                r[ 9 ] = b[ 8 ] * a[ 1 ] + b[ 9 ] * a[ 5 ] + b[ 10 ] * a[ 9 ] + b[ 11 ] * a[ 13 ];\\n                r[ 10 ] = b[ 8 ] * a[ 2 ] + b[ 9 ] * a[ 6 ] + b[ 10 ] * a[ 10 ] + b[ 11 ] * a[ 14 ];\\n                r[ 11 ] = b[ 8 ] * a[ 3 ] + b[ 9 ] * a[ 7 ] + b[ 10 ] * a[ 11 ] + b[ 11 ] * a[ 15 ];\\n\\n                r[ 12 ] = b[ 12 ] * a[ 0 ] + b[ 13 ] * a[ 4 ] + b[ 14 ] * a[ 8 ] + b[ 15 ] * a[ 12 ];\\n                r[ 13 ] = b[ 12 ] * a[ 1 ] + b[ 13 ] * a[ 5 ] + b[ 14 ] * a[ 9 ] + b[ 15 ] * a[ 13 ];\\n                r[ 14 ] = b[ 12 ] * a[ 2 ] + b[ 13 ] * a[ 6 ] + b[ 14 ] * a[ 10 ] + b[ 15 ] * a[ 14 ];\\n                r[ 15 ] = b[ 12 ] * a[ 3 ] + b[ 13 ] * a[ 7 ] + b[ 14 ] * a[ 11 ] + b[ 15 ] * a[ 15 ];\\n\\n                return r;\\n            }\\n        },\\n        /* r = a * b */\\n        mult: function ( a, b, r ) {\\n            var s00 = b[ 0 ];\\n            var s01 = b[ 1 ];\\n            var s02 = b[ 2 ];\\n            var s03 = b[ 3 ];\\n            var s10 = b[ 4 ];\\n            var s11 = b[ 5 ];\\n            var s12 = b[ 6 ];\\n            var s13 = b[ 7 ];\\n            var s20 = b[ 8 ];\\n            var s21 = b[ 9 ];\\n            var s22 = b[ 10 ];\\n            var s23 = b[ 11 ];\\n            var s30 = b[ 12 ];\\n            var s31 = b[ 13 ];\\n            var s32 = b[ 14 ];\\n            var s33 = b[ 15 ];\\n\\n            var o00 = a[ 0 ];\\n            var o01 = a[ 1 ];\\n            var o02 = a[ 2 ];\\n            var o03 = a[ 3 ];\\n            var o10 = a[ 4 ];\\n            var o11 = a[ 5 ];\\n            var o12 = a[ 6 ];\\n            var o13 = a[ 7 ];\\n            var o20 = a[ 8 ];\\n            var o21 = a[ 9 ];\\n            var o22 = a[ 10 ];\\n            var o23 = a[ 11 ];\\n            var o30 = a[ 12 ];\\n            var o31 = a[ 13 ];\\n            var o32 = a[ 14 ];\\n            var o33 = a[ 15 ];\\n\\n            r[ 0 ] = s00 * o00 + s01 * o10 + s02 * o20 + s03 * o30;\\n            r[ 1 ] = s00 * o01 + s01 * o11 + s02 * o21 + s03 * o31;\\n            r[ 2 ] = s00 * o02 + s01 * o12 + s02 * o22 + s03 * o32;\\n            r[ 3 ] = s00 * o03 + s01 * o13 + s02 * o23 + s03 * o33;\\n\\n            r[ 4 ] = s10 * o00 + s11 * o10 + s12 * o20 + s13 * o30;\\n            r[ 5 ] = s10 * o01 + s11 * o11 + s12 * o21 + s13 * o31;\\n            r[ 6 ] = s10 * o02 + s11 * o12 + s12 * o22 + s13 * o32;\\n            r[ 7 ] = s10 * o03 + s11 * o13 + s12 * o23 + s13 * o33;\\n\\n            r[ 8 ] = s20 * o00 + s21 * o10 + s22 * o20 + s23 * o30;\\n            r[ 9 ] = s20 * o01 + s21 * o11 + s22 * o21 + s23 * o31;\\n            r[ 10 ] = s20 * o02 + s21 * o12 + s22 * o22 + s23 * o32;\\n            r[ 11 ] = s20 * o03 + s21 * o13 + s22 * o23 + s23 * o33;\\n\\n            r[ 12 ] = s30 * o00 + s31 * o10 + s32 * o20 + s33 * o30;\\n            r[ 13 ] = s30 * o01 + s31 * o11 + s32 * o21 + s33 * o31;\\n            r[ 14 ] = s30 * o02 + s31 * o12 + s32 * o22 + s33 * o32;\\n            r[ 15 ] = s30 * o03 + s31 * o13 + s32 * o23 + s33 * o33;\\n\\n            return r;\\n        },\\n        multOrig: function ( a, b, r ) {\\n            var inner1 = 0.0,\\n                inner2 = 0.0,\\n                inner3 = 0.0,\\n                inner4 = 0.0;\\n            if ( r === a ) {\\n                // pre mult\\n                for ( var col = 0; col < 4; col++ ) {\\n                    inner1 = Matrix.innerProduct( b, a, 0, col );\\n                    inner2 = Matrix.innerProduct( b, a, 1, col );\\n                    inner3 = Matrix.innerProduct( b, a, 2, col );\\n                    inner4 = Matrix.innerProduct( b, a, 3, col );\\n                    a[ 0 + col ] = inner1;\\n                    a[ 4 + col ] = inner2;\\n                    a[ 8 + col ] = inner3;\\n                    a[ 12 + col ] = inner4;\\n                }\\n                return a;\\n                //return Matrix.preMult(r, b);\\n            } else if ( r === b ) {\\n                // post mult\\n                for ( var row = 0; row < 4; row++ ) {\\n                    inner1 = Matrix.innerProduct( b, a, row, 0 );\\n                    inner2 = Matrix.innerProduct( b, a, row, 1 );\\n                    inner3 = Matrix.innerProduct( b, a, row, 2 );\\n                    inner4 = Matrix.innerProduct( b, a, row, 3 );\\n                    Matrix.setRow( b, row, inner1, inner2, inner3, inner4 );\\n                }\\n                return b;\\n                //return Matrix.postMult(r, a);\\n            }\\n            if ( r === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                r = Matrix.create();\\n            }\\n\\n            var s00 = b[ 0 ];\\n            var s01 = b[ 1 ];\\n            var s02 = b[ 2 ];\\n            var s03 = b[ 3 ];\\n            var s10 = b[ 4 ];\\n            var s11 = b[ 5 ];\\n            var s12 = b[ 6 ];\\n            var s13 = b[ 7 ];\\n            var s20 = b[ 8 ];\\n            var s21 = b[ 9 ];\\n            var s22 = b[ 10 ];\\n            var s23 = b[ 11 ];\\n            var s30 = b[ 12 ];\\n            var s31 = b[ 13 ];\\n            var s32 = b[ 14 ];\\n            var s33 = b[ 15 ];\\n\\n            var o00 = a[ 0 ];\\n            var o01 = a[ 1 ];\\n            var o02 = a[ 2 ];\\n            var o03 = a[ 3 ];\\n            var o10 = a[ 4 ];\\n            var o11 = a[ 5 ];\\n            var o12 = a[ 6 ];\\n            var o13 = a[ 7 ];\\n            var o20 = a[ 8 ];\\n            var o21 = a[ 9 ];\\n            var o22 = a[ 10 ];\\n            var o23 = a[ 11 ];\\n            var o30 = a[ 12 ];\\n            var o31 = a[ 13 ];\\n            var o32 = a[ 14 ];\\n            var o33 = a[ 15 ];\\n\\n            r[ 0 ] = s00 * o00 + s01 * o10 + s02 * o20 + s03 * o30;\\n            r[ 1 ] = s00 * o01 + s01 * o11 + s02 * o21 + s03 * o31;\\n            r[ 2 ] = s00 * o02 + s01 * o12 + s02 * o22 + s03 * o32;\\n            r[ 3 ] = s00 * o03 + s01 * o13 + s02 * o23 + s03 * o33;\\n\\n            r[ 4 ] = s10 * o00 + s11 * o10 + s12 * o20 + s13 * o30;\\n            r[ 5 ] = s10 * o01 + s11 * o11 + s12 * o21 + s13 * o31;\\n            r[ 6 ] = s10 * o02 + s11 * o12 + s12 * o22 + s13 * o32;\\n            r[ 7 ] = s10 * o03 + s11 * o13 + s12 * o23 + s13 * o33;\\n\\n            r[ 8 ] = s20 * o00 + s21 * o10 + s22 * o20 + s23 * o30;\\n            r[ 9 ] = s20 * o01 + s21 * o11 + s22 * o21 + s23 * o31;\\n            r[ 10 ] = s20 * o02 + s21 * o12 + s22 * o22 + s23 * o32;\\n            r[ 11 ] = s20 * o03 + s21 * o13 + s22 * o23 + s23 * o33;\\n\\n            r[ 12 ] = s30 * o00 + s31 * o10 + s32 * o20 + s33 * o30;\\n            r[ 13 ] = s30 * o01 + s31 * o11 + s32 * o21 + s33 * o31;\\n            r[ 14 ] = s30 * o02 + s31 * o12 + s32 * o22 + s33 * o32;\\n            r[ 15 ] = s30 * o03 + s31 * o13 + s32 * o23 + s33 * o33;\\n\\n            return r;\\n        },\\n\\n        makeLookAt: ( function () {\\n            var f = [ 0.0, 0.0, 0.0 ];\\n            var s = [ 0.0, 0.0, 0.0 ];\\n            var u = [ 0.0, 0.0, 0.0 ];\\n            var neg = [ 0.0, 0.0, 0.0 ];\\n\\n            return function ( eye, center, up, result ) {\\n                if ( result === undefined ) {\\n                    Notify.warn( \\'no matrix destination !\\' );\\n                    result = Matrix.create();\\n                }\\n\\n                Vec3.sub( center, eye, f );\\n                Vec3.normalize( f, f );\\n\\n                Vec3.cross( f, up, s );\\n                Vec3.normalize( s, s );\\n\\n                Vec3.cross( s, f, u );\\n                Vec3.normalize( u, u );\\n\\n                // s[0], u[0], -f[0], 0.0,\\n                // s[1], u[1], -f[1], 0.0,\\n                // s[2], u[2], -f[2], 0.0,\\n                // 0,    0,    0,     1.0\\n\\n                result[ 0 ] = s[ 0 ];\\n                result[ 1 ] = u[ 0 ];\\n                result[ 2 ] = -f[ 0 ];\\n                result[ 3 ] = 0.0;\\n                result[ 4 ] = s[ 1 ];\\n                result[ 5 ] = u[ 1 ];\\n                result[ 6 ] = -f[ 1 ];\\n                result[ 7 ] = 0.0;\\n                result[ 8 ] = s[ 2 ];\\n                result[ 9 ] = u[ 2 ];\\n                result[ 10 ] = -f[ 2 ];\\n                result[ 11 ] = 0.0;\\n                result[ 12 ] = 0;\\n                result[ 13 ] = 0;\\n                result[ 14 ] = 0;\\n                result[ 15 ] = 1.0;\\n\\n                Matrix.multTranslate( result, Vec3.neg( eye, neg ), result );\\n                return result;\\n            };\\n        } )(),\\n        makeOrtho: function ( left, right, bottom, top, zNear, zFar, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            // note transpose of Matrix_implementation wr.t OpenGL documentation, since the OSG use post multiplication rather than pre.\\n            // we will change this convention later\\n            var tx = -( right + left ) / ( right - left );\\n            var ty = -( top + bottom ) / ( top - bottom );\\n            var tz = -( zFar + zNear ) / ( zFar - zNear );\\n            var row = Matrix.setRow;\\n            row( result, 0, 2.0 / ( right - left ), 0.0, 0.0, 0.0 );\\n            row( result, 1, 0.0, 2.0 / ( top - bottom ), 0.0, 0.0 );\\n            row( result, 2, 0.0, 0.0, -2.0 / ( zFar - zNear ), 0.0 );\\n            row( result, 3, tx, ty, tz, 1.0 );\\n            return result;\\n        },\\n\\n        getLookAt: ( function () {\\n            var inv = [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ];\\n            var v1 = [ 0.0, 0.0, 0.0 ];\\n            var v2 = [ 0.0, 1.0, 0.0 ];\\n            var v3 = [ 0.0, 0.0, -1.0 ];\\n\\n            return function ( matrix, eye, center, up, distance ) {\\n                if ( distance === undefined ) {\\n                    distance = 1.0;\\n                }\\n                var result = Matrix.inverse( matrix, inv );\\n                if ( !result ) {\\n                    Matrix.makeIdentity( inv );\\n                }\\n                Matrix.transformVec3( inv, v1, eye );\\n                Matrix.transform3x3( matrix, v2, up );\\n                Matrix.transform3x3( matrix, v3, center );\\n                Vec3.normalize( center, center );\\n                Vec3.add( Vec3.mult( center, distance, v1 ), eye, center );\\n            };\\n        } )(),\\n\\n        //getRotate_David_Spillings_Mk1\\n        getRotate: ( function () {\\n            var tq = [ 0.0, 0.0, 0.0, 0.0 ];\\n\\n            return function ( mat, quatResult ) {\\n                if ( quatResult === undefined ) {\\n                    Notify.warn( \\'no quat destination !\\' );\\n                    quatResult = [ 0.0, 0.0, 0.0, 0.0 ];\\n                }\\n\\n                var s;\\n                var i, j;\\n\\n                // Use tq to store the largest trace\\n                var mat00 = mat[ 4 * 0 + 0 ];\\n                var mat11 = mat[ 4 * 1 + 1 ];\\n                var mat22 = mat[ 4 * 2 + 2 ];\\n                tq[ 0 ] = 1.0 + mat00 + mat11 + mat22;\\n                tq[ 1 ] = 1.0 + mat00 - mat11 - mat22;\\n                tq[ 2 ] = 1.0 - mat00 + mat11 - mat22;\\n                tq[ 3 ] = 1.0 - mat00 - mat11 + mat22;\\n\\n                // Find the maximum (could also use stacked if\\'s later)\\n                j = 0;\\n                for ( i = 1; i < 4; i++ ) {\\n                    if ( ( tq[ i ] > tq[ j ] ) ) {\\n                        j = i;\\n                    } else {\\n                        j = j;\\n                    }\\n                }\\n\\n                // check the diagonal\\n                if ( j === 0 ) {\\n                    /* perform instant calculation */\\n                    quatResult[ 3 ] = tq[ 0 ];\\n                    quatResult[ 0 ] = mat[ 1 * 4 + 2 ] - mat[ 2 * 4 + 1 ];\\n                    quatResult[ 1 ] = mat[ 2 * 4 + 0 ] - mat[ 0 + 2 ];\\n                    quatResult[ 2 ] = mat[ 0 + 1 ] - mat[ 1 * 4 + 0 ];\\n                } else if ( j === 1 ) {\\n                    quatResult[ 3 ] = mat[ 1 * 4 + 2 ] - mat[ 2 * 4 + 1 ];\\n                    quatResult[ 0 ] = tq[ 1 ];\\n                    quatResult[ 1 ] = mat[ 0 + 1 ] + mat[ 1 * 4 + 0 ];\\n                    quatResult[ 2 ] = mat[ 2 * 4 + 0 ] + mat[ 0 + 2 ];\\n                } else if ( j === 2 ) {\\n                    quatResult[ 3 ] = mat[ 2 * 4 + 0 ] - mat[ 0 + 2 ];\\n                    quatResult[ 0 ] = mat[ 0 + 1 ] + mat[ 1 * 4 + 0 ];\\n                    quatResult[ 1 ] = tq[ 2 ];\\n                    quatResult[ 2 ] = mat[ 1 * 4 + 2 ] + mat[ 2 * 4 + 1 ];\\n                } else /* if (j==3) */ {\\n                    quatResult[ 3 ] = mat[ 0 + 1 ] - mat[ 1 * 4 + 0 ];\\n                    quatResult[ 0 ] = mat[ 2 * 4 + 0 ] + mat[ 0 + 2 ];\\n                    quatResult[ 1 ] = mat[ 1 * 4 + 2 ] + mat[ 2 * 4 + 1 ];\\n                    quatResult[ 2 ] = tq[ 3 ];\\n                }\\n\\n                s = Math.sqrt( 0.25 / tq[ j ] );\\n                quatResult[ 3 ] *= s;\\n                quatResult[ 0 ] *= s;\\n                quatResult[ 1 ] *= s;\\n                quatResult[ 2 ] *= s;\\n\\n                return quatResult;\\n            };\\n        } )(),\\n\\n        // Matrix M = Matrix M * Matrix Translate\\n        preMultTranslate: function ( mat, translate ) {\\n            var val;\\n            if ( translate[ 0 ] !== 0.0 ) {\\n                val = translate[ 0 ];\\n                mat[ 12 ] += val * mat[ 0 ];\\n                mat[ 13 ] += val * mat[ 1 ];\\n                mat[ 14 ] += val * mat[ 2 ];\\n                mat[ 15 ] += val * mat[ 3 ];\\n            }\\n\\n            if ( translate[ 1 ] !== 0.0 ) {\\n                val = translate[ 1 ];\\n                mat[ 12 ] += val * mat[ 4 ];\\n                mat[ 13 ] += val * mat[ 5 ];\\n                mat[ 14 ] += val * mat[ 6 ];\\n                mat[ 15 ] += val * mat[ 7 ];\\n            }\\n\\n            if ( translate[ 2 ] !== 0.0 ) {\\n                val = translate[ 2 ];\\n                mat[ 12 ] += val * mat[ 8 ];\\n                mat[ 13 ] += val * mat[ 9 ];\\n                mat[ 14 ] += val * mat[ 10 ];\\n                mat[ 15 ] += val * mat[ 11 ];\\n            }\\n            return mat;\\n        },\\n\\n        // result = Matrix M * Matrix Translate\\n        multTranslate: function ( mat, translate, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            if ( result !== mat ) {\\n                Matrix.copy( mat, result );\\n            }\\n\\n            var val;\\n            if ( translate[ 0 ] !== 0.0 ) {\\n                val = translate[ 0 ];\\n                result[ 12 ] += val * mat[ 0 ];\\n                result[ 13 ] += val * mat[ 1 ];\\n                result[ 14 ] += val * mat[ 2 ];\\n                result[ 15 ] += val * mat[ 3 ];\\n            }\\n\\n            if ( translate[ 1 ] !== 0.0 ) {\\n                val = translate[ 1 ];\\n                result[ 12 ] += val * mat[ 4 ];\\n                result[ 13 ] += val * mat[ 5 ];\\n                result[ 14 ] += val * mat[ 6 ];\\n                result[ 15 ] += val * mat[ 7 ];\\n            }\\n\\n            if ( translate[ 2 ] !== 0.0 ) {\\n                val = translate[ 2 ];\\n                result[ 12 ] += val * mat[ 8 ];\\n                result[ 13 ] += val * mat[ 9 ];\\n                result[ 14 ] += val * mat[ 10 ];\\n                result[ 15 ] += val * mat[ 11 ];\\n            }\\n            return result;\\n        },\\n\\n        makeRotate: function ( angle, x, y, z, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n\\n            var mag = Math.sqrt( x * x + y * y + z * z );\\n            var sinAngle = Math.sin( angle );\\n            var cosAngle = Math.cos( angle );\\n\\n            if ( mag > 0.0 ) {\\n                var xx, yy, zz, xy, yz, zx, xs, ys, zs;\\n                var oneMinusCos;\\n\\n                mag = 1.0 / mag;\\n\\n                x *= mag;\\n                y *= mag;\\n                z *= mag;\\n\\n                xx = x * x;\\n                yy = y * y;\\n                zz = z * z;\\n                xy = x * y;\\n                yz = y * z;\\n                zx = z * x;\\n                xs = x * sinAngle;\\n                ys = y * sinAngle;\\n                zs = z * sinAngle;\\n                oneMinusCos = 1.0 - cosAngle;\\n\\n                result[ 0 ] = ( oneMinusCos * xx ) + cosAngle;\\n                result[ 1 ] = ( oneMinusCos * xy ) - zs;\\n                result[ 2 ] = ( oneMinusCos * zx ) + ys;\\n                result[ 3 ] = 0.0;\\n\\n                result[ 4 ] = ( oneMinusCos * xy ) + zs;\\n                result[ 5 ] = ( oneMinusCos * yy ) + cosAngle;\\n                result[ 6 ] = ( oneMinusCos * yz ) - xs;\\n                result[ 7 ] = 0.0;\\n\\n                result[ 8 ] = ( oneMinusCos * zx ) - ys;\\n                result[ 9 ] = ( oneMinusCos * yz ) + xs;\\n                result[ 10 ] = ( oneMinusCos * zz ) + cosAngle;\\n                result[ 11 ] = 0.0;\\n\\n                result[ 12 ] = 0.0;\\n                result[ 13 ] = 0.0;\\n                result[ 14 ] = 0.0;\\n                result[ 15 ] = 1.0;\\n\\n                return result;\\n            } else {\\n                return Matrix.makeIdentity( result );\\n            }\\n\\n            return result;\\n        },\\n\\n        transform3x3: function ( m, v, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            result[ 0 ] = m[ 0 ] * v[ 0 ] + m[ 1 ] * v[ 1 ] + m[ 2 ] * v[ 2 ];\\n            result[ 1 ] = m[ 4 ] * v[ 0 ] + m[ 5 ] * v[ 1 ] + m[ 6 ] * v[ 2 ];\\n            result[ 2 ] = m[ 8 ] * v[ 0 ] + m[ 9 ] * v[ 1 ] + m[ 10 ] * v[ 2 ];\\n            return result;\\n        },\\n\\n        transformVec3: ( function () {\\n            var tmpVec = [ 0.0, 0.0, 0.0 ];\\n\\n            return function ( matrix, vector, result ) {\\n                var d = 1.0 / ( matrix[ 3 ] * vector[ 0 ] + matrix[ 7 ] * vector[ 1 ] + matrix[ 11 ] * vector[ 2 ] + matrix[ 15 ] );\\n\\n                if ( result === undefined ) {\\n                    Notify.warn( \\'no matrix destination !\\' );\\n                    result = Matrix.create();\\n                }\\n\\n                var tmp;\\n                if ( result === vector ) {\\n                    tmp = tmpVec;\\n                } else {\\n                    tmp = result;\\n                }\\n                tmp[ 0 ] = ( matrix[ 0 ] * vector[ 0 ] + matrix[ 4 ] * vector[ 1 ] + matrix[ 8 ] * vector[ 2 ] + matrix[ 12 ] ) * d;\\n                tmp[ 1 ] = ( matrix[ 1 ] * vector[ 0 ] + matrix[ 5 ] * vector[ 1 ] + matrix[ 9 ] * vector[ 2 ] + matrix[ 13 ] ) * d;\\n                tmp[ 2 ] = ( matrix[ 2 ] * vector[ 0 ] + matrix[ 6 ] * vector[ 1 ] + matrix[ 10 ] * vector[ 2 ] + matrix[ 14 ] ) * d;\\n\\n                if ( result === vector ) {\\n                    Vec3.copy( tmp, result );\\n                }\\n                return result;\\n            };\\n        } )(),\\n\\n        transformVec4: ( function () {\\n            var tmpVec = [ 0.0, 0.0, 0.0 ];\\n\\n            return function ( matrix, vector, result ) {\\n                if ( result === undefined ) {\\n                    Notify.warn( \\'no matrix destination !\\' );\\n                    result = Matrix.create();\\n                }\\n                var tmp;\\n                if ( result === vector ) {\\n                    tmp = tmpVec;\\n                } else {\\n                    tmp = result;\\n                }\\n                tmp[ 0 ] = ( matrix[ 0 ] * vector[ 0 ] + matrix[ 1 ] * vector[ 1 ] + matrix[ 2 ] * vector[ 2 ] + matrix[ 3 ] * vector[ 3 ] );\\n                tmp[ 1 ] = ( matrix[ 4 ] * vector[ 0 ] + matrix[ 5 ] * vector[ 1 ] + matrix[ 6 ] * vector[ 2 ] + matrix[ 7 ] * vector[ 3 ] );\\n                tmp[ 2 ] = ( matrix[ 8 ] * vector[ 0 ] + matrix[ 9 ] * vector[ 1 ] + matrix[ 10 ] * vector[ 2 ] + matrix[ 11 ] * vector[ 3 ] );\\n                tmp[ 3 ] = ( matrix[ 12 ] * vector[ 0 ] + matrix[ 13 ] * vector[ 1 ] + matrix[ 14 ] * vector[ 2 ] + matrix[ 15 ] * vector[ 3 ] );\\n\\n                if ( result === vector ) {\\n                    Vec4.copy( tmp, result );\\n                }\\n                return result;\\n            };\\n        } )(),\\n\\n        copy: function ( matrix, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            result[ 0 ] = matrix[ 0 ];\\n            result[ 1 ] = matrix[ 1 ];\\n            result[ 2 ] = matrix[ 2 ];\\n            result[ 3 ] = matrix[ 3 ];\\n            result[ 4 ] = matrix[ 4 ];\\n            result[ 5 ] = matrix[ 5 ];\\n            result[ 6 ] = matrix[ 6 ];\\n            result[ 7 ] = matrix[ 7 ];\\n            result[ 8 ] = matrix[ 8 ];\\n            result[ 9 ] = matrix[ 9 ];\\n            result[ 10 ] = matrix[ 10 ];\\n            result[ 11 ] = matrix[ 11 ];\\n            result[ 12 ] = matrix[ 12 ];\\n            result[ 13 ] = matrix[ 13 ];\\n            result[ 14 ] = matrix[ 14 ];\\n            result[ 15 ] = matrix[ 15 ];\\n            return result;\\n        },\\n\\n        inverse: ( function () {\\n            var tmp = [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ];\\n\\n            return function ( matrix, result ) {\\n                if ( result === matrix ) {\\n                    Matrix.copy( matrix, tmp );\\n                    matrix = tmp;\\n                }\\n\\n                if ( matrix[ 3 ] === 0.0 && matrix[ 7 ] === 0.0 && matrix[ 11 ] === 0.0 && matrix[ 15 ] === 1.0 ) {\\n                    return Matrix.inverse4x3( matrix, result );\\n                } else {\\n                    return Matrix.inverse4x4( matrix, result );\\n                }\\n            };\\n        } )(),\\n\\n        /**\\n         *  if a result argument is given the return of the function is true or false\\n         *  depending if the matrix can be inverted, else if no result argument is given\\n         *  the return is identity if the matrix can not be inverted and the matrix overthise\\n         */\\n        inverse4x4: function ( matrix, result ) {\\n            var tmp0 = matrix[ 10 ] * matrix[ 15 ];\\n            var tmp1 = matrix[ 14 ] * matrix[ 11 ];\\n            var tmp2 = matrix[ 6 ] * matrix[ 15 ];\\n            var tmp3 = matrix[ 14 ] * matrix[ 7 ];\\n            var tmp4 = matrix[ 6 ] * matrix[ 11 ];\\n            var tmp5 = matrix[ 10 ] * matrix[ 7 ];\\n            var tmp6 = matrix[ 2 ] * matrix[ 15 ];\\n            var tmp7 = matrix[ 14 ] * matrix[ 3 ];\\n            var tmp8 = matrix[ 2 ] * matrix[ 11 ];\\n            var tmp9 = matrix[ 10 ] * matrix[ 3 ];\\n            var tmp10 = matrix[ 2 ] * matrix[ 7 ];\\n            var tmp11 = matrix[ 6 ] * matrix[ 3 ];\\n            var tmp12 = matrix[ 8 ] * matrix[ 13 ];\\n            var tmp13 = matrix[ 12 ] * matrix[ 9 ];\\n            var tmp14 = matrix[ 4 ] * matrix[ 13 ];\\n            var tmp15 = matrix[ 12 ] * matrix[ 5 ];\\n            var tmp16 = matrix[ 4 ] * matrix[ 9 ];\\n            var tmp17 = matrix[ 8 ] * matrix[ 5 ];\\n            var tmp18 = matrix[ 0 ] * matrix[ 13 ];\\n            var tmp19 = matrix[ 12 ] * matrix[ 1 ];\\n            var tmp20 = matrix[ 0 ] * matrix[ 9 ];\\n            var tmp21 = matrix[ 8 ] * matrix[ 1 ];\\n            var tmp22 = matrix[ 0 ] * matrix[ 5 ];\\n            var tmp23 = matrix[ 4 ] * matrix[ 1 ];\\n\\n            var t0 = ( ( tmp0 * matrix[ 5 ] + tmp3 * matrix[ 9 ] + tmp4 * matrix[ 13 ] ) -\\n                ( tmp1 * matrix[ 5 ] + tmp2 * matrix[ 9 ] + tmp5 * matrix[ 13 ] ) );\\n            var t1 = ( ( tmp1 * matrix[ 1 ] + tmp6 * matrix[ 9 ] + tmp9 * matrix[ 13 ] ) -\\n                ( tmp0 * matrix[ 1 ] + tmp7 * matrix[ 9 ] + tmp8 * matrix[ 13 ] ) );\\n            var t2 = ( ( tmp2 * matrix[ 1 ] + tmp7 * matrix[ 5 ] + tmp10 * matrix[ 13 ] ) -\\n                ( tmp3 * matrix[ 1 ] + tmp6 * matrix[ 5 ] + tmp11 * matrix[ 13 ] ) );\\n            var t3 = ( ( tmp5 * matrix[ 1 ] + tmp8 * matrix[ 5 ] + tmp11 * matrix[ 9 ] ) -\\n                ( tmp4 * matrix[ 1 ] + tmp9 * matrix[ 5 ] + tmp10 * matrix[ 9 ] ) );\\n\\n            var d1 = ( matrix[ 0 ] * t0 + matrix[ 4 ] * t1 + matrix[ 8 ] * t2 + matrix[ 12 ] * t3 );\\n            if ( Math.abs( d1 ) < 1e-5 ) {\\n                Notify.log( \\'Warning can\\\\\\'t inverse matrix \\' + matrix );\\n                return false;\\n            }\\n            var d = 1.0 / d1;\\n\\n            var out00 = d * t0;\\n            var out01 = d * t1;\\n            var out02 = d * t2;\\n            var out03 = d * t3;\\n\\n            var out10 = d * ( ( tmp1 * matrix[ 4 ] + tmp2 * matrix[ 8 ] + tmp5 * matrix[ 12 ] ) -\\n                ( tmp0 * matrix[ 4 ] + tmp3 * matrix[ 8 ] + tmp4 * matrix[ 12 ] ) );\\n            var out11 = d * ( ( tmp0 * matrix[ 0 ] + tmp7 * matrix[ 8 ] + tmp8 * matrix[ 12 ] ) -\\n                ( tmp1 * matrix[ 0 ] + tmp6 * matrix[ 8 ] + tmp9 * matrix[ 12 ] ) );\\n            var out12 = d * ( ( tmp3 * matrix[ 0 ] + tmp6 * matrix[ 4 ] + tmp11 * matrix[ 12 ] ) -\\n                ( tmp2 * matrix[ 0 ] + tmp7 * matrix[ 4 ] + tmp10 * matrix[ 12 ] ) );\\n            var out13 = d * ( ( tmp4 * matrix[ 0 ] + tmp9 * matrix[ 4 ] + tmp10 * matrix[ 8 ] ) -\\n                ( tmp5 * matrix[ 0 ] + tmp8 * matrix[ 4 ] + tmp11 * matrix[ 8 ] ) );\\n\\n            var out20 = d * ( ( tmp12 * matrix[ 7 ] + tmp15 * matrix[ 11 ] + tmp16 * matrix[ 15 ] ) -\\n                ( tmp13 * matrix[ 7 ] + tmp14 * matrix[ 11 ] + tmp17 * matrix[ 15 ] ) );\\n            var out21 = d * ( ( tmp13 * matrix[ 3 ] + tmp18 * matrix[ 11 ] + tmp21 * matrix[ 15 ] ) -\\n                ( tmp12 * matrix[ 3 ] + tmp19 * matrix[ 11 ] + tmp20 * matrix[ 15 ] ) );\\n            var out22 = d * ( ( tmp14 * matrix[ 3 ] + tmp19 * matrix[ 7 ] + tmp22 * matrix[ 15 ] ) -\\n                ( tmp15 * matrix[ 3 ] + tmp18 * matrix[ 7 ] + tmp23 * matrix[ 15 ] ) );\\n            var out23 = d * ( ( tmp17 * matrix[ 3 ] + tmp20 * matrix[ 7 ] + tmp23 * matrix[ 11 ] ) -\\n                ( tmp16 * matrix[ 3 ] + tmp21 * matrix[ 7 ] + tmp22 * matrix[ 11 ] ) );\\n\\n            var out30 = d * ( ( tmp14 * matrix[ 10 ] + tmp17 * matrix[ 14 ] + tmp13 * matrix[ 6 ] ) -\\n                ( tmp16 * matrix[ 14 ] + tmp12 * matrix[ 6 ] + tmp15 * matrix[ 10 ] ) );\\n            var out31 = d * ( ( tmp20 * matrix[ 14 ] + tmp12 * matrix[ 2 ] + tmp19 * matrix[ 10 ] ) -\\n                ( tmp18 * matrix[ 10 ] + tmp21 * matrix[ 14 ] + tmp13 * matrix[ 2 ] ) );\\n            var out32 = d * ( ( tmp18 * matrix[ 6 ] + tmp23 * matrix[ 14 ] + tmp15 * matrix[ 2 ] ) -\\n                ( tmp22 * matrix[ 14 ] + tmp14 * matrix[ 2 ] + tmp19 * matrix[ 6 ] ) );\\n            var out33 = d * ( ( tmp22 * matrix[ 10 ] + tmp16 * matrix[ 2 ] + tmp21 * matrix[ 6 ] ) -\\n                ( tmp20 * matrix[ 6 ] + tmp23 * matrix[ 10 ] + tmp17 * matrix[ 2 ] ) );\\n\\n            result[ 0 ] = out00;\\n            result[ 1 ] = out01;\\n            result[ 2 ] = out02;\\n            result[ 3 ] = out03;\\n            result[ 4 ] = out10;\\n            result[ 5 ] = out11;\\n            result[ 6 ] = out12;\\n            result[ 7 ] = out13;\\n            result[ 8 ] = out20;\\n            result[ 9 ] = out21;\\n            result[ 10 ] = out22;\\n            result[ 11 ] = out23;\\n            result[ 12 ] = out30;\\n            result[ 13 ] = out31;\\n            result[ 14 ] = out32;\\n            result[ 15 ] = out33;\\n\\n            return true;\\n        },\\n\\n        // comes from OpenSceneGraph\\n        /*\\n      Matrix inversion technique:\\n      Given a matrix mat, we want to invert it.\\n      mat = [ r00 r01 r02 a\\n              r10 r11 r12 b\\n              r20 r21 r22 c\\n              tx  ty  tz  d ]\\n      We note that this matrix can be split into three matrices.\\n      mat = rot * trans * corr, where rot is rotation part, trans is translation part, and corr is the correction due to perspective (if any).\\n      rot = [ r00 r01 r02 0\\n              r10 r11 r12 0\\n              r20 r21 r22 0\\n              0   0   0   1 ]\\n      trans = [ 1  0  0  0\\n                0  1  0  0\\n                0  0  1  0\\n                tx ty tz 1 ]\\n      corr = [ 1 0 0 px\\n               0 1 0 py\\n               0 0 1 pz\\n               0 0 0 s ]\\n\\n      where the elements of corr are obtained from linear combinations of the elements of rot, trans, and mat.\\n      So the inverse is mat\\' = (trans * corr)\\' * rot\\', where rot\\' must be computed the traditional way, which is easy since it is only a 3x3 matrix.\\n      This problem is simplified if [px py pz s] = [0 0 0 1], which will happen if mat was composed only of rotations, scales, and translations (which is common).  In this case, we can ignore corr entirely which saves on a lot of computations.\\n    */\\n\\n        inverse4x3: ( function () {\\n            var inv = [ 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0 ];\\n\\n            return function ( matrix, result ) {\\n\\n                // Copy rotation components\\n                var r00 = matrix[ 0 ];\\n                var r01 = matrix[ 1 ];\\n                var r02 = matrix[ 2 ];\\n\\n                var r10 = matrix[ 4 ];\\n                var r11 = matrix[ 5 ];\\n                var r12 = matrix[ 6 ];\\n\\n                var r20 = matrix[ 8 ];\\n                var r21 = matrix[ 9 ];\\n                var r22 = matrix[ 10 ];\\n\\n                // Partially compute inverse of rot\\n                result[ 0 ] = r11 * r22 - r12 * r21;\\n                result[ 1 ] = r02 * r21 - r01 * r22;\\n                result[ 2 ] = r01 * r12 - r02 * r11;\\n\\n                // Compute determinant of rot from 3 elements just computed\\n                var oneOverDet = 1.0 / ( r00 * result[ 0 ] + r10 * result[ 1 ] + r20 * result[ 2 ] );\\n                r00 *= oneOverDet;\\n                r10 *= oneOverDet;\\n                r20 *= oneOverDet; // Saves on later computations\\n\\n                // Finish computing inverse of rot\\n                result[ 0 ] *= oneOverDet;\\n                result[ 1 ] *= oneOverDet;\\n                result[ 2 ] *= oneOverDet;\\n                result[ 3 ] = 0.0;\\n                result[ 4 ] = r12 * r20 - r10 * r22; // Have already been divided by det\\n                result[ 5 ] = r00 * r22 - r02 * r20; // same\\n                result[ 6 ] = r02 * r10 - r00 * r12; // same\\n                result[ 7 ] = 0.0;\\n                result[ 8 ] = r10 * r21 - r11 * r20; // Have already been divided by det\\n                result[ 9 ] = r01 * r20 - r00 * r21; // same\\n                result[ 10 ] = r00 * r11 - r01 * r10; // same\\n                result[ 11 ] = 0.0;\\n                result[ 15 ] = 1.0;\\n\\n                var tx, ty, tz;\\n\\n                var d = matrix[ 15 ];\\n                var dm = d - 1.0;\\n                if ( dm * dm > 1.0e-6 ) // Involves perspective, so we must\\n                { // compute the full inverse\\n\\n                    result[ 12 ] = result[ 13 ] = result[ 14 ] = 0.0;\\n\\n                    var a = matrix[ 3 ];\\n                    var b = matrix[ 7 ];\\n                    var c = matrix[ 11 ];\\n                    var px = result[ 0 ] * a + result[ 1 ] * b + result[ 2 ] * c;\\n                    var py = result[ 4 ] * a + result[ 5 ] * b + result[ 6 ] * c;\\n                    var pz = result[ 8 ] * a + result[ 9 ] * b + result[ 10 ] * c;\\n\\n                    tx = matrix[ 12 ];\\n                    ty = matrix[ 13 ];\\n                    tz = matrix[ 14 ];\\n                    var oneOverS = 1.0 / ( d - ( tx * px + ty * py + tz * pz ) );\\n\\n                    tx *= oneOverS;\\n                    ty *= oneOverS;\\n                    tz *= oneOverS; // Reduces number of calculations later on\\n\\n                    // Compute inverse of trans*corr\\n                    inv[ 0 ] = tx * px + 1.0;\\n                    inv[ 1 ] = ty * px;\\n                    inv[ 2 ] = tz * px;\\n                    inv[ 3 ] = -px * oneOverS;\\n                    inv[ 4 ] = tx * py;\\n                    inv[ 5 ] = ty * py + 1.0;\\n                    inv[ 6 ] = tz * py;\\n                    inv[ 7 ] = -py * oneOverS;\\n                    inv[ 8 ] = tx * pz;\\n                    inv[ 9 ] = ty * pz;\\n                    inv[ 10 ] = tz * pz + 1.0;\\n                    inv[ 11 ] = -pz * oneOverS;\\n                    inv[ 12 ] = -tx;\\n                    inv[ 13 ] = -ty;\\n                    inv[ 14 ] = -tz;\\n                    inv[ 15 ] = oneOverS;\\n\\n                    Matrix.preMult( result, inv ); // Finish computing full inverse of mat\\n                } else {\\n\\n                    tx = matrix[ 12 ];\\n                    ty = matrix[ 13 ];\\n                    tz = matrix[ 14 ];\\n\\n                    // Compute translation components of mat\\'\\n                    result[ 12 ] = -( tx * result[ 0 ] + ty * result[ 4 ] + tz * result[ 8 ] );\\n                    result[ 13 ] = -( tx * result[ 1 ] + ty * result[ 5 ] + tz * result[ 9 ] );\\n                    result[ 14 ] = -( tx * result[ 2 ] + ty * result[ 6 ] + tz * result[ 10 ] );\\n                }\\n                return true;\\n            };\\n        } )(),\\n\\n        transpose: function ( mat, dest ) {\\n            // from glMatrix\\n            // If we are transposing ourselves we can skip a few steps but have to cache some values\\n            if ( mat === dest ) {\\n                var a01 = mat[ 1 ],\\n                    a02 = mat[ 2 ],\\n                    a03 = mat[ 3 ];\\n                var a12 = mat[ 6 ],\\n                    a13 = mat[ 7 ];\\n                var a23 = mat[ 11 ];\\n\\n                mat[ 1 ] = mat[ 4 ];\\n                mat[ 2 ] = mat[ 8 ];\\n                mat[ 3 ] = mat[ 12 ];\\n                mat[ 4 ] = a01;\\n                mat[ 6 ] = mat[ 9 ];\\n                mat[ 7 ] = mat[ 13 ];\\n                mat[ 8 ] = a02;\\n                mat[ 9 ] = a12;\\n                mat[ 11 ] = mat[ 14 ];\\n                mat[ 12 ] = a03;\\n                mat[ 13 ] = a13;\\n                mat[ 14 ] = a23;\\n                return mat;\\n            } else {\\n                dest[ 0 ] = mat[ 0 ];\\n                dest[ 1 ] = mat[ 4 ];\\n                dest[ 2 ] = mat[ 8 ];\\n                dest[ 3 ] = mat[ 12 ];\\n                dest[ 4 ] = mat[ 1 ];\\n                dest[ 5 ] = mat[ 5 ];\\n                dest[ 6 ] = mat[ 9 ];\\n                dest[ 7 ] = mat[ 13 ];\\n                dest[ 8 ] = mat[ 2 ];\\n                dest[ 9 ] = mat[ 6 ];\\n                dest[ 10 ] = mat[ 10 ];\\n                dest[ 11 ] = mat[ 14 ];\\n                dest[ 12 ] = mat[ 3 ];\\n                dest[ 13 ] = mat[ 7 ];\\n                dest[ 14 ] = mat[ 11 ];\\n                dest[ 15 ] = mat[ 15 ];\\n                return dest;\\n            }\\n        },\\n\\n        makePerspective: function ( fovy, aspect, znear, zfar, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            var ymax = znear * Math.tan( fovy * Math.PI / 360.0 );\\n            var ymin = -ymax;\\n            var xmin = ymin * aspect;\\n            var xmax = ymax * aspect;\\n\\n            return Matrix.makeFrustum( xmin, xmax, ymin, ymax, znear, zfar, result );\\n        },\\n\\n        getFrustum: function ( matrix, result ) {\\n            var right = 0.0;\\n            var left = 0.0;\\n            var top = 0.0;\\n            var bottom = 0.0;\\n            var zNear, zFar;\\n\\n            if ( matrix[ 0 * 4 + 3 ] !== 0.0 || matrix[ 1 * 4 + 3 ] !== 0.0 || matrix[ 2 * 4 + 3 ] !== -1.0 || matrix[ 3 * 4 + 3 ] !== 0.0 ) {\\n                return false;\\n            }\\n\\n            // note: near and far must be used inside this method instead of zNear and zFar\\n            // because zNear and zFar are references and they may point to the same variable.\\n            var tempNear = matrix[ 3 * 4 + 2 ] / ( matrix[ 2 * 4 + 2 ] - 1.0 );\\n            var tempFar = matrix[ 3 * 4 + 2 ] / ( 1.0 + matrix[ 2 * 4 + 2 ] );\\n\\n            left = tempNear * ( matrix[ 2 * 4 ] - 1.0 ) / matrix[ 0 ];\\n            right = tempNear * ( 1.0 + matrix[ 2 * 4 ] ) / matrix[ 0 ];\\n\\n            top = tempNear * ( 1.0 + matrix[ 2 * 4 + 1 ] ) / matrix[ 1 * 4 + 1 ];\\n            bottom = tempNear * ( matrix[ 2 * 4 + 1 ] - 1.0 ) / matrix[ 1 * 4 + 1 ];\\n\\n            zNear = tempNear;\\n            zFar = tempFar;\\n\\n            result.left = left;\\n            result.right = right;\\n            result.top = top;\\n            result.bottom = bottom;\\n            result.zNear = zNear;\\n            result.zFar = zFar;\\n\\n            return true;\\n        },\\n\\n        getPerspective: ( function () {\\n            var c = {\\n                \\'right\\': 0,\\n                \\'left\\': 0,\\n                \\'top\\': 0,\\n                \\'bottom\\': 0,\\n                \\'zNear\\': 0,\\n                \\'zFar\\': 0\\n            };\\n            return function ( matrix, result ) {\\n                // get frustum and compute results\\n                var r = Matrix.getFrustum( matrix, c );\\n                if ( r ) {\\n                    result.fovy = 180 / Math.PI * ( Math.atan( c.top / c.zNear ) - Math.atan( c.bottom / c.zNear ) );\\n                    result.aspectRatio = ( c.right - c.left ) / ( c.top - c.bottom );\\n                }\\n                result.zNear = c.zNear;\\n                result.zFar = c.zFar;\\n                return result;\\n            };\\n        } )(),\\n\\n        makeScale: function ( x, y, z, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            Matrix.setRow( result, 0, x, 0.0, 0.0, 0.0 );\\n            Matrix.setRow( result, 1, 0.0, y, 0.0, 0.0 );\\n            Matrix.setRow( result, 2, 0.0, 0.0, z, 0.0 );\\n            Matrix.setRow( result, 3, 0.0, 0.0, 0.0, 1.0 );\\n            return result;\\n        },\\n\\n        // compute the 4 corners vector of the frustrum\\n        computeFrustrumCornersVectors: function ( projectionMatrix, vectorsArray ) {\\n            //var znear = projectionMatrix[ 12 + 2 ] / ( projectionMatrix[ 8 + 2 ] - 1.0 );\\n            //var zfar = projectionMatrix[ 12 + 2 ] / ( projectionMatrix[ 8 + 2 ] + 1.0 );\\n            var x = 1.0 / projectionMatrix[ 0 ];\\n            var y = 1.0 / projectionMatrix[ 1 * 4 + 1 ];\\n\\n            vectorsArray[ 0 ] = [ -x, y, 1.0 ];\\n            vectorsArray[ 1 ] = [ -x, -y, 1.0 ];\\n            vectorsArray[ 2 ] = [ x, -y, 1.0 ];\\n            vectorsArray[ 3 ] = [ x, y, 1.0 ];\\n            return vectorsArray;\\n        },\\n\\n        makeFrustum: function ( left, right, bottom, top, znear, zfar, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'no matrix destination !\\' );\\n                result = Matrix.create();\\n            }\\n            var X = 2.0 * znear / ( right - left );\\n            var Y = 2.0 * znear / ( top - bottom );\\n            var A = ( right + left ) / ( right - left );\\n            var B = ( top + bottom ) / ( top - bottom );\\n            var C = -( zfar + znear ) / ( zfar - znear );\\n            var D = -2.0 * zfar * znear / ( zfar - znear );\\n            Matrix.setRow( result, 0, X, 0.0, 0.0, 0.0 );\\n            Matrix.setRow( result, 1, 0.0, Y, 0.0, 0.0 );\\n            Matrix.setRow( result, 2, A, B, C, -1.0 );\\n            Matrix.setRow( result, 3, 0.0, 0.0, D, 0.0 );\\n            return result;\\n        },\\n\\n        makeRotateFromQuat: function ( quat, result ) {\\n            Matrix.makeIdentity( result );\\n            return Matrix.setRotateFromQuat( result, quat );\\n        },\\n\\n        setRotateFromQuat: function ( matrix, quat ) {\\n            var length2 = Quat.length2( quat );\\n            if ( Math.abs( length2 ) <= Number.MIN_VALUE ) {\\n                matrix[ 0 ] = 0.0;\\n                matrix[ 1 ] = 0.0;\\n                matrix[ 2 ] = 0.0;\\n\\n                matrix[ 4 ] = 0.0;\\n                matrix[ 5 ] = 0.0;\\n                matrix[ 6 ] = 0.0;\\n\\n                matrix[ 8 ] = 0.0;\\n                matrix[ 9 ] = 0.0;\\n                matrix[ 10 ] = 0.0;\\n            } else {\\n                var rlength2;\\n                // normalize quat if required.\\n                // We can avoid the expensive sqrt in this case since all \\'coefficients\\' below are products of two q components.\\n                // That is a square of a square root, so it is possible to avoid that\\n                if ( length2 !== 1.0 ) {\\n                    rlength2 = 2.0 / length2;\\n                } else {\\n                    rlength2 = 2.0;\\n                }\\n\\n                // Source: Gamasutra, Rotating Objects Using Quaternions\\n                //\\n                //http://www.gamasutra.com/features/19980703/quaternions_01.htm\\n\\n                var wx, wy, wz, xx, yy, yz, xy, xz, zz, x2, y2, z2;\\n\\n                // calculate coefficients\\n                x2 = rlength2 * quat[ 0 ];\\n                y2 = rlength2 * quat[ 1 ];\\n                z2 = rlength2 * quat[ 2 ];\\n\\n                xx = quat[ 0 ] * x2;\\n                xy = quat[ 0 ] * y2;\\n                xz = quat[ 0 ] * z2;\\n\\n                yy = quat[ 1 ] * y2;\\n                yz = quat[ 1 ] * z2;\\n                zz = quat[ 2 ] * z2;\\n\\n                wx = quat[ 3 ] * x2;\\n                wy = quat[ 3 ] * y2;\\n                wz = quat[ 3 ] * z2;\\n\\n                // Note.  Gamasutra gets the matrix assignments inverted, resulting\\n                // in left-handed rotations, which is contrary to OpenGL and OSG\\'s\\n                // methodology.  The matrix assignment has been altered in the next\\n                // few lines of code to do the right thing.\\n                // Don Burns - Oct 13, 2001\\n                matrix[ 0 ] = 1.0 - ( yy + zz );\\n                matrix[ 4 ] = xy - wz;\\n                matrix[ 8 ] = xz + wy;\\n\\n\\n                matrix[ 0 + 1 ] = xy + wz;\\n                matrix[ 4 + 1 ] = 1.0 - ( xx + zz );\\n                matrix[ 8 + 1 ] = yz - wx;\\n\\n                matrix[ 0 + 2 ] = xz - wy;\\n                matrix[ 4 + 2 ] = yz + wx;\\n                matrix[ 8 + 2 ] = 1.0 - ( xx + yy );\\n            }\\n            return matrix;\\n        }\\n    };\\n\\n    return Matrix;\\n} );\\n\\n//# sourceURL=/osg/Matrix.js\");\n\n",
    "eval(\"define( \\'osg/TransformEnums\\',[], function () {\\n\\n    return {\\n        RELATIVE_RF: 0,\\n        ABSOLUTE_RF: 1\\n    };\\n} );\\n\\n//# sourceURL=/osg/TransformEnums.js\");\n\n",
    "eval(\"define( \\'osg/ComputeMatrixFromNodePath\\',[\\n    \\'osg/Matrix\\',\\n    \\'osg/TransformEnums\\'\\n], function ( Matrix, TransformEnums ) {\\n\\n    var computeLocalToWorld = function ( nodePath, ignoreCameras ) {\\n        var ignoreCamera = ignoreCameras;\\n        if ( ignoreCamera === undefined ) {\\n            ignoreCamera = true;\\n        }\\n        var matrix = Matrix.create();\\n\\n        var j = 0;\\n        if ( ignoreCamera ) {\\n            for ( j = nodePath.length - 1; j > 0; j-- ) {\\n                var camera = nodePath[ j ];\\n                if ( camera.className() === \\'Camera\\' &&\\n                    ( camera.getReferenceFrame !== TransformEnums.RELATIVE_RF || camera.getParents().length === 0 ) ) {\\n                    break;\\n                }\\n            }\\n        }\\n\\n        for ( var i = j, l = nodePath.length; i < l; i++ ) {\\n            var node = nodePath[ i ];\\n            if ( node.computeLocalToWorldMatrix ) {\\n                node.computeLocalToWorldMatrix( matrix );\\n            }\\n        }\\n        return matrix;\\n    };\\n\\n    return {\\n        computeLocalToWorld: computeLocalToWorld\\n    };\\n} );\\n\\n//# sourceURL=/osg/ComputeMatrixFromNodePath.js\");\n\n",
    "eval(\"define( \\'osg/Node\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\',\\n    \\'osg/BoundingBox\\',\\n    \\'osg/BoundingSphere\\',\\n    \\'osg/StateSet\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/ComputeMatrixFromNodePath\\',\\n    \\'osg/TransformEnums\\'\\n], function ( MACROUTILS, Object, BoundingBox, BoundingSphere, StateSet, NodeVisitor, Matrix, ComputeMatrixFromNodePath, TransformEnums ) {\\n\\n    \\'use strict\\';\\n\\n    /**\\n     *  Node that can contains child node\\n     *  @class Node\\n     */\\n    var Node = function () {\\n        Object.call( this );\\n\\n        this.children = [];\\n        this.parents = [];\\n        /*jshint bitwise: false */\\n        this.nodeMask = ~0;\\n        /*jshint bitwise: true */\\n\\n        this.boundingSphere = new BoundingSphere();\\n        this.boundingSphereComputed = false;\\n        this._updateCallbacks = [];\\n        this._cullCallback = undefined;\\n        this._cullingActive = true;\\n        this._numChildrenWithCullingDisabled = 0;\\n    };\\n\\n    /** @lends Node.prototype */\\n    Node.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Object.prototype, {\\n        /**\\n        Return StateSet and create it if it does not exist yet\\n        @type StateSet\\n     */\\n        getOrCreateStateSet: function () {\\n            if ( this.stateset === undefined ) {\\n                this.stateset = new StateSet();\\n            }\\n            return this.stateset;\\n        },\\n        getStateSet: function () {\\n            return this.stateset;\\n        },\\n        accept: function ( nv ) {\\n            if ( nv.validNodeMask( this ) ) {\\n                nv.pushOntoNodePath( this );\\n                nv.apply( this );\\n                nv.popFromNodePath();\\n            }\\n        },\\n        dirtyBound: function () {\\n            if ( this.boundingSphereComputed === true ) {\\n                this.boundingSphereComputed = false;\\n                for ( var i = 0, l = this.parents.length; i < l; i++ ) {\\n                    this.parents[ i ].dirtyBound();\\n                }\\n            }\\n        },\\n        setNodeMask: function ( mask ) {\\n            this.nodeMask = mask;\\n        },\\n        getNodeMask: function () {\\n            return this.nodeMask;\\n        },\\n        setStateSet: function ( s ) {\\n            this.stateset = s;\\n        },\\n\\n        /**\\n       <p>\\n        Set update node callback, called during update traversal.\\n        The Object must have the following method\\n        update(node, nodeVisitor) {}\\n        note, callback is responsible for scenegraph traversal so\\n        they must call traverse(node,nv) to ensure that the\\n        scene graph subtree (and associated callbacks) are traversed.\\n        </p>\\n        <p>\\n        Here a dummy UpdateCallback example\\n        </p>\\n        @example\\n        var DummyUpdateCallback = function() {};\\n        DummyUpdateCallback.prototype = {\\n            update: function(node, nodeVisitor) {\\n                return true;\\n            }\\n        };\\n\\n        @param Oject callback\\n     */\\n        setUpdateCallback: function ( cb ) {\\n            if ( !this._updateCallbacks.length )\\n                this.addUpdateCallback( cb );\\n            else\\n                this._updateCallbacks[ 0 ] = cb;\\n        },\\n        /** Get update node callback, called during update traversal.\\n        @type Oject\\n     */\\n        getUpdateCallback: function () {\\n            return this._updateCallbacks[ 0 ];\\n        },\\n\\n        addUpdateCallback: function ( cb ) {\\n            this._updateCallbacks.push( cb );\\n        },\\n        removeUpdateCallback: function ( cb ) {\\n            var arrayIdx = this._updateCallbacks.indexOf( cb );\\n            if ( arrayIdx !== -1 )\\n                this._updateCallbacks.splice( arrayIdx, 1 );\\n        },\\n        getUpdateCallbackList: function () {\\n            return this._updateCallbacks;\\n        },\\n\\n\\n        /**\\n       <p>\\n        Set cull node callback, called during cull traversal.\\n        The Object must have the following method\\n        cull(node, nodeVisitor) {}\\n        note, callback is responsible for scenegraph traversal so\\n        they must return true to traverse.\\n        </p>\\n        <p>\\n        Here a dummy CullCallback example\\n        </p>\\n        @example\\n        var DummyCullCallback = function() {};\\n        DummyCullCallback.prototype = {\\n            cull: function(node, nodeVisitor) {\\n                return true;\\n            }\\n        };\\n\\n        @param Oject callback\\n     */\\n        setCullCallback: function ( cb ) {\\n            this._cullCallback = cb;\\n        },\\n        getCullCallback: function () {\\n            return this._cullCallback;\\n        },\\n\\n        hasChild: function ( child ) {\\n            for ( var i = 0, l = this.children.length; i < l; i++ ) {\\n                if ( this.children[ i ] === child ) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        },\\n        addChild: function ( child ) {\\n            var c = this.children.push( child );\\n            child.addParent( this );\\n            this.dirtyBound();\\n            return c;\\n        },\\n        getChildren: function () {\\n            return this.children;\\n        },\\n        getParents: function () {\\n            return this.parents;\\n        },\\n        addParent: function ( parent ) {\\n            this.parents.push( parent );\\n        },\\n        removeParent: function ( parent ) {\\n            for ( var i = 0, l = this.parents.length, parents = this.parents; i < l; i++ ) {\\n                if ( parents[ i ] === parent ) {\\n                    parents.splice( i, 1 );\\n                    return;\\n                }\\n            }\\n        },\\n        removeChildren: function () {\\n            var children = this.children;\\n            if ( children.length !== 0 ) {\\n                for ( var i = 0, l = children.length; i < l; i++ ) {\\n                    children[ i ].removeParent( this );\\n                }\\n                children.length = 0;\\n                this.dirtyBound();\\n            }\\n        },\\n\\n        // preserve order\\n        removeChild: function ( child ) {\\n            var children = this.children;\\n            for ( var i = 0, l = children.length; i < l; i++ ) {\\n                if ( children[ i ] === child ) {\\n                    child.removeParent( this );\\n                    children.splice( i, 1 );\\n                    i--;\\n                    l--;\\n                    this.dirtyBound();\\n                }\\n            }\\n        },\\n\\n        traverse: function ( visitor ) {\\n            for ( var i = 0, l = this.children.length; i < l; i++ ) {\\n                var child = this.children[ i ];\\n                child.accept( visitor );\\n            }\\n        },\\n\\n        ascend: function ( visitor ) {\\n            for ( var i = 0, l = this.parents.length; i < l; i++ ) {\\n                var parent = this.parents[ i ];\\n                parent.accept( visitor );\\n            }\\n        },\\n\\n        getBound: function () {\\n            if ( !this.boundingSphereComputed ) {\\n                this.computeBound( this.boundingSphere );\\n                this.boundingSphereComputed = true;\\n            }\\n            return this.boundingSphere;\\n        },\\n\\n        computeBound: function ( bsphere ) {\\n            var bb = new BoundingBox();\\n            bb.init();\\n            bsphere.init();\\n            for ( var i = 0, l = this.children.length; i < l; i++ ) {\\n                var child = this.children[ i ];\\n                if ( child.referenceFrame === undefined || child.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                    bb.expandBySphere( child.getBound() );\\n                }\\n            }\\n            if ( !bb.valid() ) {\\n                return bsphere;\\n            }\\n            bsphere._center = bb.center();\\n            bsphere._radius = 0.0;\\n            for ( var j = 0, l2 = this.children.length; j < l2; j++ ) {\\n                var cc = this.children[ j ];\\n                if ( cc.referenceFrame === undefined || cc.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                    bsphere.expandRadiusBySphere( cc.getBound() );\\n                }\\n            }\\n\\n            return bsphere;\\n        },\\n\\n        getWorldMatrices: function ( halt ) {\\n            var CollectParentPaths = function ( halt ) {\\n                this.nodePaths = [];\\n                this.halt = halt;\\n                NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );\\n            };\\n            CollectParentPaths.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n                apply: function ( node ) {\\n                    if ( node.parents.length === 0 || node === this.halt ) {\\n                        // copy\\n                        this.nodePaths.push( this.nodePath.slice( 0 ) );\\n                    } else {\\n                        this.traverse( node );\\n                    }\\n                }\\n            } );\\n            var collected = new CollectParentPaths( halt );\\n            this.accept( collected );\\n            var matrixList = [];\\n\\n            for ( var i = 0, l = collected.nodePaths.length; i < l; i++ ) {\\n                var np = collected.nodePaths[ i ];\\n                if ( np.length === 0 ) {\\n                    matrixList.push( Matrix.create() );\\n                } else {\\n                    matrixList.push( ComputeMatrixFromNodePath.computeLocalToWorld( np ) );\\n                }\\n            }\\n            return matrixList;\\n        },\\n\\n        setCullingActive: function ( value ) {\\n            if ( this._cullingActive === value ) return;\\n            if ( this._numChildrenWithCullingDisabled === 0 && this.parents.length > 0 ) {\\n                var delta = 0;\\n                if ( !this._cullingActive )--delta;\\n                if ( !value )++delta;\\n                if ( delta !== 0 ) {\\n                    for ( var i = 0, k = this.parents.length; i < k; i++ ) {\\n                        this.parents[ i ].setNumChildrenWithCullingDisabled( this.parents[ i ].getNumChildrenWithCullingDisabled() + delta );\\n                    }\\n                }\\n            }\\n            this._cullingActive = value;\\n        },\\n\\n        getCullingActive: function () {\\n            return this._cullingActive;\\n        },\\n\\n        isCullingActive: function () {\\n            return this._numChildrenWithCullingDisabled === 0 && this._cullingActive && this.getBound().valid();\\n        },\\n\\n        setNumChildrenWithCullingDisabled: function ( num ) {\\n            if ( this._numChildrenWithCullingDisabled === num ) return;\\n            if ( this._cullingActive && this.parents.length > 0 ) {\\n                var delta = 0;\\n                if ( this._numChildrenWithCullingDisabled > 0 )--delta;\\n                if ( num > 0 )++delta;\\n                if ( delta !== 0 ) {\\n                    for ( var i = 0, k = this.parents.length; i < k; i++ ) {\\n                        this.parents[ i ].setNumChildrenWithCullingDisabled( this.parents[ i ].getNumChildrenWithCullingDisabled() + delta );\\n                    }\\n                }\\n            }\\n            this._numChildrenWithCullingDisabled = num;\\n        },\\n\\n        getNumChildrenWithCullingDisabled: function () {\\n            return this._numChildrenWithCullingDisabled;\\n        }\\n\\n    } ), \\'osg\\', \\'Node\\' );\\n    MACROUTILS.setTypeID( Node );\\n\\n    return Node;\\n} );\\n\\n//# sourceURL=/osg/Node.js\");\n\n",
    "eval(\"define( \\'osg/Transform\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Node\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/TransformEnums\\'\\n], function ( MACROUTILS, Node, Matrix, Vec3, TransformEnums ) {\\n\\n    \\'use strict\\';\\n    /**\\n     * Transform - base class for Transform type node ( Camera, MatrixTransform )\\n     * @class Transform\\n     * @inherits Node\\n     */\\n    var Transform = function () {\\n        Node.call( this );\\n        this.referenceFrame = TransformEnums.RELATIVE_RF;\\n    };\\n\\n    /** @lends Transform.prototype */\\n    Transform.prototype = MACROUTILS.objectInehrit( Node.prototype, {\\n        setReferenceFrame: function ( value ) {\\n            this.referenceFrame = value;\\n        },\\n        getReferenceFrame: function () {\\n            return this.referenceFrame;\\n        },\\n\\n        computeBound: ( function () {\\n            var xdash = [ 0.0, 0.0, 0.0 ];\\n            var ydash = [ 0.0, 0.0, 0.0 ];\\n            var zdash = [ 0.0, 0.0, 0.0 ];\\n            return function ( bsphere ) {\\n                Node.prototype.computeBound.call( this, bsphere );\\n                if ( !bsphere.valid() ) {\\n                    return bsphere;\\n                }\\n                var sphCenter = bsphere._center;\\n                var sphRadius = bsphere._radius;\\n\\n                var matrix = Matrix.create();\\n                this.computeLocalToWorldMatrix( matrix );\\n\\n                Vec3.copy( sphCenter, xdash );\\n                xdash[ 0 ] += sphRadius;\\n                Matrix.transformVec3( matrix, xdash, xdash );\\n\\n                Vec3.copy( sphCenter, ydash );\\n                ydash[ 1 ] += sphRadius;\\n                Matrix.transformVec3( matrix, ydash, ydash );\\n\\n                Vec3.copy( sphCenter, zdash );\\n                zdash[ 2 ] += sphRadius;\\n                Matrix.transformVec3( matrix, zdash, zdash );\\n\\n                Matrix.transformVec3( matrix, sphCenter, sphCenter );\\n\\n                var lenXdash = Vec3.distance( xdash, sphCenter );\\n                var lenYdash = Vec3.distance( ydash, sphCenter );\\n                var lenZdash = Vec3.distance( zdash, sphCenter );\\n\\n                if ( lenXdash > lenYdash )\\n                    bsphere._radius = lenXdash > lenZdash ? lenXdash : lenZdash;\\n                else\\n                    bsphere._radius = lenYdash > lenZdash ? lenYdash : lenZdash;\\n                return bsphere;\\n            };\\n        } )()\\n    } );\\n\\n    return Transform;\\n} );\\n\\n//# sourceURL=/osg/Transform.js\");\n\n",
    "eval(\"define( \\'osg/CullSettings\\',[], function () {\\n\\n    var CullSettings = function () {\\n        this._computeNearFar = true;\\n        this._nearFarRatio = 0.005;\\n\\n        var lookVector = [ 0.0, 0.0, -1.0 ];\\n        /*jshint bitwise: false */\\n        this.bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\\n        this.bbCornerNear = ( ~this.bbCornerFar ) & 7;\\n        /*jshint bitwise: true */\\n    };\\n\\n    CullSettings.prototype = {\\n        setCullSettings: function ( settings ) {\\n            this._computeNearFar = settings._computeNearFar;\\n            this._nearFarRatio = settings._nearFarRatio;\\n        },\\n        setNearFarRatio: function ( ratio ) {\\n            this._nearFarRatio = ratio;\\n        },\\n        getNearFarRatio: function () {\\n            return this._nearFarRatio;\\n        },\\n        setComputeNearFar: function ( value ) {\\n            this._computeNearFar = value;\\n        },\\n        getComputeNearFar: function () {\\n            return this._computeNearFar;\\n        }\\n    };\\n\\n    return CullSettings;\\n} );\\n\\n//# sourceURL=/osg/CullSettings.js\");\n\n",
    "eval(\"define( \\'osg/Camera\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Transform\\',\\n    \\'osg/CullSettings\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/TransformEnums\\'\\n], function ( MACROUTILS, Transform, CullSettings, Matrix, TransformEnums ) {\\n\\n    /**\\n     * Camera - is a subclass of Transform which represents encapsulates the settings of a Camera.\\n     * @class Camera\\n     * @inherits Transform CullSettings\\n     */\\n    var Camera = function () {\\n        Transform.call( this );\\n        CullSettings.call( this );\\n\\n        this.viewport = undefined;\\n        this._graphicContext = undefined;\\n        this.setClearColor( [ 0, 0, 0, 1.0 ] );\\n        this.setClearDepth( 1.0 );\\n\\n        /*jshint bitwise: false */\\n        this.setClearMask( Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT );\\n        /*jshint bitwise: true */\\n\\n        this.setViewMatrix( Matrix.create() );\\n        this.setProjectionMatrix( Matrix.create() );\\n        this.renderOrder = Camera.NESTED_RENDER;\\n        this.renderOrderNum = 0;\\n    };\\n\\n    Camera.PRE_RENDER = 0;\\n    Camera.NESTED_RENDER = 1;\\n    Camera.POST_RENDER = 2;\\n\\n    Camera.COLOR_BUFFER_BIT = 0x00004000;\\n    Camera.DEPTH_BUFFER_BIT = 0x00000100;\\n    Camera.STENCIL_BUFFER_BIT = 0x00000400;\\n\\n    /** @lends Camera.prototype */\\n    Camera.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit(\\n        CullSettings.prototype,\\n        MACROUTILS.objectInehrit( Transform.prototype, {\\n\\n            setGraphicContext: function ( gc ) {\\n                this._graphicContext = gc;\\n            },\\n            getGraphicContext: function () {\\n                return this._graphicContext;\\n            },\\n            setClearDepth: function ( depth ) {\\n                this.clearDepth = depth;\\n            },\\n            getClearDepth: function () {\\n                return this.clearDepth;\\n            },\\n\\n            setClearMask: function ( mask ) {\\n                this.clearMask = mask;\\n            },\\n            getClearMask: function () {\\n                return this.clearMask;\\n            },\\n\\n            setClearColor: function ( color ) {\\n                this.clearColor = color;\\n            },\\n            getClearColor: function () {\\n                return this.clearColor;\\n            },\\n\\n            setViewport: function ( vp ) {\\n                this.viewport = vp;\\n                this.getOrCreateStateSet().setAttributeAndMode( vp );\\n            },\\n            getViewport: function () {\\n                return this.viewport;\\n            },\\n\\n\\n            setViewMatrix: function ( matrix ) {\\n                this.modelviewMatrix = matrix;\\n            },\\n\\n            setProjectionMatrix: function ( matrix ) {\\n                this.projectionMatrix = matrix;\\n            },\\n\\n            /** Set to an orthographic projection. See OpenGL glOrtho for documentation further details.*/\\n            setProjectionMatrixAsOrtho: function ( left, right,\\n                bottom, top,\\n                zNear, zFar ) {\\n                Matrix.makeOrtho( left, right, bottom, top, zNear, zFar, this.getProjectionMatrix() );\\n            },\\n\\n            getViewMatrix: function () {\\n                return this.modelviewMatrix;\\n            },\\n            getProjectionMatrix: function () {\\n                return this.projectionMatrix;\\n            },\\n            getRenderOrder: function () {\\n                return this.renderOrder;\\n            },\\n            setRenderOrder: function ( order, orderNum ) {\\n                this.renderOrder = order;\\n                this.renderOrderNum = orderNum;\\n            },\\n\\n            attachTexture: function ( bufferComponent, texture, level ) {\\n                if ( this.frameBufferObject ) {\\n                    this.frameBufferObject.dirty();\\n                }\\n                if ( level === undefined ) {\\n                    level = 0;\\n                }\\n                if ( this.attachments === undefined ) {\\n                    this.attachments = {};\\n                }\\n                this.attachments[ bufferComponent ] = {\\n                    \\'texture\\': texture,\\n                    \\'level\\': level\\n                };\\n            },\\n\\n            attachRenderBuffer: function ( bufferComponent, internalFormat ) {\\n                if ( this.frameBufferObject ) {\\n                    this.frameBufferObject.dirty();\\n                }\\n                if ( this.attachments === undefined ) {\\n                    this.attachments = {};\\n                }\\n                this.attachments[ bufferComponent ] = {\\n                    \\'format\\': internalFormat\\n                };\\n            },\\n\\n            computeLocalToWorldMatrix: function ( matrix /*,nodeVisitor*/ ) {\\n                if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                    Matrix.preMult( matrix, this.modelviewMatrix );\\n                } else { // absolute\\n                    matrix = this.modelviewMatrix;\\n                }\\n                return true;\\n            },\\n\\n            computeWorldToLocalMatrix: ( function ( matrix /*, nodeVisitor */ ) {\\n                var inverse = Matrix.create();\\n                return function () {\\n                    if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                        Matrix.postMult( Matrix.inverse( this.modelviewMatrix, inverse ), matrix );\\n                    } else {\\n                        Matrix.inverse( this.modelviewMatrix, matrix );\\n                    }\\n                    return true;\\n                };\\n            } )()\\n\\n        } ) ), \\'osg\\', \\'Camera\\' );\\n\\n    MACROUTILS.setTypeID( Camera );\\n\\n    return Camera;\\n} );\\n\\n//# sourceURL=/osg/Camera.js\");\n\n",
    "eval(\"define( \\'osg/CullFace\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\'\\n], function ( MACROUTILS, StateAttribute ) {\\n\\n    /**\\n     *  Manage CullFace attribute\\n     *  @class CullFace\\n     */\\n    var CullFace = function ( mode ) {\\n        StateAttribute.call( this );\\n        if ( mode === undefined ) {\\n            mode = CullFace.BACK;\\n        }\\n        this.setMode( mode );\\n    };\\n\\n    CullFace.DISABLE = 0x0;\\n    CullFace.FRONT = 0x0404;\\n    CullFace.BACK = 0x0405;\\n    CullFace.FRONT_AND_BACK = 0x0408;\\n\\n    /** @lends CullFace.prototype */\\n    CullFace.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'CullFace\\',\\n        cloneType: function () {\\n            return new CullFace();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setMode: function ( mode ) {\\n            if ( typeof mode === \\'string\\' ) {\\n                mode = CullFace[ mode ];\\n            }\\n            this._mode = mode;\\n        },\\n        getMode: function () {\\n            return this._mode;\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            if ( this._mode === CullFace.DISABLE ) {\\n                gl.disable( gl.CULL_FACE );\\n            } else {\\n                gl.enable( gl.CULL_FACE );\\n                gl.cullFace( this._mode );\\n            }\\n            this._dirty = false;\\n        }\\n    } ), \\'osg\\', \\'CullFace\\' );\\n\\n    return CullFace;\\n} );\\n\\n//# sourceURL=/osg/CullFace.js\");\n\n",
    "eval(\"define( \\'osg/CullStack\\',[], function () {\\n\\n    var CullStack = function () {\\n        this._modelviewMatrixStack = [];\\n        this._projectionMatrixStack = [];\\n        this._viewportStack = [];\\n        this._bbCornerFar = 0;\\n        this._bbCornerNear = 0;\\n    };\\n\\n    CullStack.prototype = {\\n        getProjectionMatrixStack: function () {\\n            return this._projectionMatrixStack;\\n        },\\n        getModelviewMatrixStack: function () {\\n            return this._modelviewMatrixStack;\\n        },\\n        getCurrentProjectionMatrix: function () {\\n            return this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\\n        },\\n        getCurrentModelviewMatrix: function () {\\n            return this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n        },\\n        getViewport: function () {\\n            if ( this._viewportStack.length === 0 ) {\\n                return undefined;\\n            }\\n            return this._viewportStack[ this._viewportStack.length - 1 ];\\n        },\\n        getLookVectorLocal: function () {\\n            var m = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n            return [ -m[ 2 ], -m[ 6 ], -m[ 10 ] ];\\n        },\\n        pushViewport: function ( vp ) {\\n            this._viewportStack.push( vp );\\n        },\\n        popViewport: function () {\\n            this._viewportStack.pop();\\n        },\\n        pushModelviewMatrix: function ( matrix ) {\\n            this._modelviewMatrixStack.push( matrix );\\n\\n            var lookVector = this.getLookVectorLocal();\\n\\n            /*jshint bitwise: false */\\n            this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\\n            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\\n            /*jshint bitwise: true */\\n\\n        },\\n        popModelviewMatrix: function () {\\n\\n            this._modelviewMatrixStack.pop();\\n            var lookVector;\\n            if ( this._modelviewMatrixStack.length !== 0 ) {\\n                lookVector = this.getLookVectorLocal();\\n            } else {\\n                lookVector = [ 0, 0, -1 ];\\n            }\\n\\n            /*jshint bitwise: false */\\n            this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\\n            this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\\n            /*jshint bitwise: true */\\n\\n\\n        },\\n        pushProjectionMatrix: function ( matrix ) {\\n            this._projectionMatrixStack.push( matrix );\\n        },\\n        popProjectionMatrix: function () {\\n            this._projectionMatrixStack.pop();\\n        }\\n    };\\n\\n    return CullStack;\\n} );\\n\\n//# sourceURL=/osg/CullStack.js\");\n\n",
    "eval(\"define( \\'osg/MatrixTransform\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Transform\\',\\n    \\'osg/TransformEnums\\'\\n], function ( MACROUTILS, Matrix, Transform, TransformEnums ) {\\n\\n    /**\\n     *  MatrixTransform is a Transform Node that can be customized with user matrix\\n     *  @class MatrixTransform\\n     */\\n    var MatrixTransform = function () {\\n        Transform.call( this );\\n        this.matrix = Matrix.create();\\n    };\\n\\n    /** @lends MatrixTransform.prototype */\\n    MatrixTransform.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Transform.prototype, {\\n        getMatrix: function () {\\n            return this.matrix;\\n        },\\n        setMatrix: function ( m ) {\\n            this.matrix = m;\\n        },\\n        computeLocalToWorldMatrix: function ( matrix /*, nodeVisitor */) {\\n            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                Matrix.preMult( matrix, this.matrix );\\n            } else {\\n                matrix = this.matrix;\\n            }\\n            return true;\\n        },\\n        computeWorldToLocalMatrix: function ( matrix /*, nodeVisitor */ ) {\\n            var minverse = Matrix.create();\\n            Matrix.inverse( this.matrix, minverse );\\n\\n            if ( this.referenceFrame === TransformEnums.RELATIVE_RF ) {\\n                Matrix.postMult( minverse, matrix );\\n            } else { // absolute\\n                matrix = minverse;\\n            }\\n            return true;\\n        }\\n    } ), \\'osg\\', \\'MatrixTransform\\' );\\n    MACROUTILS.setTypeID( MatrixTransform );\\n\\n    return MatrixTransform;\\n} );\\n\\n//# sourceURL=/osg/MatrixTransform.js\");\n\n",
    "eval(\"define( \\'osg/Projection\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Node\\',\\n    \\'osg/Matrix\\'\\n], function ( MACROUTILS, Node, Matrix ) {\\n\\n    var Projection = function () {\\n        Node.call( this );\\n        this.projection = Matrix.create();\\n    };\\n    Projection.prototype = MACROUTILS.objectInehrit( Node.prototype, {\\n        getProjectionMatrix: function () {\\n            return this.projection;\\n        },\\n        setProjectionMatrix: function ( m ) {\\n            this.projection = m;\\n        }\\n    } );\\n\\n    MACROUTILS.setTypeID( Projection );\\n\\n    return Projection;\\n} );\\n\\n//# sourceURL=/osg/Projection.js\");\n\n",
    "eval(\"define( \\'osg/LightSource\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Node\\'\\n], function ( MACROUTILS, Node ) {\\n\\n    /**\\n     *  LightSource is a positioned node to use with StateAttribute Light\\n     *  @class LightSource\\n     */\\n    var LightSource = function () {\\n        Node.call( this );\\n        this._light = undefined;\\n    };\\n\\n    /** @lends LightSource.prototype */\\n    LightSource.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Node.prototype, {\\n        getLight: function () {\\n            return this._light;\\n        },\\n        setLight: function ( light ) {\\n            this._light = light;\\n        }\\n    } ), \\'osg\\', \\'LightSource\\' );\\n\\n    MACROUTILS.setTypeID( LightSource );\\n\\n    return LightSource;\\n} );\\n\\n//# sourceURL=/osg/LightSource.js\");\n\n",
    "eval(\"define( \\'osg/Geometry\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Node\\',\\n    \\'osg/BoundingBox\\'\\n], function ( MACROUTILS, Vec3, Node, BoundingBox ) {\\n\\n    /**\\n     * Geometry manage array and primitives to draw a geometry.\\n     * @class Geometry\\n     */\\n    var Geometry = function () {\\n        Node.call( this );\\n        this.primitives = [];\\n        this.attributes = {};\\n        this.boundingBox = new BoundingBox();\\n        this.boundingBoxComputed = false;\\n        this.cacheAttributeList = {};\\n        this._shape = null;\\n    };\\n\\n    /** @lends Geometry.prototype */\\n    Geometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Node.prototype, {\\n        releaseGLObjects: function ( gl ) {\\n            var i;\\n            for ( i in this.attributes ) {\\n                this.attributes[ i ].releaseGLObjects( gl );\\n            }\\n            for ( var j = 0, l = this.primitives.length; j < l; j++ ) {\\n                var prim = this.primitives[ j ];\\n                if ( prim.getIndices !== undefined ) {\\n                    if ( prim.getIndices() !== undefined && prim.getIndices() !== null ) {\\n                        prim.indices.releaseGLObjects( gl );\\n                    }\\n                }\\n            }\\n        },\\n        dirtyBound: function () {\\n            if ( this.boundingBoxComputed === true ) {\\n                this.boundingBoxComputed = false;\\n            }\\n            Node.prototype.dirtyBound.call( this );\\n        },\\n\\n        dirty: function () {\\n            this.cacheAttributeList = {};\\n        },\\n        getPrimitives: function () {\\n            return this.primitives;\\n        },\\n        getAttributes: function () {\\n            return this.attributes;\\n        },\\n        getShape: function () {\\n            return this._shape;\\n        },\\n        setShape: function ( shape ) {\\n            this._shape = shape;\\n        },\\n        getVertexAttributeList: function () {\\n            return this.attributes;\\n        },\\n        getPrimitiveSetList: function () {\\n            return this.primitives;\\n        },\\n\\n        drawImplementation: function ( state ) {\\n            var program = state.getLastProgramApplied();\\n            var prgID = program.getInstanceID();\\n            if ( this.cacheAttributeList[ prgID ] === undefined ) {\\n                var attribute;\\n\\n                var attributesCacheKeys = program.attributesCache.getKeys();\\n                var attributesCacheMap = program.attributesCache;\\n                var attributeList = [];\\n\\n                var generated = \\'//generated by Geometry::implementation\\\\n\\';\\n                generated += \\'state.lazyDisablingOfVertexAttributes();\\\\n\\';\\n                generated += \\'var attr;\\\\n\\';\\n\\n                for ( var i = 0, l = attributesCacheKeys.length; i < l; i++ ) {\\n                    var key = attributesCacheKeys[ i ];\\n                    attribute = attributesCacheMap[ key ];\\n                    var attr = this.attributes[ key ];\\n                    if ( attr === undefined ) {\\n                        continue;\\n                    }\\n                    attributeList.push( attribute );\\n                    // dont display the geometry if missing data\\n                    generated += \\'attr = this.attributes[\\\\\\'\\' + key + \\'\\\\\\'];\\\\n\\';\\n                    generated += \\'if (!attr.isValid()) { return; }\\\\n\\';\\n                    generated += \\'state.setVertexAttribArray(\\' + attribute + \\', attr, false);\\\\n\\';\\n                }\\n                generated += \\'state.applyDisablingOfVertexAttributes();\\\\n\\';\\n                var primitives = this.primitives;\\n                generated += \\'var primitives = this.primitives;\\\\n\\';\\n                for ( var j = 0, m = primitives.length; j < m; ++j ) {\\n                    generated += \\'primitives[\\' + j + \\'].draw(state);\\\\n\\';\\n                }\\n\\n                /*jshint evil: true */\\n                this.cacheAttributeList[ prgID ] = new Function( \\'state\\', generated );\\n                /*jshint evil: false */\\n            }\\n            this.cacheAttributeList[ prgID ].call( this, state );\\n        },\\n\\n        // for testing disabling drawing\\n        drawImplementationDummy: function ( state ) {\\n            /*jshint unused: true */\\n            // for testing only that\\'s why the code is not removed\\n            var program = state.getLastProgramApplied();\\n            var attribute;\\n            var attributeList = [];\\n            var attributesCache = program.attributesCache;\\n\\n\\n            var primitives = this.primitives;\\n            //state.disableVertexAttribsExcept(attributeList);\\n\\n            for ( var j = 0, m = primitives.length; j < m; ++j ) {\\n                //primitives[j].draw(state);\\n            }\\n            /*jshint unused: false */\\n        },\\n\\n        getBoundingBox: function () {\\n            if ( !this.boundingBoxComputed ) {\\n                this.computeBoundingBox( this.boundingBox );\\n                this.boundingBoxComputed = true;\\n            }\\n            return this.boundingBox;\\n        },\\n\\n        computeBoundingBox: function ( boundingBox ) {\\n\\n            var vertexArray = this.getAttributes().Vertex;\\n            var v = [ 0.0, 0.0, 0.0 ];\\n            if ( vertexArray !== undefined &&\\n                vertexArray.getElements() !== undefined &&\\n                vertexArray.getItemSize() > 2 ) {\\n                var vertexes = vertexArray.getElements();\\n                Vec3.init( v );\\n                for ( var idx = 0, l = vertexes.length; idx < l; idx += 3 ) {\\n                    v[ 0 ] = vertexes[ idx ];\\n                    v[ 1 ] = vertexes[ idx + 1 ];\\n                    v[ 2 ] = vertexes[ idx + 2 ];\\n                    boundingBox.expandByVec3( v );\\n                }\\n            }\\n            return boundingBox;\\n        },\\n\\n        computeBound: function ( boundingSphere ) {\\n            boundingSphere.init();\\n            var bb = this.getBoundingBox();\\n            boundingSphere.expandByBox( bb );\\n            return boundingSphere;\\n        }\\n    } ), \\'osg\\', \\'Geometry\\' );\\n\\n    MACROUTILS.setTypeID( Geometry );\\n\\n    return Geometry;\\n} );\\n\\n//# sourceURL=/osg/Geometry.js\");\n\n",
    "eval(\"define( \\'osg/RenderBin\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/StateGraph\\',\\n    \\'osg/Matrix\\'\\n], function ( Notify, StateGraph, Matrix ) {\\n\\n    var RenderBin = function () {\\n        this._leafs = [];\\n        this.positionedAttribute = [];\\n        this._renderStage = undefined;\\n        this._bins = {};\\n        this.stateGraphList = [];\\n        this._parent = undefined;\\n        this._binNum = 0;\\n\\n        this._sorted = false;\\n        this._sortMode = RenderBin.SORT_BY_STATE;\\n\\n    };\\n    RenderBin.SORT_BY_STATE = 0;\\n    RenderBin.SORT_BACK_TO_FRONT = 1;\\n    RenderBin.BinPrototypes = {\\n        RenderBin: function () {\\n            return new RenderBin();\\n        },\\n        DepthSortedBin: function () {\\n            var rb = new RenderBin();\\n            rb._sortMode = RenderBin.SORT_BACK_TO_FRONT;\\n            return rb;\\n        }\\n    };\\n\\n    RenderBin.prototype = {\\n        _createRenderBin: function ( binName ) {\\n            if ( binName === undefined || RenderBin.BinPrototypes[ binName ] === undefined ) {\\n                return RenderBin.BinPrototypes.RenderBin();\\n            }\\n            return RenderBin.BinPrototypes[ binName ]();\\n        },\\n        getStateGraphList: function () {\\n            return this.stateGraphList;\\n        },\\n        copyLeavesFromStateGraphListToRenderLeafList: function () {\\n\\n            this._leafs.splice( 0, this._leafs.length );\\n            var detectedNaN = false;\\n\\n            for ( var i = 0, l = this.stateGraphList.length; i < l; i++ ) {\\n                var leafs = this.stateGraphList[ i ].leafs;\\n                for ( var j = 0, k = leafs.length; j < k; j++ ) {\\n                    var leaf = leafs[ j ];\\n                    if ( isNaN( leaf.depth ) ) {\\n                        detectedNaN = true;\\n                    } else {\\n                        this._leafs.push( leaf );\\n                    }\\n                }\\n            }\\n\\n            if ( detectedNaN ) {\\n                Notify.debug( \\'warning: RenderBin::copyLeavesFromStateGraphListToRenderLeafList() detected NaN depth values, database may be corrupted.\\' );\\n            }\\n            // empty the render graph list to prevent it being drawn along side the render leaf list (see drawImplementation.)\\n            this.stateGraphList.splice( 0, this.stateGraphList.length );\\n        },\\n\\n        sortBackToFront: function () {\\n            this.copyLeavesFromStateGraphListToRenderLeafList();\\n            var cmp = function ( a, b ) {\\n                return b.depth - a.depth;\\n            };\\n            this._leafs.sort( cmp );\\n        },\\n\\n        sortImplementation: function () {\\n            var SortMode = RenderBin;\\n            switch ( this._sortMode ) {\\n            case SortMode.SORT_BACK_TO_FRONT:\\n                this.sortBackToFront();\\n                break;\\n            case SortMode.SORT_BY_STATE:\\n                // do nothing\\n                break;\\n            }\\n        },\\n\\n        sort: function () {\\n            if ( this._sorted ) {\\n                return;\\n            }\\n\\n            var bins = this._bins;\\n            var keys = window.Object.keys( bins );\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                bins[ keys[ i ] ].sort();\\n            }\\n            this.sortImplementation();\\n\\n            this._sorted = true;\\n        },\\n\\n        setParent: function ( parent ) {\\n            this._parent = parent;\\n        },\\n        getParent: function () {\\n            return this._parent;\\n        },\\n        getBinNumber: function () {\\n            return this._binNum;\\n        },\\n        findOrInsert: function ( binNum, binName ) {\\n            var bin = this._bins[ binNum ];\\n            if ( bin === undefined ) {\\n                bin = this._createRenderBin( binName );\\n                bin._parent = this;\\n                bin._binNum = binNum;\\n                bin._renderStage = this._renderStage;\\n                this._bins[ binNum ] = bin;\\n            }\\n            return bin;\\n        },\\n        getStage: function () {\\n            return this._renderStage;\\n        },\\n        addStateGraph: function ( sg ) {\\n            this.stateGraphList.push( sg );\\n        },\\n        reset: function () {\\n            this.stateGraphList.length = 0;\\n            this._bins = {};\\n            this.positionedAttribute.length = 0;\\n            this._leafs.length = 0;\\n            this._sorted = false;\\n        },\\n        applyPositionedAttribute: function ( state, positionedAttributes ) {\\n            // the idea is to set uniform \\'globally\\' in uniform map.\\n            for ( var index = 0, l = positionedAttributes.length; index < l; index++ ) {\\n                var element = positionedAttributes[ index ];\\n                // add or set uniforms in state\\n                var stateAttribute = element[ 1 ];\\n                var matrix = element[ 0 ];\\n                state.setGlobalDefaultValue( stateAttribute );\\n                stateAttribute.apply( state );\\n                stateAttribute.applyPositionedUniform( matrix, state );\\n                state.haveAppliedAttribute( stateAttribute );\\n            }\\n        },\\n\\n        drawImplementation: function ( state, previousRenderLeaf ) {\\n            var previous = previousRenderLeaf;\\n            var binsKeys = window.Object.keys( this._bins );\\n            var bins = this._bins;\\n            var binsArray = [];\\n            for ( var i = 0, l = binsKeys.length; i < l; i++ ) {\\n                var k = binsKeys[ i ];\\n                binsArray.push( bins[ k ] );\\n            }\\n            var cmp = function ( a, b ) {\\n                return a._binNum - b._binNum;\\n            };\\n            binsArray.sort( cmp );\\n\\n            var current = 0;\\n            var end = binsArray.length;\\n\\n            var bin;\\n            // draw pre bins\\n            for ( ; current < end; current++ ) {\\n                bin = binsArray[ current ];\\n                if ( bin.getBinNumber() > 0 ) {\\n                    break;\\n                }\\n                previous = bin.drawImplementation( state, previous );\\n            }\\n\\n            // draw leafs\\n            previous = this.drawLeafs( state, previous );\\n\\n            // draw post bins\\n            for ( ; current < end; current++ ) {\\n                bin = binsArray[ current ];\\n                previous = bin.drawImplementation( state, previous );\\n            }\\n            return previous;\\n        },\\n\\n        drawGeometry: ( function() {\\n            var normal = Matrix.create();\\n            var modelViewUniform, projectionUniform, normalUniform, program;\\n\\n            return function( state, leaf, push ) {\\n\\n                var gl = state.getGraphicContext();\\n\\n                if ( push === true ) {\\n\\n                    state.apply();\\n                    program = state.getLastProgramApplied();\\n\\n                    modelViewUniform = program.uniformsCache[ state.modelViewMatrix.name ];\\n                    projectionUniform = program.uniformsCache[ state.projectionMatrix.name ];\\n                    normalUniform = program.uniformsCache[ state.normalMatrix.name ];\\n                }\\n\\n\\n                if ( modelViewUniform !== undefined ) {\\n                    state.modelViewMatrix.set( leaf.modelview );\\n                    state.modelViewMatrix.apply( gl, modelViewUniform );\\n                }\\n\\n                if ( projectionUniform !== undefined ) {\\n                    state.projectionMatrix.set( leaf.projection );\\n                    state.projectionMatrix.apply( gl, projectionUniform );\\n                }\\n\\n                if ( normalUniform !== undefined ) {\\n                    Matrix.copy( leaf.modelview, normal );\\n                    normal[ 12 ] = 0.0;\\n                    normal[ 13 ] = 0.0;\\n                    normal[ 14 ] = 0.0;\\n\\n                    Matrix.inverse( normal, normal );\\n                    Matrix.transpose( normal, normal );\\n                    state.normalMatrix.set( normal );\\n                    state.normalMatrix.apply( gl, normalUniform );\\n                }\\n\\n                leaf.geometry.drawImplementation( state );\\n\\n                if ( push === true ) {\\n                    state.popGeneratedProgram();\\n                    state.popStateSet();\\n                }\\n\\n            };\\n        })(),\\n\\n        drawLeafs: function ( state, previousRenderLeaf ) {\\n            var stateList = this.stateGraphList;\\n            var leafs = this._leafs;\\n            var previousLeaf = previousRenderLeaf;\\n\\n            if ( previousLeaf ) {\\n                StateGraph.prototype.moveToRootStateGraph( state, previousRenderLeaf.parent );\\n            }\\n\\n            var leaf, push;\\n            var prevRenderGraph, prevRenderGraphParent, rg;\\n\\n            // draw fine grained ordering.\\n            for ( var d = 0, dl = leafs.length; d < dl; d++ ) {\\n                leaf = leafs[ d ];\\n                push = false;\\n                if ( previousLeaf !== undefined ) {\\n\\n                    // apply state if required.\\n                    prevRenderGraph = previousLeaf.parent;\\n                    prevRenderGraphParent = prevRenderGraph.parent;\\n                    rg = leaf.parent;\\n                    if ( prevRenderGraphParent !== rg.parent ) {\\n                        rg.moveStateGraph( state, prevRenderGraphParent, rg.parent );\\n\\n                        // send state changes and matrix changes to OpenGL.\\n                        state.pushStateSet( rg.stateset );\\n                        push = true;\\n                    } else if ( rg !== prevRenderGraph ) {\\n                        // send state changes and matrix changes to OpenGL.\\n                        state.pushStateSet( rg.stateset );\\n                        push = true;\\n                    }\\n\\n                } else {\\n                    leaf.parent.moveStateGraph( state, undefined, leaf.parent.parent );\\n                    state.pushStateSet( leaf.parent.stateset );\\n                    push = true;\\n                }\\n\\n                this.drawGeometry( state, leaf, push );\\n\\n                previousLeaf = leaf;\\n            }\\n\\n\\n            // draw coarse grained ordering.\\n            for ( var i = 0, l = stateList.length; i < l; i++ ) {\\n                var sg = stateList[ i ];\\n                for ( var j = 0, ll = sg.leafs.length; j < ll; j++ ) {\\n\\n                    leaf = sg.leafs[ j ];\\n                    push = false;\\n                    if ( previousLeaf !== undefined ) {\\n\\n                        // apply state if required.\\n                        prevRenderGraph = previousLeaf.parent;\\n                        prevRenderGraphParent = prevRenderGraph.parent;\\n                        rg = leaf.parent;\\n                        if ( prevRenderGraphParent !== rg.parent ) {\\n                            rg.moveStateGraph( state, prevRenderGraphParent, rg.parent );\\n\\n                            // send state changes and matrix changes to OpenGL.\\n                            state.pushStateSet( rg.stateset );\\n                            push = true;\\n                        } else if ( rg !== prevRenderGraph ) {\\n                            // send state changes and matrix changes to OpenGL.\\n                            state.pushStateSet( rg.stateset );\\n                            push = true;\\n                        }\\n\\n                    } else {\\n                        leaf.parent.moveStateGraph( state, undefined, leaf.parent.parent );\\n                        state.pushStateSet( leaf.parent.stateset );\\n                        push = true;\\n                    }\\n\\n                    this.drawGeometry( state, leaf, push );\\n\\n                    previousLeaf = leaf;\\n                }\\n            }\\n            return previousLeaf;\\n        }\\n    };\\n\\n    return RenderBin;\\n} );\\n\\n//# sourceURL=/osg/RenderBin.js\");\n\n",
    "eval(\"define( \\'osg/FrameBufferObject\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\'\\n], function ( Notify, MACROUTILS, StateAttribute ) {\\n\\n    /**\\n     * FrameBufferObject manage fbo / rtt\\n     * @class FrameBufferObject\\n     */\\n    var FrameBufferObject = function () {\\n        StateAttribute.call( this );\\n        this.fbo = undefined;\\n        this.attachments = [];\\n        this.dirty();\\n    };\\n\\n    FrameBufferObject.COLOR_ATTACHMENT0 = 0x8CE0;\\n    FrameBufferObject.DEPTH_ATTACHMENT = 0x8D00;\\n    FrameBufferObject.DEPTH_COMPONENT16 = 0x81A5;\\n\\n    /** @lends FrameBufferObject.prototype */\\n    FrameBufferObject.prototype = MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'FrameBufferObject\\',\\n        cloneType: function () {\\n            return new FrameBufferObject();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setAttachment: function ( attachment ) {\\n            this.attachments.push( attachment );\\n        },\\n        _reportFrameBufferError: function ( code ) {\\n            switch ( code ) {\\n            case 0x8CD6:\\n                Notify.debug( \\'FRAMEBUFFER_INCOMPLETE_ATTACHMENT\\' );\\n                break;\\n            case 0x8CD7:\\n                Notify.debug( \\'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT\\' );\\n                break;\\n            case 0x8CD9:\\n                Notify.debug( \\'FRAMEBUFFER_INCOMPLETE_DIMENSIONS\\' );\\n                break;\\n            case 0x8CDD:\\n                Notify.debug( \\'FRAMEBUFFER_UNSUPPORTED\\' );\\n                break;\\n            default:\\n                Notify.debug( \\'FRAMEBUFFER unknown error \\' + code.toString( 16 ) );\\n            }\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            var status;\\n            if ( this.attachments.length > 0 ) {\\n                if ( this.isDirty() ) {\\n\\n                    if ( !this.fbo ) {\\n                        this.fbo = gl.createFramebuffer();\\n                    }\\n\\n                    gl.bindFramebuffer( gl.FRAMEBUFFER, this.fbo );\\n                    var hasRenderBuffer = false;\\n                    for ( var i = 0, l = this.attachments.length; i < l; ++i ) {\\n\\n                        if ( this.attachments[ i ].texture === undefined ) { // render buffer\\n                            var rb = gl.createRenderbuffer();\\n                            gl.bindRenderbuffer( gl.RENDERBUFFER, rb );\\n                            gl.renderbufferStorage( gl.RENDERBUFFER, this.attachments[ i ].format, this.attachments[ i ].width, this.attachments[ i ].height );\\n                            gl.framebufferRenderbuffer( gl.FRAMEBUFFER, this.attachments[ i ].attachment, gl.RENDERBUFFER, rb );\\n                            hasRenderBuffer = true;\\n                        } else {\\n                            var texture = this.attachments[ i ].texture;\\n                            // apply on unit 0 to init it\\n                            state.applyTextureAttribute( 0, texture );\\n\\n                            gl.framebufferTexture2D( gl.FRAMEBUFFER, this.attachments[ i ].attachment, texture.getTextureTarget(), texture.getTextureObject().id(), this.attachments[ i ].level );\\n                        }\\n                    }\\n                    status = gl.checkFramebufferStatus( gl.FRAMEBUFFER );\\n                    if ( status !== 0x8CD5 ) {\\n                        this._reportFrameBufferError( status );\\n                    }\\n\\n                    if ( hasRenderBuffer ) { // set it to null only if used renderbuffer\\n                        gl.bindRenderbuffer( gl.RENDERBUFFER, null );\\n                    }\\n                    this.setDirty( false );\\n                } else {\\n                    gl.bindFramebuffer( gl.FRAMEBUFFER, this.fbo );\\n                    if ( Notify.reportWebGLError === true ) {\\n                        status = gl.checkFramebufferStatus( gl.FRAMEBUFFER );\\n                        if ( status !== 0x8CD5 ) {\\n                            this._reportFrameBufferError( status );\\n                        }\\n                    }\\n                }\\n            } else {\\n                gl.bindFramebuffer( gl.FRAMEBUFFER, null );\\n            }\\n        }\\n    } );\\n\\n    return FrameBufferObject;\\n} );\\n\\n//# sourceURL=/osg/FrameBufferObject.js\");\n\n",
    "eval(\"define( \\'osg/RenderStage\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/RenderBin\\',\\n    \\'osg/Camera\\',\\n    \\'osg/FrameBufferObject\\'\\n], function ( Notify, MACROUTILS, RenderBin, Camera, FrameBufferObject ) {\\n\\n    /**\\n     * From OpenSceneGraph http://www.openscenegraph.org\\n     * RenderStage base class. Used for encapsulate a complete stage in\\n     * rendering - setting up of viewport, the projection and model\\n     * matrices and rendering the RenderBin\\'s enclosed with this RenderStage.\\n     * RenderStage also has a dependency list of other RenderStages, each\\n     * of which must be called before the rendering of this stage.  These\\n     * \\'pre\\' rendering stages are used for advanced rendering techniques\\n     * like multistage pixel shading or impostors.\\n     */\\n    var RenderStage = function () {\\n        RenderBin.call( this );\\n        this.positionedAttribute = [];\\n        this.clearDepth = 1.0;\\n        this.clearColor = [ 0.0, 0.0, 0.0, 1.0 ];\\n        /*jshint bitwise: false */\\n        this.clearMask = Camera.COLOR_BUFFER_BIT | Camera.DEPTH_BUFFER_BIT;\\n        /*jshint bitwise: true */\\n        this.camera = undefined;\\n        this.viewport = undefined;\\n        this.preRenderList = [];\\n        this.postRenderList = [];\\n        this._renderStage = this;\\n    };\\n    RenderStage.prototype = MACROUTILS.objectInehrit( RenderBin.prototype, {\\n        reset: function () {\\n            RenderBin.prototype.reset.call( this );\\n            this.preRenderList.length = 0;\\n            this.postRenderList.length = 0;\\n        },\\n        setClearDepth: function ( depth ) {\\n            this.clearDepth = depth;\\n        },\\n        getClearDepth: function () {\\n            return this.clearDepth;\\n        },\\n        setClearColor: function ( color ) {\\n            this.clearColor = color;\\n        },\\n        getClearColor: function () {\\n            return this.clearColor;\\n        },\\n        setClearMask: function ( mask ) {\\n            this.clearMask = mask;\\n        },\\n        getClearMask: function () {\\n            return this.clearMask;\\n        },\\n        setViewport: function ( vp ) {\\n            this.viewport = vp;\\n        },\\n        getViewport: function () {\\n            return this.viewport;\\n        },\\n        setCamera: function ( camera ) {\\n            this.camera = camera;\\n        },\\n        addPreRenderStage: function ( rs, order ) {\\n            for ( var i = 0, l = this.preRenderList.length; i < l; i++ ) {\\n                var render = this.preRenderList[ i ];\\n                if ( order < render.order ) {\\n                    break;\\n                }\\n            }\\n            if ( i < this.preRenderList.length ) {\\n                this.preRenderList = this.preRenderList.splice( i, 0, {\\n                    \\'order\\': order,\\n                    \\'renderStage\\': rs\\n                } );\\n            } else {\\n                this.preRenderList.push( {\\n                    \\'order\\': order,\\n                    \\'renderStage\\': rs\\n                } );\\n            }\\n        },\\n        addPostRenderStage: function ( rs, order ) {\\n            for ( var i = 0, l = this.postRenderList.length; i < l; i++ ) {\\n                var render = this.postRenderList[ i ];\\n                if ( order < render.order ) {\\n                    break;\\n                }\\n            }\\n            if ( i < this.postRenderList.length ) {\\n                this.postRenderList = this.postRenderList.splice( i, 0, {\\n                    \\'order\\': order,\\n                    \\'renderStage\\': rs\\n                } );\\n            } else {\\n                this.postRenderList.push( {\\n                    \\'order\\': order,\\n                    \\'renderStage\\': rs\\n                } );\\n            }\\n        },\\n\\n        drawPreRenderStages: function ( state, previousRenderLeaf ) {\\n            var previous = previousRenderLeaf;\\n            for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {\\n                var sg = this.preRenderList[ i ].renderStage;\\n                previous = sg.draw( state, previous );\\n            }\\n            return previous;\\n        },\\n\\n        draw: function ( state, previousRenderLeaf ) {\\n            var previous = this.drawPreRenderStages( state, previousRenderLeaf );\\n            previous = this.drawImplementation( state, previous );\\n\\n            previous = this.drawPostRenderStages( state, previous );\\n            return previous;\\n        },\\n\\n        sort: function () {\\n            for ( var i = 0, l = this.preRenderList.length; i < l; ++i ) {\\n                this.preRenderList[ i ].renderStage.sort();\\n            }\\n\\n            RenderBin.prototype.sort.call( this );\\n\\n            for ( var j = 0, k = this.postRenderList.length; j < k; ++j ) {\\n                this.postRenderList[ j ].renderStage.sort();\\n            }\\n        },\\n\\n        drawPostRenderStages: function ( state, previousRenderLeaf ) {\\n            var previous = previousRenderLeaf;\\n            for ( var i = 0, l = this.postRenderList.length; i < l; ++i ) {\\n                var sg = this.postRenderList[ i ].renderStage;\\n                previous = sg.draw( state, previous );\\n            }\\n            return previous;\\n        },\\n\\n        applyCamera: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            if ( this.camera === undefined ) {\\n                gl.bindFramebuffer( gl.FRAMEBUFFER, null );\\n                return;\\n            }\\n            var viewport = this.camera.getViewport();\\n            var fbo = this.camera.frameBufferObject;\\n\\n            if ( !fbo ) {\\n                fbo = new FrameBufferObject();\\n                this.camera.frameBufferObject = fbo;\\n            }\\n\\n            if ( fbo.isDirty() ) {\\n                if ( this.camera.attachments !== undefined ) {\\n                    for ( var key in this.camera.attachments ) {\\n                        var a = this.camera.attachments[ key ];\\n                        var attach;\\n                        if ( a.texture === undefined ) { //renderbuffer\\n                            attach = {\\n                                attachment: key,\\n                                format: a.format,\\n                                width: viewport.width(),\\n                                height: viewport.height()\\n                            };\\n                        } else if ( a.texture !== undefined ) {\\n                            attach = {\\n                                attachment: key,\\n                                texture: a.texture,\\n                                level: a.level\\n                            };\\n                            if ( a.format ) {\\n                                attach.format = a.format;\\n                            }\\n                        }\\n                        fbo.setAttachment( attach );\\n                    }\\n                }\\n            }\\n            fbo.apply( state );\\n        },\\n\\n        drawImplementation: function ( state, previousRenderLeaf ) {\\n            var gl = state.getGraphicContext();\\n\\n            this.applyCamera( state );\\n\\n            if ( this.viewport === undefined ) {\\n                Notify.log( \\'RenderStage does not have a valid viewport\\' );\\n            }\\n\\n            state.applyAttribute( this.viewport );\\n\\n            /*jshint bitwise: false */\\n            if ( this.clearMask & gl.COLOR_BUFFER_BIT ) {\\n                gl.clearColor( this.clearColor[ 0 ], this.clearColor[ 1 ], this.clearColor[ 2 ], this.clearColor[ 3 ] );\\n            }\\n            if ( this.clearMask & gl.DEPTH_BUFFER_BIT ) {\\n                gl.depthMask( true );\\n                gl.clearDepth( this.clearDepth );\\n            }\\n            /*jshint bitwise: true */\\n\\n            gl.clear( this.clearMask );\\n\\n            if ( this.positionedAttribute ) {\\n                this.applyPositionedAttribute( state, this.positionedAttribute );\\n            }\\n\\n            var previous = RenderBin.prototype.drawImplementation.call( this, state, previousRenderLeaf );\\n\\n            return previous;\\n        }\\n    } );\\n\\n    return RenderStage;\\n} );\\n\\n//# sourceURL=/osg/RenderStage.js\");\n\n",
    "eval(\"/**\\n * @author Jordi Torres\\n */\\n\\n\\ndefine( \\'osg/Lod\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Node\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/BoundingSphere\\'\\n], function ( MACROUTILS, Node, NodeVisitor, Matrix, Vec3, BoundingSphere ) {\\n    /**\\n     *  Lod that can contains child node\\n     *  @class Lod\\n     */\\n    var Lod = function () {\\n        Node.call( this );\\n        this._radius = -1;\\n        this._range = [];\\n        this._rangeMode = Lod.DISTANCE_FROM_EYE_POINT;\\n        this._userDefinedCenter = [];\\n        this._centerMode = Lod.USE_BOUNDING_SPHERE_CENTER;\\n    };\\n\\n    Lod.DISTANCE_FROM_EYE_POINT = 0;\\n    Lod.PIXEL_SIZE_ON_SCREEN = 1;\\n\\n    Lod.USE_BOUNDING_SPHERE_CENTER = 0;\\n    Lod.USER_DEFINED_CENTER = 1;\\n    Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED = 2;\\n\\n    /** @lends Lod.prototype */\\n    Lod.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Node.prototype, {\\n        // Functions here\\n        getRadius: function () {\\n            return this._radius;\\n        },\\n\\n        /** Set the object-space reference radius of the volume enclosed by the LOD.\\n         * Used to determine the bounding sphere of the LOD in the absence of any children.*/\\n        setRadius: function ( radius ) {\\n            this._radius = radius;\\n        },\\n\\n        setCenter: function ( center ) {\\n            if ( this._centerMode !== Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED )\\n                this._centerMode = Lod.USER_DEFINED_CENTER;\\n            this._userDefinedCenter = center;\\n        },\\n\\n        getCenter: function () {\\n            if ( ( this._centerMode === Lod.USER_DEFINED_CENTER ) || ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED ) )\\n                return this._userDefinedCenter;\\n            else return this.getBound().center();\\n        },\\n\\n        setCenterMode: function ( centerMode ) {\\n            this._centerMode = centerMode;\\n        },\\n\\n        computeBound: function ( bsphere ) {\\n            if ( this._centerMode === Lod.USER_DEFINED_CENTER && this._radius >= 0.0)\\n            {\\n                bsphere.set( this._userDefinedCenter, this._radius);\\n                return bsphere;\\n            }\\n            else if ( this._centerMode === Lod.UNION_OF_BOUNDING_SPHERE_AND_USER_DEFINED && this._radius >= 0.0)\\n            {\\n                bsphere.set( this._userDefinedCenter, this._radius);\\n                var bs = new BoundingSphere();\\n                bsphere.expandBy( Node.prototype.computeBound.call( this, bs ) );\\n                return bsphere;\\n            }\\n            else\\n            {\\n                Node.prototype.computeBound.call( this, bsphere );\\n                return bsphere;\\n            }\\n        },\\n\\n        projectBoundingSphere: ( function () {\\n            // from http://www.iquilezles.org/www/articles/sphereproj/sphereproj.htm\\n            // Sample code at http://www.shadertoy.com/view/XdBGzd?\\n            var o = Vec3.create();\\n            return function ( sph, camMatrix, fle ) {\\n                Matrix.transformVec3( camMatrix, sph.center(), o );\\n                var r2 = sph.radius2();\\n                var z2 = o[ 2 ] * o[ 2 ];\\n                var l2 = Vec3.length2( o );\\n                var area = -Math.PI * fle * fle * r2 * Math.sqrt( Math.abs( ( l2 - r2 ) / ( r2 - z2 ) ) ) / ( r2 - z2 );\\n                return area;\\n            };\\n        } )(),\\n\\n        setRangeMode: function ( mode ) {\\n            //TODO: check if mode is correct\\n            this._rangeMode = mode;\\n        },\\n\\n        addChildNode: function ( node ) {\\n\\n            Node.prototype.addChild.call( this, node );\\n            if ( this.children.length > this._range.length ) {\\n                var r = [];\\n                var max = 0.0;\\n                if ( this._range.lenght > 0 )\\n                    max = this._range[ this._range.length - 1 ][ 1 ];\\n                r.push( [ max, max ] );\\n                this._range.push( r );\\n            }\\n            return true;\\n        },\\n\\n        addChild: function ( node, min, max ) {\\n            Node.prototype.addChild.call( this, node );\\n\\n            if ( this.children.length > this._range.length ) {\\n                var r = [];\\n                r.push( [ min, min ] );\\n                this._range.push( r );\\n            }\\n            this._range[ this.children.length - 1 ][ 0 ] = min;\\n            this._range[ this.children.length - 1 ][ 1 ] = max;\\n            return true;\\n        },\\n\\n        traverse: ( function () {\\n\\n            // avoid to generate variable on the heap to limit garbage collection\\n            // instead create variable and use the same each time\\n            var zeroVector = Vec3.create();\\n            var eye = Vec3.create();\\n            var viewModel = Matrix.create();\\n\\n            return function ( visitor ) {\\n                var traversalMode = visitor.traversalMode;\\n\\n                switch ( traversalMode ) {\\n\\n                case NodeVisitor.TRAVERSE_ALL_CHILDREN:\\n\\n                    for ( var index = 0; index < this.children.length; index++ ) {\\n                        this.children[ index ].accept( visitor );\\n                    }\\n                    break;\\n\\n                case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):\\n                    var requiredRange = 0;\\n                    var matrix = visitor.getCurrentModelviewMatrix();\\n                    Matrix.inverse( matrix, viewModel );\\n                    // Calculate distance from viewpoint\\n                    if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {\\n                        Matrix.transformVec3( viewModel, zeroVector, eye );\\n                        var d = Vec3.distance( eye, this.getBound().center() );\\n                        requiredRange = d;\\n                    } else {\\n                        // Let\\'s calculate pixels on screen\\n                        var projmatrix = visitor.getCurrentProjectionMatrix();\\n                        // focal lenght is the value stored in projmatrix[0]\\n                        requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );\\n                        // Multiply by a factor to get the real area value\\n                        requiredRange = ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25;\\n                    }\\n\\n                    var numChildren = this.children.length;\\n                    if ( this._range.length < numChildren ) numChildren = this._range.length;\\n\\n                    for ( var j = 0; j < numChildren; ++j ) {\\n                        if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {\\n                            this.children[ j ].accept( visitor );\\n                        }\\n                    }\\n                    break;\\n\\n                default:\\n                    break;\\n                }\\n            };\\n        } )()\\n\\n    } ), \\'osg\\', \\'Lod\\' );\\n\\n    MACROUTILS.setTypeID( Lod );\\n    return Lod;\\n} );\\n\\n//# sourceURL=/osg/Lod.js\");\n\n",
    "eval(\"define( \\'Q\\',[],function ( ) {\\n    if ( window.Q ) {\\n        return window.Q;\\n    }\\n    return window.require( \\'Q\\' );\\n} );\\n\\n//# sourceURL=/vendors/Q.js\");\n\n",
    "eval(\"/**\\n * @author Jordi Torres\\n */\\n\\n\\ndefine( \\'osg/PagedLOD\\',[\\n    \\'Q\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Lod\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Node\\',\\n    \\'osg/Geometry\\',\\n    \\'osg/Notify\\'\\n], function ( Q, MACROUTILS, Lod, NodeVisitor, Matrix, Vec3, Node, Geometry, Notify ) {\\n    /**\\n     *  PagedLOD that can contains paged child nodes\\n     *  @class PagedLod\\n     */\\n    var PagedLOD = function () {\\n        Lod.call( this );\\n        this._perRangeDataList = [];\\n        this._loading = false;\\n        this._expiryTime = 10.0;\\n        this._centerMode = Lod.USER_DEFINED_CENTER;\\n    };\\n\\n    /**\\n     *  PerRangeData utility structure to store per range values\\n     *  @class PerRangeData\\n     */\\n    var PerRangeData = function () {\\n        this.filename = \\'\\';\\n        this.function = undefined;\\n        this.loaded = false;\\n        this.timeStamp = 0.0;\\n        this.frameNumber = 0;\\n        this.frameNumberOfLastTraversal = 0;\\n    };\\n\\n    /** @lends PagedLOD.prototype */\\n    PagedLOD.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Lod.prototype, {\\n        // Functions here\\n        setRange: function ( childNo, min, max ) {\\n            if ( childNo >= this._range.length ) {\\n                var r = [];\\n                r.push( [ min, min ] );\\n                this._range.push( r );\\n            }\\n            this._range[ childNo ][ 0 ] = min;\\n            this._range[ childNo ][ 1 ] = max;\\n        },\\n\\n        setExpiryTime: function ( expiryTime ) {\\n            this._expiryTime = expiryTime;\\n        },\\n\\n        setFileName: function ( childNo, filename ) {\\n            // May we should expand the vector first?\\n            if ( childNo >= this._perRangeDataList.length ) {\\n                var rd = new PerRangeData();\\n                rd.filename = filename;\\n                this._perRangeDataList.push( rd );\\n            } else {\\n                this._perRangeDataList[ childNo ].filename = filename;\\n            }\\n        },\\n        setFunction: function ( childNo, func ) {\\n            if ( childNo >= this._perRangeDataList.length ) {\\n                var rd = new PerRangeData();\\n                rd.function = func;\\n                this._perRangeDataList.push( rd );\\n            } else {\\n                this._perRangeDataList[ childNo ].function = func;\\n            }\\n        },\\n\\n        addChild: function ( node, min, max ) {\\n            Lod.prototype.addChild.call( this, node, min, max );\\n            this._perRangeDataList.push( new PerRangeData() );\\n        },\\n\\n        addChildNode: function ( node ) {\\n            Lod.prototype.addChildNode.call( this, node );\\n            // this.perRangeDataList.push ( null );\\n        },\\n\\n        loadNode: function ( perRangeData, node ) {\\n            if ( perRangeData.function === undefined )\\n                this.loadNodeFromURL( perRangeData, node );\\n            else this.loadNodeFromFunction( perRangeData, node );\\n        },\\n\\n        loadNodeFromURL: function ( perRangeData, node ) {\\n            // TODO:\\n            // we should ask to the Cache if the data is in the IndexedDB first\\n            var ReaderParser = require( \\'osgDB/ReaderParser\\' );\\n            Notify.log( \\'loading \\' + perRangeData.filename );\\n            var req = new XMLHttpRequest();\\n            req.open( \\'GET\\', perRangeData.filename, true );\\n            req.onload = function ( aEvt ) {\\n                var promise = ReaderParser.parseSceneGraph( JSON.parse( req.responseText ) );\\n                Q.when( promise ).then( function ( child ) {\\n                    node.addChildNode( child );\\n                } );\\n                Notify.log( \\'success \\' + perRangeData.filename, aEvt );\\n            };\\n\\n            req.onerror = function ( aEvt ) {\\n                Notify.error( \\'error \\' + perRangeData.filename, aEvt );\\n            };\\n            req.send( null );\\n        },\\n\\n        loadNodeFromFunction: function ( perRangeData, node ) {\\n            // Need to call with this paged lod as parent\\n            Q.when( ( perRangeData.function )( this ) ).then( function ( child ) {\\n                node.addChildNode( child );\\n            } );\\n        },\\n\\n        removeExpiredChildren: function ( frameStamp, gl ) {\\n\\n            var ReleaseVisitor = function ( gl ) {\\n                NodeVisitor.call( this, NodeVisitor.TRAVERSE_ALL_CHILDREN );\\n                this.gl = gl;\\n            };\\n            ReleaseVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n                apply: function ( node ) {\\n                    if ( node instanceof Geometry ) {\\n                        node.releaseGLObjects( this.gl );\\n                    }\\n                    this.traverse( node );\\n                }\\n            } );\\n            if ( frameStamp.getFrameNumber() === 0 ) return;\\n            var numChildren = this.children.length;\\n            for ( var i = numChildren - 1; i > 0; i-- ) {\\n                //First children never expires, also children added with addChild method should not be deleted\\n                var timed = frameStamp.getSimulationTime() - this._perRangeDataList[ i ].timeStamp;\\n                if ( ( timed > this._expiryTime ) && ( this._perRangeDataList[ i ].filename.length > 0 ||\\n                                                    this._perRangeDataList[ i ].function !== undefined ) ){\\n                    if ( i === this.children.length - 1 ) {\\n                        this.children[ i ].accept( new ReleaseVisitor( gl ) );\\n                        this.removeChild( this.children[ i ] );\\n                        this._perRangeDataList[ i ].loaded = false;\\n                        numChildren--;\\n                    }\\n                } else {\\n                    return;\\n                }\\n            }\\n        },\\n\\n        traverse: ( function () {\\n\\n            // avoid to generate variable on the heap to limit garbage collection\\n            // instead create variable and use the same each time\\n            var zeroVector = Vec3.create();\\n            var eye = Vec3.create();\\n            var viewModel = Matrix.create();\\n            return function ( visitor ) {\\n                var traversalMode = visitor.traversalMode;\\n                var updateTimeStamp = false;\\n                if ( visitor.getVisitorType() === NodeVisitor.CULL_VISITOR ) {\\n                    updateTimeStamp = true;\\n                    //this._frameNumberOfLastTraversal = visitor.getFrameStamp().getFrameNumber();\\n                }\\n\\n                switch ( traversalMode ) {\\n\\n                case NodeVisitor.TRAVERSE_ALL_CHILDREN:\\n\\n                    for ( var index = 0; index < this.children.length; index++ ) {\\n                        this.children[ index ].accept( visitor );\\n                    }\\n                    break;\\n\\n                case ( NodeVisitor.TRAVERSE_ACTIVE_CHILDREN ):\\n                    var requiredRange = 0;\\n\\n                    // Calculate distance from viewpoint\\n                    var matrix = visitor.getCurrentModelviewMatrix();\\n                    Matrix.inverse( matrix, viewModel );\\n                    if ( this._rangeMode === Lod.DISTANCE_FROM_EYE_POINT ) {\\n                        Matrix.transformVec3( viewModel, zeroVector, eye );\\n                        var d = Vec3.distance( eye, this.getBound().center() );\\n                        requiredRange = d;\\n                    } else {\\n                        // Calculate pixels on screen\\n                        var projmatrix = visitor.getCurrentProjectionMatrix();\\n                        // focal lenght is the value stored in projmatrix[0] \\n                        requiredRange = this.projectBoundingSphere( this.getBound(), matrix, projmatrix[ 0 ] );\\n                        // Get the real area value\\n                        requiredRange = ( requiredRange * visitor.getViewport().width() * visitor.getViewport().width() ) * 0.25;\\n                        if ( requiredRange < 0 ) requiredRange = this._range[ this._range.length -1 ][ 0 ];\\n                    }\\n\\n                    var needToLoadChild = false;\\n                    var lastChildTraversed = -1;\\n                    for ( var j = 0; j < this._range.length; ++j ) {\\n                        if ( this._range[ j ][ 0 ] <= requiredRange && requiredRange < this._range[ j ][ 1 ] ) {\\n                            if ( j < this.children.length ) {\\n                                if ( updateTimeStamp ) {\\n                                    this._perRangeDataList[ j ].timeStamp = visitor.getFrameStamp().getSimulationTime();\\n                                    //this.perRangeDataList[j].frameNumber = visitor.getFrameStamp().getFrameNumber();\\n                                }\\n                                this.children[ j ].accept( visitor );\\n                                lastChildTraversed = j;\\n                            } else {\\n                                needToLoadChild = true;\\n                            }\\n                        }\\n                    }\\n                    if ( needToLoadChild ) {\\n                        var numChildren = this.children.length;\\n                        if ( numChildren > 0 && ( ( numChildren - 1 ) !== lastChildTraversed ) ) {\\n\\n                            if ( updateTimeStamp ) {\\n                                this._perRangeDataList[ numChildren - 1 ].timeStamp = visitor.getFrameStamp().getSimulationTime();\\n                                //this.perRangeDataList[numChildren -1].frameNumber = visitor.getFrameStamp().getFrameNumber();\\n                            }\\n\\n                            this.children[ numChildren - 1 ].accept( visitor );\\n                        }\\n                        // now request the loading of the next unloaded child.\\n                        if ( numChildren < this._range.length ) {\\n\\n                            // Here we should do the request\\n                            var group = visitor.nodePath[ visitor.nodePath.length - 1 ];\\n                            if ( this._perRangeDataList[ numChildren ].loaded === false ) {\\n                                this._perRangeDataList[ numChildren ].loaded = true;\\n                                this.loadNode( this._perRangeDataList[ numChildren ], group );\\n                            }\\n                        }\\n                    }\\n                    // Remove the expired childs if any\\n                    this.removeExpiredChildren( visitor.getFrameStamp(), visitor.getCurrentCamera().getGraphicContext() );\\n                    break;\\n\\n                default:\\n                    break;\\n                }\\n            };\\n        } )()\\n\\n\\n\\n    } ), \\'osg\\', \\'PagedLOD\\' );\\n\\n    MACROUTILS.setTypeID( PagedLOD );\\n    return PagedLOD;\\n} );\\n\\n//# sourceURL=/osg/PagedLOD.js\");\n\n",
    "eval(\"define( \\'osg/CullVisitor\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/CullSettings\\',\\n    \\'osg/CullStack\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/MatrixTransform\\',\\n    \\'osg/Projection\\',\\n    \\'osg/LightSource\\',\\n    \\'osg/Geometry\\',\\n    \\'osg/RenderStage\\',\\n    \\'osg/Node\\',\\n    \\'osg/Lod\\',\\n    \\'osg/PagedLOD\\',\\n    \\'osg/Camera\\',\\n    \\'osg/TransformEnums\\',\\n    \\'osg/Vec4\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/ComputeMatrixFromNodePath\\'\\n], function ( Notify, MACROUTILS, NodeVisitor, CullSettings, CullStack, Matrix, MatrixTransform, Projection, LightSource, Geometry, RenderStage, Node, Lod, PagedLOD, Camera, TransformEnums, Vec4, Vec3, ComputeMatrixFromNodePath ) {\\n\\n\\n    /**\\n     * CullVisitor traverse the tree and collect Matrix/State for the rendering traverse\\n     * @class CullVisitor\\n     */\\n    var CullVisitor = function () {\\n        NodeVisitor.call( this, NodeVisitor.TRAVERSE_ACTIVE_CHILDREN);\\n        CullSettings.call( this );\\n        CullStack.call( this );\\n\\n        this._rootStateGraph = undefined;\\n        this._currentStateGraph = undefined;\\n        this._currentRenderBin = undefined;\\n        this._currentRenderStage = undefined;\\n        this._rootRenderStage = undefined;\\n        this._frustum = [ Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create(), Vec4.create() ];\\n        this._computedNear = Number.POSITIVE_INFINITY;\\n        this._computedFar = Number.NEGATIVE_INFINITY;\\n        this._enableFrustumCulling = false;\\n        var lookVector = [ 0.0, 0.0, -1.0 ];\\n        this._camera = undefined;\\n        /*jshint bitwise: false */\\n        this._bbCornerFar = ( lookVector[ 0 ] >= 0 ? 1 : 0 ) | ( lookVector[ 1 ] >= 0 ? 2 : 0 ) | ( lookVector[ 2 ] >= 0 ? 4 : 0 );\\n        this._bbCornerNear = ( ~this._bbCornerFar ) & 7;\\n        /*jshint bitwise: true */\\n\\n\\n        // keep a matrix in memory to avoid to create matrix\\n        this._reserveMatrixStack = [\\n            []\\n        ];\\n        this._reserveMatrixStack.current = 0;\\n\\n        this._reserveLeafStack = [ {} ];\\n        this._reserveLeafStack.current = 0;\\n\\n        this._renderBinStack = [];\\n        this.visitorType = NodeVisitor.CULL_VISITOR;\\n    };\\n\\n    /** @lends CullVisitor.prototype */\\n    CullVisitor.prototype = MACROUTILS.objectInehrit( CullStack.prototype, MACROUTILS.objectInehrit( CullSettings.prototype, MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n        distance: function ( coord, matrix ) {\\n            return -( coord[ 0 ] * matrix[ 2 ] + coord[ 1 ] * matrix[ 6 ] + coord[ 2 ] * matrix[ 10 ] + matrix[ 14 ] );\\n        },\\n\\n        handleCullCallbacksAndTraverse: function ( node ) {\\n            var ccb = node.getCullCallback();\\n            if ( ccb ) {\\n                if ( !ccb.cull( node, this ) ) {\\n                    return;\\n                }\\n            }\\n            this.traverse( node );\\n        },\\n        setCamera: function(camera){\\n            this._camera = camera;\\n        },\\n        getCurrentCamera: function (){\\n            return this._camera;\\n        },\\n        updateCalculatedNearFar: function ( matrix, drawable ) {\\n\\n            var bb = drawable.getBoundingBox();\\n            var dNear, dFar;\\n\\n            // efficient computation of near and far, only taking into account the nearest and furthest\\n            // corners of the bounding box.\\n            dNear = this.distance( bb.corner( this._bbCornerNear ), matrix );\\n            dFar = this.distance( bb.corner( this._bbCornerFar ), matrix );\\n\\n            if ( dNear > dFar ) {\\n                var tmp = dNear;\\n                dNear = dFar;\\n                dFar = tmp;\\n            }\\n\\n            if ( dFar < 0.0 ) {\\n                // whole object behind the eye point so discard\\n                return false;\\n            }\\n\\n            if ( dNear < this._computedNear ) {\\n                this._computedNear = dNear;\\n            }\\n\\n            if ( dFar > this._computedFar ) {\\n                this._computedFar = dFar;\\n            }\\n\\n            return true;\\n        },\\n\\n        clampProjectionMatrix: function ( projection, znear, zfar, nearFarRatio, resultNearFar ) {\\n            var epsilon = 1e-6;\\n            if ( zfar < znear - epsilon ) {\\n                Notify.log( \\'clampProjectionMatrix not applied, invalid depth range, znear = \\' + znear + \\'  zfar = \\' + zfar );\\n                return false;\\n            }\\n\\n            var desiredZnear, desiredZfar;\\n            if ( zfar < znear + epsilon ) {\\n                // znear and zfar are too close together and could cause divide by zero problems\\n                // late on in the clamping code, so move the znear and zfar apart.\\n                var average = ( znear + zfar ) * 0.5;\\n                znear = average - epsilon;\\n                zfar = average + epsilon;\\n                // OSG_INFO << \\'_clampProjectionMatrix widening znear and zfar to \\'<<znear<<\\' \\'<<zfar<<std::endl;\\n            }\\n\\n            if ( Math.abs( Matrix.get( projection, 0, 3 ) ) < epsilon &&\\n                Math.abs( Matrix.get( projection, 1, 3 ) ) < epsilon &&\\n                Math.abs( Matrix.get( projection, 2, 3 ) ) < epsilon ) {\\n                // OSG_INFO << \\'Orthographic matrix before clamping\\'<<projection<<std::endl;\\n\\n                var deltaSpan = ( zfar - znear ) * 0.02;\\n                if ( deltaSpan < 1.0 ) {\\n                    deltaSpan = 1.0;\\n                }\\n                desiredZnear = znear - deltaSpan;\\n                desiredZfar = zfar + deltaSpan;\\n\\n                // assign the clamped values back to the computed values.\\n                znear = desiredZnear;\\n                zfar = desiredZfar;\\n\\n                Matrix.set( projection, 2, 2, -2.0 / ( desiredZfar - desiredZnear ) );\\n                Matrix.set( projection, 3, 2, -( desiredZfar + desiredZnear ) / ( desiredZfar - desiredZnear ) );\\n\\n                // OSG_INFO << \\'Orthographic matrix after clamping \\'<<projection<<std::endl;\\n            } else {\\n\\n                // OSG_INFO << \\'Persepective matrix before clamping\\'<<projection<<std::endl;\\n                //std::cout << \\'_computed_znear\\'<<_computed_znear<<std::endl;\\n                //std::cout << \\'_computed_zfar\\'<<_computed_zfar<<std::endl;\\n\\n                var zfarPushRatio = 1.02;\\n                var znearPullRatio = 0.98;\\n\\n                //znearPullRatio = 0.99;\\n\\n                desiredZnear = znear * znearPullRatio;\\n                desiredZfar = zfar * zfarPushRatio;\\n\\n                // near plane clamping.\\n                var minNearPlane = zfar * nearFarRatio;\\n                if ( desiredZnear < minNearPlane ) {\\n                    desiredZnear = minNearPlane;\\n                }\\n\\n                // assign the clamped values back to the computed values.\\n                znear = desiredZnear;\\n                zfar = desiredZfar;\\n\\n                var m22 = Matrix.get( projection, 2, 2 );\\n                var m32 = Matrix.get( projection, 3, 2 );\\n                var m23 = Matrix.get( projection, 2, 3 );\\n                var m33 = Matrix.get( projection, 3, 3 );\\n                var transNearPlane = ( -desiredZnear * m22 + m32 ) / ( -desiredZnear * m23 + m33 );\\n                var transFarPlane = ( -desiredZfar * m22 + m32 ) / ( -desiredZfar * m23 + m33 );\\n\\n                var ratio = Math.abs( 2.0 / ( transNearPlane - transFarPlane ) );\\n                var center = -( transNearPlane + transFarPlane ) / 2.0;\\n\\n                var matrix = [ 1.0, 0.0, 0.0, 0.0,\\n                    0.0, 1.0, 0.0, 0.0,\\n                    0.0, 0.0, ratio, 0.0,\\n                    0.0, 0.0, center * ratio, 1.0\\n                ];\\n                Matrix.postMult( matrix, projection );\\n                // OSG_INFO << \\'Persepective matrix after clamping\\'<<projection<<std::endl;\\n            }\\n            if ( resultNearFar !== undefined ) {\\n                resultNearFar[ 0 ] = znear;\\n                resultNearFar[ 1 ] = zfar;\\n            }\\n            return true;\\n        },\\n\\n        setStateGraph: function ( sg ) {\\n            this._rootStateGraph = sg;\\n            this._currentStateGraph = sg;\\n        },\\n        setRenderStage: function ( rg ) {\\n            this._rootRenderStage = rg;\\n            this._currentRenderBin = rg;\\n        },\\n        reset: function () {\\n            //this._modelviewMatrixStack.length = 0;\\n            this._modelviewMatrixStack.splice( 0, this._modelviewMatrixStack.length );\\n            //this._projectionMatrixStack.length = 0;\\n            this._projectionMatrixStack.splice( 0, this._projectionMatrixStack.length );\\n            this._reserveMatrixStack.current = 0;\\n            this._reserveLeafStack.current = 0;\\n\\n            this._computedNear = Number.POSITIVE_INFINITY;\\n            this._computedFar = Number.NEGATIVE_INFINITY;\\n        },\\n        getCurrentRenderBin: function () {\\n            return this._currentRenderBin;\\n        },\\n        setCurrentRenderBin: function ( rb ) {\\n            this._currentRenderBin = rb;\\n        },\\n        addPositionedAttribute: function ( attribute, matrix ) {\\n            if ( matrix === undefined )\\n                matrix = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n            this._currentRenderBin.getStage().positionedAttribute.push( [ matrix, attribute ] );\\n        },\\n\\n        pushStateSet: function ( stateset ) {\\n            this._currentStateGraph = this._currentStateGraph.findOrInsert( stateset );\\n            if ( stateset.getBinName() !== undefined ) {\\n                var renderBinStack = this._renderBinStack;\\n                var currentRenderBin = this._currentRenderBin;\\n                renderBinStack.push( currentRenderBin );\\n                this._currentRenderBin = currentRenderBin.getStage().findOrInsert( stateset.getBinNumber(), stateset.getBinName() );\\n            }\\n        },\\n\\n        /** Pop the top state set and hence associated state group.\\n         * Move the current state group to the parent of the popped\\n         * state group.\\n         */\\n        popStateSet: function () {\\n            var currentStateGraph = this._currentStateGraph;\\n            var stateset = currentStateGraph.getStateSet();\\n            this._currentStateGraph = currentStateGraph.parent;\\n            if ( stateset.getBinName() !== undefined ) {\\n                var renderBinStack = this._renderBinStack;\\n                if ( renderBinStack.length === 0 ) {\\n                    this._currentRenderBin = this._currentRenderBin.getStage();\\n                } else {\\n                    this._currentRenderBin = renderBinStack.pop();\\n                }\\n            }\\n        },\\n\\n        popProjectionMatrix: function () {\\n            if ( this._computeNearFar === true && this._computedFar >= this._computedNear ) {\\n                var m = this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\\n                this.clampProjectionMatrix( m, this._computedNear, this._computedFar, this._nearFarRatio );\\n            }\\n            CullStack.prototype.popProjectionMatrix.call( this );\\n        },\\n\\n        apply: function ( node ) {\\n            this[ node.typeID ].call( this, node );\\n        },\\n\\n        _getReservedMatrix: function () {\\n            var m = this._reserveMatrixStack[ this._reserveMatrixStack.current++ ];\\n            if ( this._reserveMatrixStack.current === this._reserveMatrixStack.length ) {\\n                this._reserveMatrixStack.push( Matrix.create() );\\n            }\\n            return m;\\n        },\\n        _getReservedLeaf: function () {\\n            var l = this._reserveLeafStack[ this._reserveLeafStack.current++ ];\\n            if ( this._reserveLeafStack.current === this._reserveLeafStack.length ) {\\n                this._reserveLeafStack.push( {} );\\n            }\\n            return l;\\n        },\\n\\n        setEnableFrustumCulling: function ( value ) {\\n            this._enableFrustumCulling = value;\\n        },\\n\\n        getFrustumPlanes: ( function () {\\n\\n            var right = Vec4.create();\\n            var left = Vec4.create();\\n            var bottom = Vec4.create();\\n            var top = Vec4.create();\\n            var far = Vec4.create();\\n            var near = Vec4.create();\\n\\n            return function ( matrix, result, withNearFar ) {\\n                if ( withNearFar === undefined )\\n                    withNearFar = false;\\n                // Right clipping plane.\\n                right[ 0 ] = matrix[ 3 ] - matrix[ 0 ];\\n                right[ 1 ] = matrix[ 7 ] - matrix[ 4 ];\\n                right[ 2 ] = matrix[ 11 ] - matrix[ 8 ];\\n                right[ 3 ] = matrix[ 15 ] - matrix[ 12 ];\\n                result[ 0 ] = right;\\n                // Left clipping plane.\\n                left[ 0 ] = matrix[ 3 ] + matrix[ 0 ];\\n                left[ 1 ] = matrix[ 7 ] + matrix[ 4 ];\\n                left[ 2 ] = matrix[ 11 ] + matrix[ 8 ];\\n                left[ 3 ] = matrix[ 15 ] + matrix[ 12 ];\\n                result[ 1 ] = left;\\n                // Bottom clipping plane.\\n                bottom[ 0 ] = matrix[ 3 ] + matrix[ 1 ];\\n                bottom[ 1 ] = matrix[ 7 ] + matrix[ 5 ];\\n                bottom[ 2 ] = matrix[ 11 ] + matrix[ 9 ];\\n                bottom[ 3 ] = matrix[ 15 ] + matrix[ 13 ];\\n                result[ 2 ] = bottom;\\n                // Top clipping plane.\\n                top[ 0 ] = matrix[ 3 ] - matrix[ 1 ];\\n                top[ 1 ] = matrix[ 7 ] - matrix[ 5 ];\\n                top[ 2 ] = matrix[ 11 ] - matrix[ 9 ];\\n                top[ 3 ] = matrix[ 15 ] - matrix[ 13 ];\\n                result[ 3 ] = top;\\n\\n                if( withNearFar ) {\\n                    // Far clipping plane.\\n                    far[ 0 ] = matrix[ 3 ] - matrix[ 2 ];\\n                    far[ 1 ] = matrix[ 7 ] - matrix[ 6 ];\\n                    far[ 2 ] = matrix[ 11 ] - matrix[ 10 ];\\n                    far[ 3 ] = matrix[ 15 ] - matrix[ 14 ];\\n                    result[ 4 ] = far;\\n                    // Near clipping plane.\\n                    near[ 0 ] = matrix[ 3 ] + matrix[ 2 ];\\n                    near[ 1 ] = matrix[ 7 ] + matrix[ 6 ];\\n                    near[ 2 ] = matrix[ 11 ] + matrix[ 10 ];\\n                    near[ 3 ] = matrix[ 15 ] + matrix[ 14 ];\\n                    result[ 5 ] = near;\\n                }\\n                //Normalize the planes\\n                for ( var i = 0, j = result.length; i < j; i++ ) {\\n                    var norm = result[ i ][ 0 ] * result[ i ][ 0 ] + result[ i ][ 1 ] * result[ i ][ 1 ] + result[ i ][ 2 ] * result[ i ][ 2 ];\\n                    var inv = 1.0 / Math.sqrt( norm );\\n                    result[ i ][ 0 ] = result[ i ][ 0 ] * inv;\\n                    result[ i ][ 1 ] = result[ i ][ 1 ] * inv;\\n                    result[ i ][ 2 ] = result[ i ][ 2 ] * inv;\\n                    result[ i ][ 3 ] = result[ i ][ 3 ] * inv;\\n                }\\n            };\\n        } )(),\\n\\n        isCulled: ( function () {\\n            var position = Vec3.create();\\n\\n            return function ( node ) {\\n                var pos = node.getBound().center();\\n                Vec3.copy( pos, position );\\n                var radius = - node.getBound().radius();\\n                var d;\\n                var m = ComputeMatrixFromNodePath.computeLocalToWorld( this.nodePath );\\n                Matrix.transformVec3( m, position, position);\\n\\n                for ( var i = 0, j = this._frustum.length; i < j; i++ ) {\\n                    d = this._frustum[ i ][ 0 ] * position[ 0 ] + this._frustum[ i ][ 1 ] * position[ 1 ] + this._frustum[ i ][ 2 ] * position[ 2 ] + this._frustum[ i ][ 3 ];\\n                    if ( d <= radius )\\n                    {\\n                        return true;\\n                    }\\n                }\\n                return false;\\n        };\\n    } )()\\n    } ) ) );\\n\\n    CullVisitor.prototype[ Camera.typeID ] = function ( camera ) {\\n\\n        var stateset = camera.getStateSet();\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n\\n        if ( camera.light ) {\\n            this.addPositionedAttribute( camera.light );\\n        }\\n\\n        // never used\\n        //var originalModelView = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n\\n        var modelview = this._getReservedMatrix();\\n        var projection = this._getReservedMatrix();\\n\\n        if ( camera.getReferenceFrame() === TransformEnums.RELATIVE_RF ) {\\n            var lastProjectionMatrix = this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\\n            Matrix.mult( lastProjectionMatrix, camera.getProjectionMatrix(), projection );\\n            var lastViewMatrix = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n            Matrix.mult( lastViewMatrix, camera.getViewMatrix(), modelview );\\n        } else {\\n            // absolute\\n            Matrix.copy( camera.getViewMatrix(), modelview );\\n            Matrix.copy( camera.getProjectionMatrix(), projection );\\n        }\\n        this.pushProjectionMatrix( projection );\\n        this.pushModelviewMatrix( modelview );\\n\\n        if ( camera.getViewport() ) {\\n            this.pushViewport( camera.getViewport() );\\n        }\\n\\n        // save current state of the camera\\n        var previousZnear = this._computedNear;\\n        var previousZfar = this._computedFar;\\n        var previousCullsettings = new CullSettings();\\n        previousCullsettings.setCullSettings( this );\\n\\n        this._computedNear = Number.POSITIVE_INFINITY;\\n        this._computedFar = Number.NEGATIVE_INFINITY;\\n        this.setCullSettings( camera );\\n\\n        // nested camera\\n        if ( camera.getRenderOrder() === Camera.NESTED_RENDER ) {\\n\\n            this.handleCullCallbacksAndTraverse( camera );\\n\\n        } else {\\n            // not tested\\n\\n            var previousStage = this.getCurrentRenderBin().getStage();\\n\\n            // use render to texture stage\\n            var rtts = new RenderStage();\\n            rtts.setCamera( camera );\\n            rtts.setClearDepth( camera.getClearDepth() );\\n            rtts.setClearColor( camera.getClearColor() );\\n\\n            rtts.setClearMask( camera.getClearMask() );\\n\\n            var vp;\\n            if ( camera.getViewport() === undefined ) {\\n                vp = previousStage.getViewport();\\n            } else {\\n                vp = camera.getViewport();\\n            }\\n            rtts.setViewport( vp );\\n\\n            // skip positional state for now\\n            // ...\\n\\n            var previousRenderBin = this.getCurrentRenderBin();\\n\\n            this.setCurrentRenderBin( rtts );\\n\\n            this.handleCullCallbacksAndTraverse( camera );\\n\\n            this.setCurrentRenderBin( previousRenderBin );\\n\\n            if ( camera.getRenderOrder() === Camera.PRE_RENDER ) {\\n                this.getCurrentRenderBin().getStage().addPreRenderStage( rtts, camera.renderOrderNum );\\n            } else {\\n                this.getCurrentRenderBin().getStage().addPostRenderStage( rtts, camera.renderOrderNum );\\n            }\\n        }\\n\\n        this.popModelviewMatrix();\\n        this.popProjectionMatrix();\\n\\n        if ( camera.getViewport() ) {\\n            this.popViewport();\\n        }\\n\\n        // restore previous state of the camera\\n        this.setCullSettings( previousCullsettings );\\n        this._computedNear = previousZnear;\\n        this._computedFar = previousZfar;\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n\\n    };\\n\\n\\n    CullVisitor.prototype[ MatrixTransform.typeID ] = function ( node ) {\\n        var matrix = this._getReservedMatrix();\\n\\n        if ( node.getReferenceFrame() === TransformEnums.RELATIVE_RF ) {\\n            var lastMatrixStack = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n            Matrix.mult( lastMatrixStack, node.getMatrix(), matrix );\\n        } else {\\n            // absolute\\n            Matrix.copy( node.getMatrix(), matrix );\\n        }\\n        this.pushModelviewMatrix( matrix );\\n\\n\\n        var stateset = node.getStateSet();\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n\\n        if ( node.light ) {\\n            this.addPositionedAttribute( node.light );\\n        }\\n\\n        this.handleCullCallbacksAndTraverse( node );\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n\\n        this.popModelviewMatrix();\\n\\n    };\\n\\n    CullVisitor.prototype[ Projection.typeID ] = function ( node ) {\\n        var lastMatrixStack = this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\\n        var matrix = this._getReservedMatrix();\\n        Matrix.mult( lastMatrixStack, node.getProjectionMatrix(), matrix );\\n        this.pushProjectionMatrix( matrix );\\n\\n        var stateset = node.getStateSet();\\n\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n\\n        this.handleCullCallbacksAndTraverse( node );\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n\\n        this.popProjectionMatrix();\\n    };\\n\\n    CullVisitor.prototype[ Node.typeID ] = function ( node ) {\\n\\n        // We need the frame stamp > 0 to do the frustum culling, otherwise the projection matrix is not correct\\n        if ( this._enableFrustumCulling === true && node.isCullingActive() && this.getFrameStamp().getFrameNumber() !== 0 && this.isCulled ( node ) ) return;\\n\\n        var stateset = node.getStateSet();\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n        if ( node.light ) {\\n            this.addPositionedAttribute( node.light );\\n        }\\n\\n        this.handleCullCallbacksAndTraverse( node );\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n    };\\n\\n    // same code like Node\\n    CullVisitor.prototype[ Lod.typeID ] = CullVisitor.prototype[ Node.typeID ];\\n\\n    // same code like Node\\n    CullVisitor.prototype[ PagedLOD.typeID ] = CullVisitor.prototype[ Node.typeID ];\\n\\n    CullVisitor.prototype[ LightSource.typeID ] = function ( node ) {\\n\\n        var stateset = node.getStateSet();\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n\\n        var light = node.getLight();\\n        if ( light ) {\\n            this.addPositionedAttribute( light );\\n        }\\n\\n        this.handleCullCallbacksAndTraverse( node );\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n    };\\n\\n    CullVisitor.prototype[ Geometry.typeID ] = function ( node ) {\\n        var modelview = this._modelviewMatrixStack[ this._modelviewMatrixStack.length - 1 ];\\n        var bb = node.getBoundingBox();\\n        if ( this._computeNearFar && bb.valid() ) {\\n            if ( !this.updateCalculatedNearFar( modelview, node ) ) {\\n                return;\\n            }\\n        }\\n\\n        var stateset = node.getStateSet();\\n        if ( stateset ) {\\n            this.pushStateSet( stateset );\\n        }\\n\\n        this.handleCullCallbacksAndTraverse( node );\\n\\n        var leafs = this._currentStateGraph.leafs;\\n        if ( leafs.length === 0 ) {\\n            this._currentRenderBin.addStateGraph( this._currentStateGraph );\\n        }\\n\\n        var leaf = this._getReservedLeaf();\\n        var depth = 0;\\n        if ( bb.valid() ) {\\n            depth = this.distance( bb.center(), modelview );\\n        }\\n        if ( isNaN( depth ) ) {\\n            Notify.warn( \\'warning geometry has a NaN depth, \\' + modelview + \\' center \\' + bb.center() );\\n        } else {\\n            //leaf.id = this._reserveLeafStack.current;\\n            leaf.parent = this._currentStateGraph;\\n            leaf.projection = this._projectionMatrixStack[ this._projectionMatrixStack.length - 1 ];\\n            leaf.geometry = node;\\n            leaf.modelview = modelview;\\n            leaf.depth = depth;\\n            leafs.push( leaf );\\n        }\\n\\n        if ( stateset ) {\\n            this.popStateSet();\\n        }\\n    };\\n\\n    return CullVisitor;\\n} );\\n\\n//# sourceURL=/osg/CullVisitor.js\");\n\n",
    "eval(\"define( \\'osg/Depth\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\'\\n], function ( MACROUTILS, StateAttribute ) {\\n\\n    var Depth = function ( func, near, far, writeMask ) {\\n        StateAttribute.call( this );\\n\\n        this._func = Depth.LESS;\\n        this._near = 0.0;\\n        this._far = 1.0;\\n        this._writeMask = true;\\n\\n        if ( func !== undefined ) {\\n            if ( typeof ( func ) === \\'string\\' ) {\\n                this._func = Depth[ func ];\\n            } else {\\n                this._func = func;\\n            }\\n        }\\n        if ( near !== undefined ) {\\n            this._near = near;\\n        }\\n        if ( far !== undefined ) {\\n            this._far = far;\\n        }\\n        if ( writeMask !== undefined ) {\\n            this._writeMask = writeMask;\\n        }\\n    };\\n\\n    Depth.DISABLE = 0x0000;\\n    Depth.NEVER = 0x0200;\\n    Depth.LESS = 0x0201;\\n    Depth.EQUAL = 0x0202;\\n    Depth.LEQUAL = 0x0203;\\n    Depth.GREATE = 0x0204;\\n    Depth.NOTEQU = 0x0205;\\n    Depth.GEQUAL = 0x0206;\\n    Depth.ALWAYS = 0x0207;\\n\\n    Depth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'Depth\\',\\n        cloneType: function () {\\n            return new Depth();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setRange: function ( near, far ) {\\n            this._near = near;\\n            this._far = far;\\n        },\\n        setWriteMask: function ( mask ) {\\n            this._writeMask = mask;\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            if ( this._func === 0 ) {\\n                gl.disable( gl.DEPTH_TEST );\\n            } else {\\n                gl.enable( gl.DEPTH_TEST );\\n                gl.depthFunc( this._func );\\n                gl.depthMask( this._writeMask );\\n                gl.depthRange( this._near, this._far );\\n            }\\n        }\\n    } ), \\'osg\\', \\'Depth\\' );\\n\\n    return Depth;\\n} );\\n\\n//# sourceURL=/osg/Depth.js\");\n\n",
    "eval(\"define( \\'osg/DrawArrayLengths\\',[\\n], function () {\\n\\n    /**\\n     * DrawArrayLengths manage rendering primitives\\n     * @class DrawArrayLengths\\n     */\\n    var DrawArrayLengths = function ( mode, first, array ) {\\n        this._mode = mode;\\n        this._first = first;\\n        this._arrayLengths = array.slice( 0 );\\n    };\\n\\n    /** @lends DrawArrayLengths.prototype */\\n    DrawArrayLengths.prototype = {\\n        draw: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            var mode = this._mode;\\n            var first = this._first;\\n            var array = this._arrayLengths;\\n            for ( var i = 0, l = array.length; i < l; i++ ) {\\n                var count = array[ i ];\\n                gl.drawArrays( mode, first, count );\\n                first += count;\\n            }\\n        },\\n        getMode: function () {\\n            return this._mode;\\n        },\\n        getNumIndices: function () {\\n            var count = 0;\\n            var array = this._arrayLengths;\\n            for ( var i = 0, l = array.length; i < l; i++ ) {\\n                count += array[ i ];\\n            }\\n            return count;\\n        },\\n        getArrayLengths: function () {\\n            return this._arrayLengths;\\n        },\\n        getFirst: function () {\\n            return this._first;\\n        },\\n        setFirst: function ( first ) {\\n            this._first = first;\\n        }\\n    };\\n\\n    return DrawArrayLengths;\\n} );\\n\\n//# sourceURL=/osg/DrawArrayLengths.js\");\n\n",
    "eval(\"define( \\'osg/PrimitiveSet\\',[], function () {\\n\\n    var PrimitiveSet = {};\\n    PrimitiveSet.POINTS = 0x0000;\\n    PrimitiveSet.LINES = 0x0001;\\n    PrimitiveSet.LINE_LOOP = 0x0002;\\n    PrimitiveSet.LINE_STRIP = 0x0003;\\n    PrimitiveSet.TRIANGLES = 0x0004;\\n    PrimitiveSet.TRIANGLE_STRIP = 0x0005;\\n    PrimitiveSet.TRIANGLE_FAN = 0x0006;\\n\\n    return PrimitiveSet;\\n} );\\n\\n//# sourceURL=/osg/PrimitiveSet.js\");\n\n",
    "eval(\"define( \\'osg/DrawArrays\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/PrimitiveSet\\'\\n], function ( Notify, PrimitiveSet ) {\\n\\n    /**\\n     * DrawArrays manage rendering primitives\\n     * @class DrawArrays\\n     */\\n    var DrawArrays = function ( mode, first, count ) {\\n        this.mode = mode;\\n        if ( mode !== undefined ) {\\n            if ( typeof ( mode ) === \\'string\\' ) {\\n                mode = PrimitiveSet[ mode ];\\n            }\\n            this.mode = mode;\\n        }\\n        this.first = first;\\n        this.count = count;\\n    };\\n\\n    /** @lends DrawArrays.prototype */\\n    DrawArrays.prototype = {\\n        draw: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            gl.drawArrays( this.mode, this.first, this.count );\\n        },\\n        getMode: function () {\\n            return this.mode;\\n        },\\n        getCount: function () {\\n            return this.count;\\n        },\\n        getFirst: function () {\\n            return this.first;\\n        }\\n    };\\n    DrawArrays.create = function ( mode, first, count ) {\\n        Notify.log( \\'DrawArrays.create is deprecated, use new DrawArrays with same arguments\\' );\\n        var d = new DrawArrays( mode, first, count );\\n        return d;\\n    };\\n\\n    return DrawArrays;\\n} );\\n//# sourceURL=/osg/DrawArrays.js\");\n\n",
    "eval(\"define( \\'osg/DrawElements\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/PrimitiveSet\\'\\n], function ( Notify, PrimitiveSet ) {\\n\\n    /**\\n     * DrawElements manage rendering of indexed primitives\\n     * @class DrawElements\\n     */\\n    var DrawElements = function ( mode, indices ) {\\n        this.mode = PrimitiveSet.POINTS;\\n        if ( mode !== undefined ) {\\n            if ( typeof ( mode ) === \\'string\\' ) {\\n                mode = PrimitiveSet[ mode ];\\n            }\\n            this.mode = mode;\\n        }\\n        this.count = 0;\\n        this.offset = 0;\\n        this.indices = indices;\\n        if ( indices !== undefined ) {\\n            this.setIndices( indices );\\n        }\\n    };\\n\\n    /** @lends DrawElements.prototype */\\n    DrawElements.prototype = {\\n        getMode: function () {\\n            return this.mode;\\n        },\\n        draw: function ( state ) {\\n            state.setIndexArray( this.indices );\\n            var gl = state.getGraphicContext();\\n            gl.drawElements( this.mode, this.count, gl.UNSIGNED_SHORT, this.offset );\\n        },\\n        setIndices: function ( indices ) {\\n            this.indices = indices;\\n            this.count = indices.getElements().length;\\n        },\\n        getIndices: function () {\\n            return this.indices;\\n        },\\n        setFirst: function ( val ) {\\n            this.offset = val;\\n        },\\n        getFirst: function () {\\n            return this.offset;\\n        },\\n        setCount: function ( val ) {\\n            this.count = val;\\n        },\\n        getCount: function () {\\n            return this.count;\\n        }\\n\\n    };\\n\\n    DrawElements.create = function ( mode, indices ) {\\n        Notify.log( \\'DrawElements.create is deprecated, use new DrawElements with same arguments\\' );\\n        return new DrawElements( mode, indices );\\n    };\\n\\n    return DrawElements;\\n} );\\n//# sourceURL=/osg/DrawElements.js\");\n\n",
    "eval(\"define( \\'osg/EllipsoidModel\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\'\\n], function ( Notify, Matrix, Vec3 ) {\\n\\n    var EllipsoidModel = function () {\\n        this._radiusEquator = EllipsoidModel.WGS_84_RADIUS_EQUATOR;\\n        this._radiusPolar = EllipsoidModel.WGS_84_RADIUS_POLAR;\\n        this.computeCoefficients();\\n    };\\n\\n    EllipsoidModel.WGS_84_RADIUS_EQUATOR = 6378137.0;\\n    EllipsoidModel.WGS_84_RADIUS_POLAR = 6356752.3142;\\n\\n    EllipsoidModel.prototype = {\\n        setRadiusEquator: function ( radius ) {\\n            this._radiusEquator = radius;\\n            this.computeCoefficients();\\n        },\\n        getRadiusEquator: function () {\\n            return this._radiusEquator;\\n        },\\n        setRadiusPolar: function ( radius ) {\\n            this._radiusPolar = radius;\\n            this.computeCoefficients();\\n        },\\n        getRadiusPolar: function () {\\n            return this._radiusPolar;\\n        },\\n        convertLatLongHeightToXYZ: function ( latitude, longitude, height, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'deprecated, use this signature convertLatLongHeightToXYZ( latitude, longitude, height, result )\\' );\\n                result = [ 0.0, 0.0, 0.0 ];\\n            }\\n            var sinLatitude = Math.sin( latitude );\\n            var cosLatitude = Math.cos( latitude );\\n            var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );\\n            var X = ( N + height ) * cosLatitude * Math.cos( longitude );\\n            var Y = ( N + height ) * cosLatitude * Math.sin( longitude );\\n            var Z = ( N * ( 1.0 - this._eccentricitySquared ) + height ) * sinLatitude;\\n            result[ 0 ] = X;\\n            result[ 1 ] = Y;\\n            result[ 2 ] = Z;\\n            return result;\\n        },\\n        convertXYZToLatLongHeight: function ( X, Y, Z, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'deprecated, use this signature convertXYZToLatLongHeight( X,  Y,  Z , result)\\' );\\n                result = [ 0.0, 0.0, 0.0 ];\\n            }\\n            // http://www.colorado.edu/geography/gcraft/notes/datum/gif/xyzllh.gif\\n            var p = Math.sqrt( X * X + Y * Y );\\n            var theta = Math.atan2( Z * this._radiusEquator, ( p * this._radiusPolar ) );\\n            var eDashSquared = ( this._radiusEquator * this._radiusEquator - this._radiusPolar * this._radiusPolar ) / ( this._radiusPolar * this._radiusPolar );\\n\\n            var sinTheta = Math.sin( theta );\\n            var cosTheta = Math.cos( theta );\\n\\n            var latitude = Math.atan( ( Z + eDashSquared * this._radiusPolar * sinTheta * sinTheta * sinTheta ) /\\n                ( p - this._eccentricitySquared * this._radiusEquator * cosTheta * cosTheta * cosTheta ) );\\n            var longitude = Math.atan2( Y, X );\\n\\n            var sinLatitude = Math.sin( latitude );\\n            var N = this._radiusEquator / Math.sqrt( 1.0 - this._eccentricitySquared * sinLatitude * sinLatitude );\\n\\n            var cosLat = Math.cos( latitude );\\n            if ( cosLat === 0) cosLat = 1;\\n            var height = p / cosLat - N;\\n            result[ 0 ] = latitude;\\n            result[ 1 ] = longitude;\\n            result[ 2 ] = height;\\n            return result;\\n        },\\n        computeLocalUpVector: function ( X, Y, Z ) {\\n            // Note latitude is angle between normal to ellipsoid surface and XY-plane\\n            var latitude, longitude, altitude;\\n            var coord = this.convertXYZToLatLongHeight( X, Y, Z, latitude, longitude, altitude );\\n            latitude = coord[ 0 ];\\n            longitude = coord[ 1 ];\\n            altitude = coord[ 2 ];\\n\\n            // Compute up vector\\n            return [ Math.cos( longitude ) * Math.cos( latitude ),\\n                Math.sin( longitude ) * Math.cos( latitude ),\\n                Math.sin( latitude ) ];\\n        },\\n        isWGS84: function () {\\n            return ( this._radiusEquator === EllipsoidModel.WGS_84_RADIUS_EQUATOR && this._radiusPolar === EllipsoidModel.WGS_84_RADIUS_POLAR );\\n        },\\n\\n        computeCoefficients: function () {\\n            var flattening = ( this._radiusEquator - this._radiusPolar ) / this._radiusEquator;\\n            this._eccentricitySquared = 2.0 * flattening - flattening * flattening;\\n        },\\n        computeLocalToWorldTransformFromLatLongHeight: function ( latitude, longitude, height, result ) {\\n            if ( result === undefined ) {\\n                Notify.warn( \\'deprecated, use this signature computeLocalToWorldTransformFromLatLongHeight(latitude, longitude, height, result)\\' );\\n                result = new Array( 16 );\\n            }\\n            var pos = this.convertLatLongHeightToXYZ( latitude, longitude, height, result );\\n            Matrix.makeTranslate( pos[ 0 ], pos[ 1 ], pos[ 2 ], result );\\n            this.computeCoordinateFrame( latitude, longitude, result );\\n            return result;\\n        },\\n        computeLocalToWorldTransformFromXYZ: function ( X, Y, Z ) {\\n            var lla = this.convertXYZToLatLongHeight( X, Y, Z );\\n            var m = Matrix.makeTranslate( X, Y, Z, Matrix.create() );\\n            this.computeCoordinateFrame( lla[ 0 ], lla[ 1 ], m );\\n            return m;\\n        },\\n        computeCoordinateFrame: ( function () {\\n            var up = [ 0.0, 0.0, 0.0 ];\\n            var east = [ 0.0, 0.0, 0.0 ];\\n            var north = [ 0.0, 0.0, 0.0 ];\\n            return function ( latitude, longitude, localToWorld ) {\\n                // Compute up vector\\n                up[ 0 ] = Math.cos( longitude ) * Math.cos( latitude );\\n                up[ 1 ] = Math.sin( longitude ) * Math.cos( latitude );\\n                up[ 2 ] = Math.sin( latitude );\\n\\n                // Compute east vector\\n                east[ 0 ] = -Math.sin( longitude );\\n                east[ 1 ] = -Math.cos( longitude );\\n\\n                // Compute north vector = outer product up x east\\n                Vec3.cross( up, east, north );\\n\\n                // set matrix\\n                Matrix.set( localToWorld, 0, 0, east[ 0 ] );\\n                Matrix.set( localToWorld, 0, 1, east[ 1 ] );\\n                Matrix.set( localToWorld, 0, 2, east[ 2 ] );\\n\\n                Matrix.set( localToWorld, 1, 0, north[ 0 ] );\\n                Matrix.set( localToWorld, 1, 1, north[ 1 ] );\\n                Matrix.set( localToWorld, 1, 2, north[ 2 ] );\\n\\n                Matrix.set( localToWorld, 2, 0, up[ 0 ] );\\n                Matrix.set( localToWorld, 2, 1, up[ 1 ] );\\n                Matrix.set( localToWorld, 2, 2, up[ 2 ] );\\n            };\\n        } )()\\n    };\\n\\n    return EllipsoidModel;\\n} );\\n\\n//# sourceURL=/osg/EllipsoidModel.js\");\n\n",
    "eval(\"define( \\'osg/Image\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( MACROUTILS, Object ) {\\n\\n    var Image = function ( image ) {\\n        Object.call( this );\\n\\n        this._imageObject = undefined;\\n        this._url = undefined;\\n        this._width = undefined;\\n        this._height = undefined;\\n\\n        if ( image ) {\\n            this.setImage( image );\\n        }\\n\\n        this._isGreyscale = undefined;\\n    };\\n\\n    Image.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Object.prototype, {\\n\\n        dirty: function () {\\n            this._isGreyscale = undefined;\\n        },\\n        getImage: function () {\\n            return this._imageObject;\\n        },\\n        getURL: function () {\\n            return this._url;\\n        },\\n        setURL: function ( url ) {\\n            this._url = url;\\n        },\\n        setImage: function ( img ) {\\n            if ( !this._url && img && img.src ) {\\n                this._url = img.src;\\n            }\\n            this._imageObject = img;\\n            this.dirty();\\n        },\\n        isCanvas: function () {\\n            return this._imageObject instanceof HTMLCanvasElement;\\n        },\\n        isImage: function () {\\n            return this._imageObject instanceof window.Image;\\n        },\\n        isTypedArray: function () {\\n            return this._imageObject instanceof Uint8Array;\\n        },\\n        setWidth: function ( w ) {\\n            this._width = w;\\n        },\\n        setHeight: function ( h ) {\\n            this._height = h;\\n        },\\n        getWidth: function () {\\n            if ( this.isImage() ) {\\n                return this._imageObject.naturalWidth;\\n            } else if ( this.isCanvas() ) {\\n                return this._imageObject.width;\\n            }\\n            return this._width;\\n        },\\n        getHeight: function () {\\n            if ( this.isImage() ) {\\n                return this._imageObject.naturalHeight;\\n            } else if ( this.isCanvas() ) {\\n                return this._imageObject.height;\\n            }\\n            return this._height;\\n        },\\n\\n        isGreyscale: function ( nbSamples ) {\\n            if ( this._isGreyscale !== undefined )\\n                return this._isGreyscale;\\n\\n            if ( this._imageObject !== undefined && this.isReady() && this._isGreyscale === undefined ) {\\n\\n                var canvas = this._imageObject;\\n                if ( !this.isCanvas() ) {\\n                    canvas = document.createElement( \\'canvas\\' );\\n                }\\n                var ctx = canvas.getContext( \\'2d\\' );\\n                canvas.width = this._imageObject.width;\\n                canvas.height = this._imageObject.height;\\n                ctx.drawImage( this._imageObject, 0, 0 );\\n\\n                var sampleX, sampleY;\\n                // cap sample if needed\\n                if ( !nbSamples ) {\\n                    sampleX = canvas.width;\\n                    sampleY = canvas.height;\\n                }\\n                if ( nbSamples > 0 ) {\\n                    nbSamples = Math.min( Math.min( canvas.width, canvas.height ), nbSamples );\\n                    sampleX = sampleY = nbSamples;\\n                }\\n\\n                var isGreyscale = true;\\n                var xFactor = canvas.width / (sampleX );\\n                var yFactor = canvas.height / (sampleY );\\n                for ( var i = 0; i < sampleX; i++ ) {\\n                    for ( var j = 0; j < sampleY; j++ ) {\\n                        var x = Math.floor( xFactor * ( i + 0.5 ) ),\\n                            y = Math.floor( yFactor * ( j + 0.5 ) );\\n                        var data = ctx.getImageData( x, y, 1, 1 ).data;\\n                        if ( !( data[ 0 ] === data[ 1 ] && data[ 0 ] === data[ 2 ]) ) {\\n                            isGreyscale = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                this._isGreyscale = isGreyscale;\\n            }\\n\\n            return this._isGreyscale;\\n        },\\n\\n        isReady: function () {\\n\\n            // image are ready for static data\\n            if ( this.isCanvas() ||\\n                this.isTypedArray() ) {\\n                return true;\\n            }\\n\\n            if ( this.isImage() ) {\\n                var image = this._imageObject;\\n                if ( image.complete ) {\\n                    if ( image.naturalWidth !== undefined && image.naturalWidth === 0 ) {\\n                        return false;\\n                    }\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n    } ), \\'osg\\', \\'Image\\' );\\n\\n    MACROUTILS.setTypeID( Image );\\n\\n    return Image;\\n} );\\n\\n//# sourceURL=/osg/Image.js\");\n\n",
    "eval(\"define( \\'osg/TriangleIndexFunctor\\',[\\n    \\'osg/Vec3\\',\\n    \\'osg/PrimitiveSet\\'\\n], function( Vec3, PrimitiveSet ) {\\n\\n    // This class can be used to visit all the triangles of a geometry\\n    // You feed it with a callback that will be called for each triangle\\n    // (with the 3 indexes of vertices as arguments)\\n    var TriangleIndexFunctor = function( geom, cb ) {\\n        this._geom = geom;\\n        this._cb = cb;\\n    };\\n\\n    TriangleIndexFunctor.prototype = {\\n        applyDrawElementsTriangles: function( count, indexes ) {\\n            var cb = this._cb;\\n            for ( var i = 0; i < count; i += 3 ) {\\n                cb( indexes[ i ], indexes[ i + 1 ], indexes[ i + 2 ] );\\n            }\\n        },\\n\\n        applyDrawElementsTriangleStrip: function( count, indexes ) {\\n            var cb = this._cb;\\n            for ( var i = 2, j = 0; i < count; ++i, ++j ) {\\n                if ( i % 2 ) cb( indexes[ j ], indexes[ j + 2 ], indexes[ j + 1 ] );\\n                else cb( indexes[ j ], indexes[ j + 1 ], indexes[ j + 2 ] );\\n            }\\n        },\\n\\n        applyDrawElementsTriangleFan: function( count, indexes ) {\\n            var cb = this._cb;\\n            var first = indexes[ 0 ];\\n            for ( var i = 2, j = 1; i < count; ++i, ++j ) {\\n                cb( first, indexes[ j ], indexes[ j + 1 ] );\\n            }\\n        },\\n\\n        applyDrawArraysTriangles: function( first, count ) {\\n            var cb = this._cb;\\n            for ( var i = 2, pos = first; i < count; i += 3, pos += 3 ) {\\n                cb( pos, pos + 1, pos + 2 );\\n            }\\n        },\\n\\n        applyDrawArraysTriangleStrip: function( first, count ) {\\n            var cb = this._cb;\\n            for ( var i = 2, pos = first; i < count; ++i, ++pos ) {\\n                if ( i % 2 ) cb( pos, pos + 2, pos + 1 );\\n                else cb( pos, pos + 1, pos + 2 );\\n            }\\n        },\\n\\n        applyDrawArraysTriangleFan: function( first, count ) {\\n            var cb = this._cb;\\n            for ( var i = 2, pos = first + 1; i < count; ++i, ++pos ) {\\n                cb( first, pos, pos + 1 );\\n            }\\n        },\\n\\n        apply: function() {\\n            var geom = this._geom;\\n            var primitives = geom.primitives;\\n            if ( !primitives )\\n                return;\\n            var nbPrimitives = primitives.length;\\n            for ( var i = 0; i < nbPrimitives; i++ ) {\\n                var primitive = primitives[ i ];\\n                if ( primitive.getIndices !== undefined ) {\\n                    var indexes = primitive.indices.getElements();\\n                    switch ( primitive.getMode() ) {\\n                        case PrimitiveSet.TRIANGLES:\\n                            this.applyDrawElementsTriangles( primitive.getCount(), indexes );\\n                            break;\\n                        case PrimitiveSet.TRIANGLE_STRIP:\\n                            this.applyDrawElementsTriangleStrip( primitive.getCount(), indexes );\\n                            break;\\n                        case PrimitiveSet.TRIANGLE_FAN:\\n                            this.applyDrawElementsTriangleFan( primitive.getCount(), indexes );\\n                            break;\\n                    }\\n                } else { // draw array\\n                    switch ( primitive.getMode() ) {\\n                        case PrimitiveSet.TRIANGLES:\\n                            this.applyDrawArraysTriangles( primitive.getFirst(), primitive.getCount() );\\n                            break;\\n                        case PrimitiveSet.TRIANGLE_STRIP:\\n                            this.applyDrawArraysTriangleStrip( primitive.getFirst(), primitive.getCount() );\\n                            break;\\n                        case PrimitiveSet.TRIANGLE_FAN:\\n                            this.applyDrawArraysTriangleFan( primitive.getFirst(), primitive.getCount() );\\n                            break;\\n                    }\\n                }\\n            }\\n        }\\n    };\\n\\n    return TriangleIndexFunctor;\\n} );\\n\\n//# sourceURL=/osg/TriangleIndexFunctor.js\");\n\n",
    "eval(\"define( \\'osgUtil/TriangleIntersect\\',[\\n    \\'osg/Vec3\\',\\n    \\'osg/TriangleIndexFunctor\\'\\n], function( Vec3, TriangleIndexFunctor ) {\\n\\n    var TriangleHit = function( index, normal, r1, v1, r2, v2, r3, v3 ) {\\n        this.index = index;\\n        this.normal = normal;\\n        this.r1 = r1;\\n        this.v1 = v1;\\n        this.r2 = r2;\\n        this.v2 = v2;\\n        this.r3 = r3;\\n        this.v3 = v3;\\n    };\\n\\n    var TriangleIntersect = function() {\\n        this.hits = [];\\n        this.nodePath = [];\\n        this.index = 0;\\n    };\\n\\n    TriangleIntersect.prototype = {\\n        setNodePath: function( np ) {\\n            this.nodePath = np;\\n        },\\n        set: function( start, end ) {\\n            this.start = start;\\n            this.end = end;\\n            this.dir = Vec3.sub( end, start, [ 0.0, 0.0, 0.0 ] );\\n            this.length = Vec3.length( this.dir );\\n            this.invLength = 1.0 / this.length;\\n            Vec3.mult( this.dir, this.invLength, this.dir );\\n        },\\n\\n        apply: function( node ) {\\n            if ( !node.getAttributes().Vertex ) {\\n                return;\\n            }\\n            var vertices = node.getAttributes().Vertex.getElements();\\n            var self = this;\\n            var v1 = [ 0.0, 0.0, 0.0 ];\\n            var v2 = [ 0.0, 0.0, 0.0 ];\\n            var v3 = [ 0.0, 0.0, 0.0 ];\\n            var cb = function( i1, i2, i3 ) {\\n                if ( i1 === i2 || i1 === i3 || i2 === i3 )\\n                    return;\\n                var j = i1 * 3;\\n                v1[ 0 ] = vertices[ j ];\\n                v1[ 1 ] = vertices[ j + 1 ];\\n                v1[ 2 ] = vertices[ j + 2 ];\\n                j = i2 * 3;\\n                v2[ 0 ] = vertices[ j ];\\n                v2[ 1 ] = vertices[ j + 1 ];\\n                v2[ 2 ] = vertices[ j + 2 ];\\n                j = i3 * 3;\\n                v3[ 0 ] = vertices[ j ];\\n                v3[ 1 ] = vertices[ j + 1 ];\\n                v3[ 2 ] = vertices[ j + 2 ];\\n                self.intersect( v1, v2, v3 );\\n            };\\n            var tif = new TriangleIndexFunctor( node, cb );\\n            tif.apply();\\n        },\\n\\n        intersect: ( function() {\\n            var normal = [ 0.0, 0.0, 0.0 ];\\n            var e2 = [ 0.0, 0.0, 0.0 ];\\n            var e1 = [ 0.0, 0.0, 0.0 ];\\n            var tvec = [ 0.0, 0.0, 0.0 ];\\n            var pvec = [ 0.0, 0.0, 0.0 ];\\n            var qvec = [ 0.0, 0.0, 0.0 ];\\n            var epsilon = 1E-20;\\n            return function( v0, v1, v2 ) {\\n                this.index++;\\n                var d = this.dir;\\n\\n                Vec3.sub( v2, v0, e2 );\\n                Vec3.sub( v1, v0, e1 );\\n                Vec3.cross( d, e2, pvec );\\n\\n                var det = Vec3.dot( pvec, e1 );\\n                if ( det > -epsilon && det < epsilon )\\n                    return;\\n                var invDet = 1.0 / det;\\n\\n                Vec3.sub( this.start, v0, tvec );\\n\\n                var u = Vec3.dot( pvec, tvec ) * invDet;\\n                if ( u < 0.0 || u > 1.0 )\\n                    return;\\n\\n                Vec3.cross( tvec, e1, qvec );\\n\\n                var v = Vec3.dot( qvec, d ) * invDet;\\n                if ( v < 0.0 || ( u + v ) > 1.0 )\\n                    return;\\n\\n                var t = Vec3.dot( qvec, e2 ) * invDet;\\n\\n                if ( t < epsilon || t > this.length ) //no intersection\\n                    return;\\n\\n                var r0 = 1.0 - u - v;\\n                var r1 = u;\\n                var r2 = v;\\n                var r = t * this.invLength;\\n\\n                var interX = v0[ 0 ] * r0 + v1[ 0 ] * r1 + v2[ 0 ] * r2;\\n                var interY = v0[ 1 ] * r0 + v1[ 1 ] * r1 + v2[ 1 ] * r2;\\n                var interZ = v0[ 2 ] * r0 + v1[ 2 ] * r1 + v2[ 2 ] * r2;\\n\\n                Vec3.cross( e1, e2, normal );\\n                Vec3.normalize( normal, normal );\\n\\n                this.hits.push( {\\n                    \\'ratio\\': r,\\n                    \\'nodepath\\': this.nodePath.slice( 0 ),\\n                    \\'triangleHit\\': new TriangleHit( this.index - 1, normal.slice( 0 ), r0, v0.slice( 0 ), r1, v1.slice( 0 ), r2, v2.slice( 0 ) ),\\n                    \\'point\\': [ interX, interY, interZ ]\\n                } );\\n                this.hit = true;\\n            };\\n        } )()\\n    };\\n\\n    return TriangleIntersect;\\n} );\\n//# sourceURL=/osgUtil/TriangleIntersect.js\");\n\n",
    "eval(\"define( \\'osg/KdTree\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/BoundingBox\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/TriangleIndexFunctor\\',\\n    \\'osgUtil/TriangleIntersect\\',\\n    \\'osg/PrimitiveSet\\'\\n], function( MACROUTILS, BoundingBox, Vec3, TriangleIndexFunctor, TriangleIntersect, PrimitiveSet ) {\\n\\n    // **** GENERAL INFO ON KDTREE ****\\n    // A KdTree is a Spatial Partitionning Tree (http://en.wikipedia.org/wiki/Space_partitioning)\\n    // The type of tree is sort of defined by the splitting axis method:\\n    // - Per Axis split (octree/ kdtree)\\n    // - Arbritrary direction split (bsp)\\n\\n    // The algorithm used for splitting, the name for finding best split is \\'Surface Area Heuristic (SAH)\\'\\n    // Octree divide the space in 8 subspace (one box -> 8 sub boxes)\\n    // whereas kdtree does it by splitting population number in two equal group\\n\\n    // Kd Tree http://en.wikipedia.org/wiki/K-d_tree\\n    // a given set of points is sorted along one Axis (e.g. X).\\n    // The sorted list is split at the median.\\n    // The result are two sets, one for each half-space (left and right).\\n\\n    // Then, for the current node, the splitting-plane position (or the median-point) and depth is saved.\\n    // Finally, if the point-set has more than n point and the tree depth is below m \\n    // (with n,m chosen by the user, as build options), two child-nodes (L/R one for each point-set) \\n    // are created which themselfs repeat the pocedure.\\n\\n    // The split-axis gets alternated at each depth, the split order is computed by checking the main\\n    // bounding box the length of its axis\\n    // **** GENERAL INFO ON KDTREE ****\\n\\n    // The KdTree implemented here is flattened, ie, a node and its children all lie in the same array\\n    // The most important thing is the understanding of the variables first and second for each node\\n    // Their semantic depend if the node is a leaf or not\\n    // if it\\'s a leaf :\\n    //   first and second defines a range in the triangles array (triangles in the cell)\\n    // if it\\'s not a leaf :\\n    // - first and second respectively represents the left and right sub children\\n    // We know that a node is a leaf if first is negative, in that case the range will be defined by\\n    // [ -first - 1, -first-1 + second ]\\n    var KdNode = function( first, second ) {\\n        this._bb = new BoundingBox();\\n        this._first = first;\\n        this._second = second;\\n        // These variables represent the local clipped ray (for intersection test)\\n        // They are mostly temporary because they are recomputed for each intersection test\\n        this._nodeRayStart = [ 0.0, 0.0, 0.0 ];\\n        this._nodeRayEnd = [ 0.0, 0.0, 0.0 ];\\n    };\\n\\n    var IntersectKdTree = function( vertices, nodes, triangles, intersections, start, end, nodePath ) {\\n        this._vertices = vertices;\\n        this._kdNodes = nodes;\\n        this._triangles = triangles;\\n        this._intersector = new TriangleIntersect();\\n        this._dinvX = [ 0.0, 0.0, 0.0 ];\\n        this._dinvY = [ 0.0, 0.0, 0.0 ];\\n        this._dinvZ = [ 0.0, 0.0, 0.0 ];\\n        this.init( intersections, start, end, nodePath );\\n    };\\n\\n    IntersectKdTree.prototype = {\\n        init: function( intersections, start, end, nodePath ) {\\n            var d = Vec3.sub( end, start, [ 0.0, 0.0, 0.0 ] );\\n            var len = Vec3.length( d );\\n            var invLen = 0.0;\\n            if ( len !== 0.0 )\\n                invLen = 1.0 / len;\\n            Vec3.mult( d, invLen, d );\\n            if ( d[ 0 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 0 ], this._dinvX );\\n            if ( d[ 1 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 1 ], this._dinvY );\\n            if ( d[ 2 ] !== 0.0 ) Vec3.mult( d, 1.0 / d[ 2 ], this._dinvZ );\\n\\n            this._intersector.hits = intersections;\\n            this._intersector.setNodePath( nodePath );\\n            this._intersector.set( start, end );\\n        },\\n        // Classic ray intersection test\\n        // If it\\'s a leaf it does ray-triangles intersection with the triangles in the cell\\n        // If it\\'s not a leaf, it descend in the tree in a recursive way as long as the ray\\n        // intersects the boundinbox of the nodes\\n        intersect: ( function() {\\n\\n            var v0 = [ 0.0, 0.0, 0.0 ];\\n            var v1 = [ 0.0, 0.0, 0.0 ];\\n            var v2 = [ 0.0, 0.0, 0.0 ];\\n\\n            return function( node, ls, le ) {\\n                var first = node._first;\\n                var second = node._second;\\n                var triangles = this._triangles;\\n                var vertices = this._vertices;\\n\\n                if ( first < 0 ) {\\n                    // treat as a leaf\\n                    var istart = -first - 1;\\n                    var iend = istart + second;\\n                    var intersector = this._intersector;\\n                    intersector.index = istart;\\n\\n                    for ( var i = istart; i < iend; ++i ) {\\n                        var id = i * 3;\\n                        var iv0 = triangles[ id ] * 3;\\n                        var iv1 = triangles[ id + 1 ] * 3;\\n                        var iv2 = triangles[ id + 2 ] * 3;\\n\\n                        v0[ 0 ] = vertices[ iv0 ];\\n                        v0[ 1 ] = vertices[ iv0 + 1 ];\\n                        v0[ 2 ] = vertices[ iv0 + 2 ];\\n\\n                        v1[ 0 ] = vertices[ iv1 ];\\n                        v1[ 1 ] = vertices[ iv1 + 1 ];\\n                        v1[ 2 ] = vertices[ iv1 + 2 ];\\n\\n                        v2[ 0 ] = vertices[ iv2 ];\\n                        v2[ 1 ] = vertices[ iv2 + 1 ];\\n                        v2[ 2 ] = vertices[ iv2 + 2 ];\\n\\n                        intersector.intersect( v0, v1, v2 );\\n                    }\\n                } else {\\n                    var s = node._nodeRayStart;\\n                    var e = node._nodeRayEnd;\\n                    Vec3.copy( ls, s );\\n                    Vec3.copy( le, e );\\n                    if ( first > 0 ) {\\n                        if ( this.intersectAndClip( s, e, this._kdNodes[ first ]._bb ) ) {\\n                            this.intersect( this._kdNodes[ first ], s, e );\\n                        }\\n                    }\\n                    if ( second > 0 ) {\\n                        Vec3.copy( ls, s );\\n                        Vec3.copy( le, e );\\n                        if ( this.intersectAndClip( s, e, this._kdNodes[ second ]._bb ) ) {\\n                            this.intersect( this._kdNodes[ second ], s, e );\\n                        }\\n                    }\\n                }\\n            };\\n        } )(),\\n        // This method do 2 things\\n        // It test if the ray intersects the node\\n        // If so... it clip the ray so that the start and end point of the ray are\\n        // snapped to the bounding box of the nodes\\n        intersectAndClip: ( function() {\\n            var tmp = [ 0.0, 0.0, 0.0 ];\\n            return function( s, e, bb ) {\\n                var min = bb._min;\\n                var xmin = min[ 0 ];\\n                var ymin = min[ 1 ];\\n                var zmin = min[ 2 ];\\n\\n                var max = bb._max;\\n                var xmax = max[ 0 ];\\n                var ymax = max[ 1 ];\\n                var zmax = max[ 2 ];\\n\\n                var invX = this._dinvX;\\n                var invY = this._dinvY;\\n                var invZ = this._dinvZ;\\n\\n                if ( s[ 0 ] <= e[ 0 ] ) {\\n                    // trivial reject of segment wholely outside.\\n                    if ( e[ 0 ] < xmin ) return false;\\n                    if ( s[ 0 ] > xmax ) return false;\\n\\n                    if ( s[ 0 ] < xmin ) {\\n                        // clip s to xMin.\\n                        Vec3.mult( invX, xmin - s[ 0 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n\\n                    if ( e[ 0 ] > xmax ) {\\n                        // clip e to xMax.\\n                        Vec3.mult( invX, xmax - s[ 0 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n                } else {\\n                    if ( s[ 0 ] < xmin ) return false;\\n                    if ( e[ 0 ] > xmax ) return false;\\n\\n                    if ( e[ 0 ] < xmin ) {\\n                        // clip s to xMin.\\n                        Vec3.mult( invX, xmin - s[ 0 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n\\n                    if ( s[ 0 ] > xmax ) {\\n                        // clip e to xMax.\\n                        Vec3.mult( invX, xmax - s[ 0 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n                }\\n\\n                // compate s and e against the yMin to yMax range of bb.\\n                if ( s[ 1 ] <= e[ 1 ] ) {\\n\\n                    // trivial reject of segment wholely outside.\\n                    if ( e[ 1 ] < ymin ) return false;\\n                    if ( s[ 1 ] > ymax ) return false;\\n\\n                    if ( s[ 1 ] < ymin ) {\\n                        // clip s to yMin.\\n                        Vec3.mult( invY, ymin - s[ 1 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n\\n                    if ( e[ 1 ] > ymax ) {\\n                        // clip e to yMax.\\n                        Vec3.mult( invY, ymax - s[ 1 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n                } else {\\n                    if ( s[ 1 ] < ymin ) return false;\\n                    if ( e[ 1 ] > ymax ) return false;\\n\\n                    if ( e[ 1 ] < ymin ) {\\n                        // clip s to yMin.\\n                        Vec3.mult( invY, ymin - s[ 1 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n\\n                    if ( s[ 1 ] > ymax ) {\\n                        // clip e to yMax.\\n                        Vec3.mult( invY, ymax - s[ 1 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n                }\\n\\n                // compate s and e against the zMin to zMax range of bb.\\n                if ( s[ 2 ] <= e[ 2 ] ) {\\n                    // trivial reject of segment wholely outside.\\n                    if ( e[ 2 ] < zmin ) return false;\\n                    if ( s[ 2 ] > zmax ) return false;\\n\\n                    if ( s[ 2 ] < zmin ) {\\n                        // clip s to zMin.\\n                        Vec3.mult( invZ, zmin - s[ 2 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n\\n                    if ( e[ 2 ] > zmax ) {\\n                        // clip e to zMax.\\n                        Vec3.mult( invZ, zmax - s[ 2 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n                } else {\\n                    if ( s[ 2 ] < zmin ) return false;\\n                    if ( e[ 2 ] > zmax ) return false;\\n\\n                    if ( e[ 2 ] < zmin ) {\\n                        // clip s to zMin.\\n                        Vec3.mult( invZ, zmin - s[ 2 ], tmp );\\n                        Vec3.add( s, tmp, e );\\n                    }\\n\\n                    if ( s[ 2 ] > zmax ) {\\n                        // clip e to zMax.\\n                        Vec3.mult( invZ, zmax - s[ 2 ], tmp );\\n                        Vec3.add( s, tmp, s );\\n                    }\\n                }\\n                return true;\\n            };\\n        } )()\\n    };\\n\\n    var BuildKdTree = function( kdTree ) {\\n        this._kdTree = kdTree;\\n        this._bb = new BoundingBox();\\n        this._primitiveIndices = null; // Uint32Array\\n        this._centers = null; // Float32Array\\n        this._axisOrder = [ 0, 0, 0 ];\\n        this._stackLength = 0;\\n    };\\n\\n    BuildKdTree.prototype = {\\n        build: function( options, geom ) {\\n            var targetTris = options._targetNumTrianglesPerLeaf;\\n            var vertexAttrib = geom.getVertexAttributeList().Vertex;\\n            if ( !vertexAttrib )\\n                return false;\\n            var vertices = vertexAttrib.getElements();\\n            if ( !vertices )\\n                return false;\\n            var nbVertices = vertices.length / 3;\\n            if ( nbVertices < targetTris )\\n                return false;\\n\\n            this._bb.copy( geom.getBoundingBox() );\\n            this._kdTree.setVertices( vertices );\\n\\n            this.computeDivisions( options );\\n            options._numVerticesProcessed += nbVertices;\\n\\n            this.computeTriangles( geom );\\n\\n            var node = new KdNode( -1, this._primitiveIndices.length );\\n            node._bb.copy( this._bb );\\n            var nodeNum = this._kdTree.addNode( node );\\n\\n            var bb = new BoundingBox();\\n            bb.copy( this._bb );\\n            nodeNum = this.divide( options, bb, nodeNum, 0 );\\n\\n            // Here we re-order the triangle list so that we can have a flat tree\\n            // _primitiveIndices is the ordered array of the triangle indices\\n            var triangles = this._kdTree.getTriangles();\\n            var primitives = this._primitiveIndices;\\n            var nbPrimitives = primitives.length;\\n            var triangleOrdered = new MACROUTILS.Uint32Array( triangles.length );\\n            for ( var i = 0, j = 0; i < nbPrimitives; ++i, j += 3 ) {\\n                var id = primitives[ i ] * 3;\\n                triangleOrdered[ j ] = triangles[ id ];\\n                triangleOrdered[ j + 1 ] = triangles[ id + 1 ];\\n                triangleOrdered[ j + 2 ] = triangles[ id + 2 ];\\n            }\\n            this._kdTree.setTriangles( triangleOrdered );\\n\\n            return this._kdTree.getNodes().length > 0;\\n        },\\n        // The function first gather all the triangles of the geometry\\n        // It then computes the centroid for each triangle and initialize\\n        // of triangles indices that will refer to the main triangles array\\n        computeTriangles: function( geom ) {\\n            var kdTree = this._kdTree;\\n\\n            var totalLenArray = 0;\\n            var geomPrimitives = geom.primitives;\\n            var nbPrimitives = geomPrimitives.length;\\n            var i = 0;\\n            for ( i = 0; i < nbPrimitives; i++ ) {\\n                var prim = geomPrimitives[ i ];\\n                var mode = prim.getMode();\\n                if ( mode === PrimitiveSet.TRIANGLES )\\n                    totalLenArray += prim.getCount();\\n                else\\n                    totalLenArray += ( prim.getCount() - 2 ) * 3;\\n            }\\n            var indices = new MACROUTILS.Uint32Array( totalLenArray );\\n            var next = 0;\\n            var cb = function( i1, i2, i3 ) {\\n                if ( i1 === i2 || i1 === i3 || i2 === i3 )\\n                    return;\\n                indices[ next ] = i1;\\n                indices[ next + 1 ] = i2;\\n                indices[ next + 2 ] = i3;\\n                next += 3;\\n            };\\n\\n            var tif = new TriangleIndexFunctor( geom, cb );\\n            tif.apply();\\n            indices = indices.subarray( 0, next );\\n\\n            var nbTriangles = indices.length;\\n            kdTree.setTriangles( indices );\\n\\n            var vertices = kdTree.getVertices();\\n\\n            this._centers = new MACROUTILS.Float32Array( nbTriangles );\\n            var centers = this._centers;\\n            this._primitiveIndices = new MACROUTILS.Uint32Array( nbTriangles / 3 );\\n            var primitives = this._primitiveIndices;\\n\\n            var j = 0;\\n            for ( i = 0, j = 0; i < nbTriangles; i += 3, ++j ) {\\n                var iv0 = indices[ i ];\\n                var iv1 = indices[ i + 1 ];\\n                var iv2 = indices[ i + 2 ];\\n\\n                // discard degenerate points\\n                if ( iv0 === iv1 || iv1 === iv2 || iv0 === iv2 )\\n                    return;\\n\\n                iv0 *= 3;\\n                iv1 *= 3;\\n                iv2 *= 3;\\n\\n                var v0x = vertices[ iv0 ];\\n                var v0y = vertices[ iv0 + 1 ];\\n                var v0z = vertices[ iv0 + 2 ];\\n\\n                var v1x = vertices[ iv1 ];\\n                var v1y = vertices[ iv1 + 1 ];\\n                var v1z = vertices[ iv1 + 2 ];\\n\\n                var v2x = vertices[ iv2 ];\\n                var v2y = vertices[ iv2 + 1 ];\\n                var v2z = vertices[ iv2 + 2 ];\\n\\n                var minx = Math.min( v0x, Math.min( v1x, v2x ) );\\n                var miny = Math.min( v0y, Math.min( v1y, v2y ) );\\n                var minz = Math.min( v0z, Math.min( v1z, v2z ) );\\n\\n                var maxx = Math.max( v0x, Math.max( v1x, v2x ) );\\n                var maxy = Math.max( v0y, Math.max( v1y, v2y ) );\\n                var maxz = Math.max( v0z, Math.max( v1z, v2z ) );\\n                centers[ i ] = ( minx + maxx ) * 0.5;\\n                centers[ i + 1 ] = ( miny + maxy ) * 0.5;\\n                centers[ i + 2 ] = ( minz + maxz ) * 0.5;\\n                primitives[ j ] = j;\\n            }\\n        },\\n        computeDivisions: function( options ) {\\n            this._stackLength = options._maxNumLevels;\\n            var max = this._bb._max;\\n            var min = this._bb._min;\\n            var dx = max[ 0 ] - min[ 0 ];\\n            var dy = max[ 1 ] - min[ 1 ];\\n            var dz = max[ 2 ] - min[ 2 ];\\n            var axisOrder = this._axisOrder;\\n\\n            // We set the cutting order (longest edge aabb first)\\n            axisOrder[ 0 ] = ( dx >= dy && dx >= dz ) ? 0 : ( dy >= dz ) ? 1 : 2;\\n            axisOrder[ 2 ] = ( dx < dy && dx < dz ) ? 0 : ( dy < dz ) ? 1 : 2;\\n            var sum = axisOrder[ 0 ] + axisOrder[ 2 ];\\n            axisOrder[ 1 ] = sum === 3 ? 0 : sum === 2 ? 1 : 2;\\n        },\\n        // The core function of the kdtree building\\n        // It checks if the node need to be subdivide or not\\n        // If it decides it\\'s a leaf, it computes the final bounding box of the node\\n        // and it ends here\\n        // If it\\'s a node, then it puts the splitting axis position on the median population\\n        // On the same time it reorder the triangle index array\\n        divide: function( options, bb, nodeIndex, level ) {\\n            var kdTree = this._kdTree;\\n            var primitives = this._primitiveIndices;\\n            var nodes = kdTree.getNodes();\\n            var node = nodes[ nodeIndex ];\\n\\n            var first = node._first;\\n            var second = node._second;\\n\\n            var needToDivide = level < this._stackLength && first < 0 && second > options._targetNumTrianglesPerLeaf;\\n            var istart = -first - 1;\\n            var iend = istart + second - 1;\\n\\n            if ( !needToDivide ) {\\n                if ( first < 0 ) {\\n                    // leaf is done, now compute bound on it.\\n                    this.computeNodeBox( node, istart, iend );\\n                }\\n                return nodeIndex;\\n            }\\n\\n            if ( first >= 0 )\\n                return nodeIndex;\\n            // leaf node as first < 0, so look at dividing it.\\n\\n            var axis = this._axisOrder[ level % 3 ];\\n            var originalMin = bb._min[ axis ];\\n            var originalMax = bb._max[ axis ];\\n\\n            var mid = ( originalMin + originalMax ) * 0.5;\\n\\n            var originalLeftChildIndex = 0;\\n            var originalRightChildIndex = 0;\\n            var insitueDivision = false;\\n\\n            var left = istart;\\n            var right = iend;\\n\\n            var centers = this._centers;\\n            while ( left < right ) {\\n                while ( left < right && ( centers[ primitives[ left ] * 3 + axis ] <= mid ) ) {\\n                    ++left;\\n                }\\n\\n                while ( left < right && ( centers[ primitives[ right ] * 3 + axis ] > mid ) ) {\\n                    --right;\\n                }\\n\\n                if ( left < right ) {\\n                    var tmp = primitives[ left ];\\n                    primitives[ left ] = primitives[ right ];\\n                    primitives[ right ] = tmp;\\n                    ++left;\\n                    --right;\\n                }\\n            }\\n\\n            if ( left === right ) {\\n                if ( centers[ primitives[ left ] * 3 + axis ] <= mid )++left;\\n                else --right;\\n            }\\n\\n            if ( ( right - istart ) <= -1 ) {\\n                originalLeftChildIndex = 0;\\n                originalRightChildIndex = nodeIndex;\\n                insitueDivision = true;\\n            } else if ( ( iend - left ) <= -1 ) {\\n                originalLeftChildIndex = nodeIndex;\\n                originalRightChildIndex = 0;\\n                insitueDivision = true;\\n            } else {\\n                originalLeftChildIndex = kdTree.addNode( new KdNode( -istart - 1, ( right - istart ) + 1 ) );\\n                originalRightChildIndex = kdTree.addNode( new KdNode( -left - 1, ( iend - left ) + 1 ) );\\n            }\\n\\n\\n            var restore = bb._max[ axis ];\\n            bb._max[ axis ] = mid;\\n\\n            var leftChildIndex = originalLeftChildIndex !== 0 ? this.divide( options, bb, originalLeftChildIndex, level + 1 ) : 0;\\n\\n            bb._max[ axis ] = restore;\\n\\n            restore = bb._min[ axis ];\\n            bb._min[ axis ] = mid;\\n\\n            var rightChildIndex = originalRightChildIndex !== 0 ? this.divide( options, bb, originalRightChildIndex, level + 1 ) : 0;\\n\\n            bb._min[ axis ] = restore;\\n\\n            if ( !insitueDivision ) {\\n                node._first = leftChildIndex;\\n                node._second = rightChildIndex;\\n\\n                insitueDivision = true;\\n\\n                var bnode = node._bb;\\n                bnode.init();\\n                if ( leftChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ leftChildIndex ]._bb );\\n                if ( rightChildIndex !== 0 ) bnode.expandByBoundingBox( nodes[ rightChildIndex ]._bb );\\n            }\\n            return nodeIndex;\\n        },\\n        // It computes the bounding box of the node so that the box contains all the triangles\\n        // of the cell\\n        computeNodeBox: function( node, istart, iend ) {\\n            var minx = Infinity,\\n                miny = Infinity,\\n                minz = Infinity,\\n                maxx = -Infinity,\\n                maxy = -Infinity,\\n                maxz = -Infinity;\\n            var triangles = this._kdTree.getTriangles();\\n            var vertices = this._kdTree.getVertices();\\n            var primitives = this._primitiveIndices;\\n            for ( var i = istart; i <= iend; ++i ) {\\n                var id = primitives[ i ] * 3;\\n                var iv0 = triangles[ id ] * 3;\\n                var iv1 = triangles[ id + 1 ] * 3;\\n                var iv2 = triangles[ id + 2 ] * 3;\\n\\n                var v0x = vertices[ iv0 ];\\n                var v0y = vertices[ iv0 + 1 ];\\n                var v0z = vertices[ iv0 + 2 ];\\n\\n                var v1x = vertices[ iv1 ];\\n                var v1y = vertices[ iv1 + 1 ];\\n                var v1z = vertices[ iv1 + 2 ];\\n\\n                var v2x = vertices[ iv2 ];\\n                var v2y = vertices[ iv2 + 1 ];\\n                var v2z = vertices[ iv2 + 2 ];\\n\\n                minx = Math.min( minx, Math.min( v0x, Math.min( v1x, v2x ) ) );\\n                miny = Math.min( miny, Math.min( v0y, Math.min( v1y, v2y ) ) );\\n                minz = Math.min( minz, Math.min( v0z, Math.min( v1z, v2z ) ) );\\n\\n                maxx = Math.max( maxx, Math.max( v0x, Math.max( v1x, v2x ) ) );\\n                maxy = Math.max( maxy, Math.max( v0y, Math.max( v1y, v2y ) ) );\\n                maxz = Math.max( maxz, Math.max( v0z, Math.max( v1z, v2z ) ) );\\n            }\\n            var epsilon = 1E-6;\\n            var bnode = node._bb;\\n            var bmin = bnode._min;\\n            var bmax = bnode._max;\\n            bmin[ 0 ] = minx - epsilon;\\n            bmin[ 1 ] = miny - epsilon;\\n            bmin[ 2 ] = minz - epsilon;\\n            bmax[ 0 ] = maxx + epsilon;\\n            bmax[ 1 ] = maxy + epsilon;\\n            bmax[ 2 ] = maxz + epsilon;\\n        }\\n    };\\n\\n    var KdTree = function() {\\n        this._vertices = null;\\n        this._kdNodes = [];\\n        this._triangles = null; // Float32Array\\n    };\\n\\n    KdTree.prototype = MACROUTILS.objectLibraryClass( {\\n        getVertices: function() {\\n            return this._vertices;\\n        },\\n        setVertices: function( vertices ) {\\n            this._vertices = vertices;\\n        },\\n        getNodes: function() {\\n            return this._kdNodes;\\n        },\\n        getTriangles: function() {\\n            return this._triangles;\\n        },\\n        setTriangles: function( triangles ) {\\n            this._triangles = triangles;\\n        },\\n        addNode: function( node ) {\\n            this._kdNodes.push( node );\\n            return this._kdNodes.length - 1;\\n        },\\n        build: function( options, geom ) {\\n            var buildTree = new BuildKdTree( this );\\n            return buildTree.build( options, geom );\\n        },\\n        intersect: function( start, end, intersections, nodePath ) {\\n            if ( this._kdNodes.length === 0 ) {\\n                return false;\\n            }\\n\\n            var numIntersectionsBefore = intersections.length;\\n            var intersector = new IntersectKdTree( this._vertices, this._kdNodes, this._triangles, intersections, start, end, nodePath );\\n            intersector.intersect( this.getNodes()[ 0 ], start, end );\\n\\n            return numIntersectionsBefore !== intersections.length;\\n        }\\n    }, \\'osg\\', \\'KdTree\\' );\\n\\n    return KdTree;\\n} );\\n//# sourceURL=/osg/KdTree.js\");\n\n",
    "eval(\"define( \\'osg/KdTreeBuilder\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/KdTree\\'\\n], function ( MACROUTILS, NodeVisitor, KdTree ) {\\n\\n    var KdTreeBuilder = function ( options ) {\\n        NodeVisitor.call( this );\\n        this._buildOptions = options !== undefined ? options : {\\n            _numVerticesProcessed: 0,\\n            _targetNumTrianglesPerLeaf: 50,\\n            _maxNumLevels: 20\\n        };\\n    };\\n\\n    KdTreeBuilder.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n        apply: function ( node ) {\\n            if ( node.getShape ) {\\n                var shape = node.getShape();\\n                if ( shape === null ) { // we test if the kdTree is already built\\n                    var kdTree = new KdTree();\\n                    if ( kdTree.build( this._buildOptions, node ) ) {\\n                        node.setShape( kdTree );\\n                    }\\n                }\\n            }\\n            this.traverse( node );\\n        }\\n    } );\\n\\n    return KdTreeBuilder;\\n} );\\n//# sourceURL=/osg/KdTreeBuilder.js\");\n\n",
    "eval(\"define( \\'osg/Uniform\\',[\\n    \\'osg/Utils\\'\\n], function ( MACROUTILS ) {\\n    /**\\n     * Uniform manage variable used in glsl shader.\\n     * @class Uniform\\n     */\\n    var Uniform = function () {\\n        this.transpose = false;\\n        this._dirty = true;\\n        this.name = \\'\\';\\n        this.type = undefined;\\n    };\\n\\n    Uniform.isUniform = function ( obj ) {\\n        if ( typeof obj === \\'object\\' && Object.getPrototypeOf(obj) === Uniform.prototype ) {\\n            return true;\\n        }\\n        return false;\\n    };\\n\\n    /** @lends Uniform.prototype */\\n    Uniform.prototype = {\\n        getName: function () {\\n            return this.name;\\n        },\\n        getType: function () {\\n            return this.type;\\n        },\\n\\n        get: function () { // call dirty if you update this array outside\\n            return this.data;\\n        },\\n        set: function ( array ) {\\n            this.data = array;\\n            this.dirty();\\n        },\\n        dirty: function () {\\n            this._dirty = true;\\n        },\\n        apply: function ( gl, location ) {\\n            if ( this._dirty ) {\\n                this.update.call( this.glData, this.data );\\n                this._dirty = false;\\n            }\\n            this.glCall( gl, location, this.glData );\\n        },\\n        applyMatrix: function ( gl, location ) {\\n            if ( this._dirty ) {\\n                this.update.call( this.glData, this.data );\\n                this._dirty = false;\\n            }\\n            this.glCall( gl, location, this.transpose, this.glData );\\n        },\\n        update: function ( array ) {\\n            for ( var i = 0, l = array.length; i < l; ++i ) { // FF not traced maybe short\\n                this[ i ] = array[ i ];\\n            }\\n        },\\n\\n        _updateArray: function ( array ) {\\n            for ( var i = 0, l = array.length; i < l; ++i ) { // FF not traced maybe short\\n                this[ i ] = array[ i ];\\n            }\\n        },\\n\\n        _updateFloat1: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n        },\\n        _updateFloat2: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n            this[ 1 ] = f[ 1 ];\\n        },\\n        _updateFloat3: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n            this[ 1 ] = f[ 1 ];\\n            this[ 2 ] = f[ 2 ];\\n        },\\n        _updateFloat4: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n            this[ 1 ] = f[ 1 ];\\n            this[ 2 ] = f[ 2 ];\\n            this[ 3 ] = f[ 3 ];\\n        },\\n        _updateFloat9: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n            this[ 1 ] = f[ 1 ];\\n            this[ 2 ] = f[ 2 ];\\n            this[ 3 ] = f[ 3 ];\\n            this[ 4 ] = f[ 4 ];\\n            this[ 5 ] = f[ 5 ];\\n            this[ 6 ] = f[ 6 ];\\n            this[ 7 ] = f[ 7 ];\\n            this[ 8 ] = f[ 8 ];\\n        },\\n        _updateFloat16: function ( f ) {\\n            this[ 0 ] = f[ 0 ];\\n            this[ 1 ] = f[ 1 ];\\n            this[ 2 ] = f[ 2 ];\\n            this[ 3 ] = f[ 3 ];\\n            this[ 4 ] = f[ 4 ];\\n            this[ 5 ] = f[ 5 ];\\n            this[ 6 ] = f[ 6 ];\\n            this[ 7 ] = f[ 7 ];\\n            this[ 8 ] = f[ 8 ];\\n            this[ 9 ] = f[ 9 ];\\n            this[ 10 ] = f[ 10 ];\\n            this[ 11 ] = f[ 11 ];\\n            this[ 12 ] = f[ 12 ];\\n            this[ 13 ] = f[ 13 ];\\n            this[ 14 ] = f[ 14 ];\\n            this[ 15 ] = f[ 15 ];\\n        }\\n    };\\n\\n    Uniform.createFloat1 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = [ value ];\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform1fv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat1;\\n        uniform.set = function ( value ) {\\n            if ( value.length === undefined ) {\\n                this.data[ 0 ] = value;\\n            } else {\\n                this.data = value;\\n            }\\n            this.dirty();\\n        };\\n\\n        uniform.name = name;\\n        uniform.type = \\'float\\';\\n        return uniform;\\n    };\\n    Uniform.createFloat = Uniform.createFloat1;\\n    Uniform[ \\'float\\' ] = Uniform.createFloat1;\\n    Uniform.createFloatArray = function ( array, name ) {\\n        var u = Uniform.createFloat.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createFloat2 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform2fv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat2;\\n        uniform.name = name;\\n        uniform.type = \\'vec2\\';\\n        return uniform;\\n    };\\n    Uniform.vec2 = Uniform.createFloat2;\\n    Uniform.createFloat2Array = function ( array, name ) {\\n        var u = Uniform.createFloat2.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createFloat3 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform3fv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat3;\\n        uniform.name = name;\\n        uniform.type = \\'vec3\\';\\n        return uniform;\\n    };\\n    Uniform.vec3 = Uniform.createFloat3;\\n    Uniform.createFloat3Array = function ( array, name ) {\\n        var u = Uniform.createFloat3.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createFloat4 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0, 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform4fv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat4;\\n        uniform.name = name;\\n        uniform.type = \\'vec4\\';\\n        return uniform;\\n    };\\n    Uniform.vec4 = Uniform.createFloat4;\\n    Uniform.createFloat4Array = function ( array, name ) {\\n        var u = Uniform.createFloat4.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createInt1 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = [ value ];\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform1iv( location, glData );\\n        };\\n        uniform.set = function ( value ) {\\n            if ( value.length === undefined ) {\\n                this.data[ 0 ] = value;\\n            } else {\\n                this.data = value;\\n            }\\n            this.dirty();\\n        };\\n\\n        uniform.glData = new MACROUTILS.Int32Array( uniform.data );\\n        uniform.name = name;\\n        uniform.type = \\'int\\';\\n        return uniform;\\n    };\\n    Uniform[ \\'int\\' ] = Uniform.createInt1;\\n    Uniform.createInt = Uniform.createInt1;\\n    Uniform.createIntArray = function ( array, name ) {\\n        var u = Uniform.createInt.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n\\n    Uniform.createInt2 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform2iv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Int32Array( uniform.data );\\n        uniform.name = name;\\n        uniform.type = \\'vec2i\\';\\n        return uniform;\\n    };\\n    Uniform.vec2i = Uniform.createInt2;\\n    Uniform.createInt2Array = function ( array, name ) {\\n        var u = Uniform.createInt2.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createInt3 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform3iv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Int32Array( uniform.data );\\n        uniform.name = name;\\n        uniform.type = \\'vec3i\\';\\n        return uniform;\\n    };\\n    Uniform.vec3i = Uniform.createInt3;\\n    Uniform.createInt3Array = function ( array, name ) {\\n        var u = Uniform.createInt3.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createInt4 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 0, 0, 0, 0 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, glData ) {\\n            gl.uniform4iv( location, glData );\\n        };\\n        uniform.glData = new MACROUTILS.Int32Array( uniform.data );\\n        uniform.name = name;\\n        uniform.type = \\'vec4i\\';\\n        return uniform;\\n    };\\n    Uniform.vec4i = Uniform.createInt4;\\n\\n    Uniform.createInt4Array = function ( array, name ) {\\n        var u = Uniform.createInt4.call( this, array, name );\\n        u.update = Uniform.prototype._updateArray;\\n        return u;\\n    };\\n\\n    Uniform.createMatrix2 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 1, 0, 0, 1 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, transpose, glData ) {\\n            gl.uniformMatrix2fv( location, transpose, glData );\\n        };\\n        uniform.apply = uniform.applyMatrix;\\n        uniform.transpose = false;\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat4;\\n        uniform.name = name;\\n        uniform.type = \\'mat2\\';\\n        return uniform;\\n    };\\n    Uniform.createMat2 = Uniform.createMatrix2;\\n    Uniform.mat2 = Uniform.createMat2;\\n\\n    Uniform.createMatrix3 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, transpose, glData ) {\\n            gl.uniformMatrix3fv( location, transpose, glData );\\n        };\\n        uniform.apply = uniform.applyMatrix;\\n        uniform.transpose = false;\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat9;\\n        uniform.name = name;\\n        uniform.type = \\'mat3\\';\\n        return uniform;\\n    };\\n    Uniform.createMat3 = Uniform.createMatrix3;\\n    Uniform.mat3 = Uniform.createMatrix3;\\n\\n    Uniform.createMatrix4 = function ( data, uniformName ) {\\n        var value = data;\\n        var name = uniformName;\\n        if ( name === undefined ) {\\n            name = value;\\n            value = [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ];\\n        }\\n        var uniform = new Uniform();\\n        uniform.data = value;\\n        uniform.glCall = function ( gl, location, transpose, glData ) {\\n            gl.uniformMatrix4fv( location, transpose, glData );\\n        };\\n        uniform.apply = uniform.applyMatrix;\\n        uniform.transpose = false;\\n        uniform.glData = new MACROUTILS.Float32Array( uniform.data );\\n        uniform.update = Uniform.prototype._updateFloat16;\\n        uniform.name = name;\\n        uniform.type = \\'mat4\\';\\n        return uniform;\\n    };\\n    Uniform.createMat4 = Uniform.createMatrix4;\\n    Uniform.mat4 = Uniform.createMatrix4;\\n\\n    return Uniform;\\n} );\\n//# sourceURL=/osg/Uniform.js\");\n\n",
    "eval(\"define( \\'osg/Light\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Vec4\\',\\n    \\'osg/Map\\'\\n], function ( MACROUTILS, StateAttribute, Uniform, Matrix, Vec3, Vec4, Map ) {\\n\\n\\n    var Light = function ( lightNumber ) {\\n        StateAttribute.call( this );\\n\\n        if ( lightNumber === undefined ) {\\n            lightNumber = 0;\\n        }\\n\\n        this._color = [ 1.0, 1.0, 1.0 ];\\n        this._ambient = [ 0.0, 0.0, 0.0 ];\\n        this._useDiffuse = true;\\n        this._useSpecular = true;\\n        this._position = [ 0.0, 0.0, 0.0 ];\\n        this._direction = [ 0.0, 0.0, -1.0 ];\\n        this._spotCutoff = 1.0;\\n        this._spotBlend = 0.01;\\n        this._falloffType = \\'INVERSE_SQUARE\\';\\n        this._distance = 25;\\n        this._energy = 1.0;\\n        this._lightUnit = lightNumber;\\n        this._type = \\'POINT\\';\\n        this._useSphere = false;\\n        this._enable = true;\\n        this.dirty();\\n    };\\n\\n    /** @lends Light.prototype */\\n    Light.uniforms = {};\\n    Light.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\\n        attributeType: \\'Light\\',\\n        cloneType: function () {\\n            return new Light( this._lightUnit );\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType + this._lightUnit;\\n        },\\n        getUniformName: function ( name ) {\\n            return this.getPrefix() + \\'_uniform_\\' + name;\\n        },\\n        getHash: function () {\\n            return \\'Light\\' + this._lightUnit + this._type + this._falloffType + this._useSphere.toString() + this._useDiffuse.toString() + this._useSpecular.toString();\\n        },\\n        getOrCreateUniforms: function () {\\n\\n            var obj = Light;\\n            var typeMember = this.getTypeMember();\\n\\n            if ( obj.uniforms[ typeMember ] ) return obj.uniforms[ typeMember ];\\n\\n            var uniformList = {\\n                \\'color\\': \\'createFloat3\\',\\n                \\'position\\': \\'createFloat3\\',\\n                \\'direction\\': \\'createFloat3\\',\\n                \\'spotCutoff\\': \\'createFloat1\\',\\n                \\'spotBlend\\': \\'createFloat1\\',\\n                \\'distance\\': \\'createFloat1\\'\\n            };\\n\\n            var uniforms = {};\\n\\n            Object.keys( uniformList ).forEach( function ( key ) {\\n\\n                var type = uniformList[ key ];\\n                var func = Uniform[ type ];\\n                uniforms[ key ] = func( this.getUniformName( key ) );\\n\\n            }.bind( this ) );\\n\\n            obj.uniforms[ typeMember ] = new Map( uniforms );\\n\\n            return obj.uniforms[ typeMember ];\\n        },\\n\\n        isEnable: function () {\\n            return this._enable;\\n        },\\n        setEnable: function ( bool ) {\\n            this._enable = bool;\\n        },\\n        setPosition: function ( a ) {\\n            Vec3.copy( a, this._position );\\n        },\\n        setDirection: function ( a ) {\\n            Vec3.copy( a, this._direction );\\n        },\\n\\n        setColor: function ( a ) {\\n            Vec3.copy( a, this._color );\\n            this.dirty();\\n        },\\n        getColor: function () {\\n            return this._color;\\n        },\\n\\n        setAmbient: function ( a ) {\\n            Vec3.copy( a, this._ambient );\\n            this.dirty();\\n        },\\n        getAmbient: function () {\\n            return this._ambient;\\n        },\\n\\n\\n        setEnergy: function ( a ) {\\n            this._energy = a;\\n            this.dirty();\\n        },\\n        getEnergy: function () {\\n            return this._energy;\\n        },\\n\\n        setSpotCutoff: function ( a ) {\\n            this._spotCutoff = a;\\n            this.dirty();\\n        },\\n        setSpotBlend: function ( a ) {\\n            this._spotBlend = a;\\n            this.dirty();\\n        },\\n\\n\\n        setConstantAttenuation: function ( value ) {\\n            this._falloffType = \\'INVERSE_CONSTANT\\';\\n            this._distance = value;\\n            this.dirty();\\n        },\\n\\n        setLinearAttenuation: function ( value ) {\\n            this._falloffType = \\'INVERSE_LINEAR\\';\\n            this._distance = value;\\n            this.dirty();\\n        },\\n\\n        setQuadraticAttenuation: function ( value ) {\\n            this._falloffType = \\'INVERSE_SQUARE\\';\\n            this._distance = value;\\n            this.dirty();\\n        },\\n\\n        setDiffuse: function ( a ) {\\n            this._diffuse = a;\\n            this.setUseDiffuse(a);\\n            this.dirty();\\n        },\\n\\n        setUseDiffuse: function ( a ) {\\n            this._useDiffuse = a;\\n            this.dirty();\\n        },\\n\\n        getUseDiffuse: function () {\\n            return this._useDiffuse;\\n        },\\n\\n        setSpecular: function ( a ) {\\n            this._specular = a;\\n            this.setUseSpecular(a);\\n            this.dirty();\\n        },\\n\\n        setUseSpecular: function ( a ) {\\n            this._useSpecular = a;\\n            this.dirty();\\n        },\\n        getUseSpecular: function () {\\n            return this._useSpecular;\\n        },\\n\\n        setLightType: function ( a ) {\\n            if ( a === \\'SUN\\' || a === \\'HEMI\\' ) {\\n                this._position = [ 0, 0, -1 ];\\n            } else {\\n                this._position = [ 0, 0, 0 ];\\n            }\\n            this._type = a;\\n            this.dirty();\\n        },\\n        getLightType: function () {\\n            return this._type;\\n        },\\n\\n        setFalloffType: function ( value ) {\\n            this._falloffType = value;\\n        },\\n        getFalloffType: function () {\\n            return this._falloffType;\\n        },\\n\\n        setUseSphere: function ( value ) {\\n            this._useSphere = value;\\n        },\\n        getUseSphere: function () {\\n            return this._useSphere;\\n        },\\n\\n        setDistance: function ( value ) {\\n            this._distance = value;\\n            this.dirty();\\n        },\\n        getDistance: function () {\\n            return this._distance;\\n        },\\n\\n        setLightNumber: function ( unit ) {\\n            this._lightUnit = unit;\\n            this.dirty();\\n        },\\n        getLightNumber: function () {\\n            return this._lightUnit;\\n        },\\n\\n        getPrefix: function () {\\n            return this.getType() + this._lightUnit;\\n        },\\n        getParameterName: function ( name ) {\\n            return this.getPrefix() + \\'_\\' + name;\\n        },\\n\\n        applyPositionedUniform: ( function () {\\n            var invMatrix = new Matrix.create();\\n\\n            return function ( matrix /*, state*/ ) {\\n\\n                var uniformMap = this.getOrCreateUniforms();\\n\\n                if ( this._type === \\'SUN\\' || this._type === \\'HEMI\\' ) {\\n                    Matrix.copy( matrix, invMatrix );\\n                    invMatrix[ 12 ] = 0.0;\\n                    invMatrix[ 13 ] = 0.0;\\n                    invMatrix[ 14 ] = 0.0;\\n                    Matrix.inverse( invMatrix, invMatrix );\\n                    Matrix.transpose( invMatrix, invMatrix );\\n                    Matrix.transformVec3( invMatrix, this._position, uniformMap.position.get() );\\n                } else {\\n                    Matrix.transformVec3( matrix, this._position, uniformMap.position.get() );\\n                }\\n                if ( this._type === \\'SPOT\\' ) {\\n                    Matrix.copy( matrix, invMatrix );\\n                    invMatrix[ 12 ] = 0.0;\\n                    invMatrix[ 13 ] = 0.0;\\n                    invMatrix[ 14 ] = 0.0;\\n                    Matrix.inverse( invMatrix, invMatrix );\\n                    Matrix.transpose( invMatrix, invMatrix );\\n                    Matrix.transformVec3( invMatrix, this._direction, uniformMap.direction.get() );\\n                }\\n\\n                uniformMap.position.dirty();\\n                uniformMap.direction.dirty();\\n            };\\n        } )(),\\n\\n        apply: function ( /*state*/) {\\n            var uniformMap = this.getOrCreateUniforms();\\n\\n            var color = uniformMap.color.get();\\n            color[ 0 ] = this._color[ 0 ] * this._energy;\\n            color[ 1 ] = this._color[ 1 ] * this._energy;\\n            color[ 2 ] = this._color[ 2 ] * this._energy;\\n            uniformMap.color.dirty();\\n\\n            Vec3.copy( this._position, uniformMap.position.get() );\\n            Vec3.copy( this._direction, uniformMap.direction.get() );\\n            uniformMap.position.dirty();\\n            uniformMap.direction.dirty();\\n\\n            var spotsize = Math.cos( this._spotCutoff * 0.5 );\\n            uniformMap.spotCutoff.get()[ 0 ] = spotsize;\\n            uniformMap.spotCutoff.dirty();\\n\\n            uniformMap.spotBlend.get()[ 0 ] = ( 1.0 - spotsize ) * this._spotBlend;\\n            uniformMap.spotBlend.dirty();\\n\\n            uniformMap.distance.get()[ 0 ] = this._distance;\\n            uniformMap.distance.dirty();\\n\\n            this.setDirty( false );\\n        }\\n\\n    } ), \\'osg\\', \\'Light\\' );\\n\\n    MACROUTILS.setTypeID( Light );\\n\\n    return Light;\\n} );\\n\\n//# sourceURL=/osg/Light.js\");\n\n",
    "eval(\"define( \\'osg/LineWidth\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n], function ( MACROUTILS, StateAttribute ) {\\n\\n    var LineWidth = function ( lineWidth ) {\\n        StateAttribute.call( this );\\n        this.lineWidth = 1.0;\\n        if ( lineWidth !== undefined ) {\\n            this.lineWidth = lineWidth;\\n        }\\n    };\\n    LineWidth.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'LineWidth\\',\\n        cloneType: function () {\\n            return new LineWidth();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        apply: function ( state ) {\\n            state.getGraphicContext().lineWidth( this.lineWidth );\\n        }\\n    } ), \\'osg\\', \\'LineWidth\\' );\\n\\n    return LineWidth;\\n} );\\n\\n//# sourceURL=/osg/LineWidth.js\");\n\n",
    "eval(\"define( \\'osg/Program\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Map\\'\\n], function ( MACROUTILS, Notify, StateAttribute, Map ) {\\n\\n    /**\\n     * Program encapsulate an vertex and fragment shader\\n     * @class Program\\n     */\\n    var Program = function ( vShader, fShader ) {\\n        StateAttribute.call( this );\\n\\n        this.program = null;\\n        this.setVertexShader( vShader );\\n        this.setFragmentShader( fShader );\\n        this.dirty = true;\\n    };\\n\\n    /** @lends Program.prototype */\\n    Program.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n\\n        attributeType: \\'Program\\',\\n        cloneType: function () {\\n            var p = new Program();\\n            p.defaultProgram = true;\\n            return p;\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        setVertexShader: function ( vs ) {\\n            this.vertex = vs;\\n        },\\n        setFragmentShader: function ( fs ) {\\n            this.fragment = fs;\\n        },\\n        getVertexShader: function () {\\n            return this.vertex;\\n        },\\n        getFragmentShader: function () {\\n            return this.fragment;\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            if ( !this.program || this.isDirty() ) {\\n\\n                if ( this.defaultProgram === true ) {\\n                    return;\\n                }\\n\\n                if ( !this.vertex.shader ) {\\n                    this.vertex.compile( gl );\\n                }\\n                if ( !this.fragment.shader ) {\\n                    this.fragment.compile( gl );\\n                }\\n                this.program = gl.createProgram();\\n                gl.attachShader( this.program, this.vertex.shader );\\n                gl.attachShader( this.program, this.fragment.shader );\\n                MACROUTILS.timeStamp( \\'osgjs.metrics:linkShader\\' );\\n                gl.linkProgram( this.program );\\n                gl.validateProgram( this.program );\\n                if ( !gl.getProgramParameter( this.program, gl.LINK_STATUS ) && !gl.isContextLost() ) {\\n                    Notify.log( \\'can\\\\\\'t link program\\\\n\\' + \\'vertex shader:\\\\n\\' + this.vertex.text + \\'\\\\n fragment shader:\\\\n\\' + this.fragment.text );\\n                    Notify.log( gl.getProgramInfoLog( this.program ) );\\n                    this.setDirty( false );\\n                    //debugger;\\n                    return;\\n                }\\n\\n                this.uniformsCache = new Map();\\n                this.attributesCache = new Map();\\n\\n                this.cacheUniformList( gl, this.vertex.text );\\n                this.cacheUniformList( gl, this.fragment.text );\\n\\n                this.cacheAttributeList( gl, this.vertex.text );\\n\\n                this.setDirty( false );\\n            }\\n\\n            gl.useProgram( this.program );\\n        },\\n\\n        cacheUniformList: function ( gl, str ) {\\n            var r = str.match( /uniform\\\\s+\\\\w+\\\\s+\\\\w+/g );\\n            var map = this.uniformsCache;\\n            if ( r !== null ) {\\n                for ( var i = 0, l = r.length; i < l; i++ ) {\\n                    var uniform = r[ i ].match( /uniform\\\\s+\\\\w+\\\\s+(\\\\w+)/ )[ 1 ];\\n                    var location = gl.getUniformLocation( this.program, uniform );\\n                    if ( location !== undefined && location !== null ) {\\n                        if ( map[ uniform ] === undefined ) {\\n                            map[ uniform ] = location;\\n                            this.uniformsCache.dirty();\\n                        }\\n                    }\\n                }\\n            }\\n        },\\n\\n        cacheAttributeList: function ( gl, str ) {\\n            var r = str.match( /attribute\\\\s+\\\\w+\\\\s+\\\\w+/g );\\n            var map = this.attributesCache;\\n            if ( r !== null ) {\\n                for ( var i = 0, l = r.length; i < l; i++ ) {\\n                    var attr = r[ i ].match( /attribute\\\\s+\\\\w+\\\\s+(\\\\w+)/ )[ 1 ];\\n                    var location = gl.getAttribLocation( this.program, attr );\\n                    if ( location !== -1 && location !== undefined ) {\\n                        if ( map[ attr ] === undefined ) {\\n                            map[ attr ] = location;\\n                            this.attributesCache.dirty();\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    } ), \\'osg\\', \\'Program\\' );\\n\\n    Program.create = function ( vShader, fShader ) {\\n        Notify.log( \\'Program.create is deprecated use new Program(vertex, fragment) instead\\' );\\n        var program = new Program( vShader, fShader );\\n        return program;\\n    };\\n\\n    return Program;\\n} );\\n\\n//# sourceURL=/osg/Program.js\");\n\n",
    "eval(\"define( \\'osg/Shader\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\'\\n], function ( Notify, Utils ) {\\n\\n    /**\\n     * Shader manage shader for vertex and fragment, you need both to create a glsl program.\\n     * @class Shader\\n     */\\n    var Shader = function ( type, text ) {\\n\\n        var t = type;\\n        if ( typeof ( type ) === \\'string\\' ) {\\n            t = Shader[ type ];\\n        }\\n        this.type = t;\\n        this.setText( text );\\n    };\\n\\n    Shader.VERTEX_SHADER = 0x8B31;\\n    Shader.FRAGMENT_SHADER = 0x8B30;\\n\\n    /** @lends Shader.prototype */\\n    Shader.prototype = {\\n        setText: function ( text ) {\\n            this.text = text;\\n        },\\n        getText: function () {\\n            return this.text;\\n        },\\n        compile: function ( gl ) {\\n            this.shader = gl.createShader( this.type );\\n            gl.shaderSource( this.shader, this.text );\\n            Utils.timeStamp( \\'osgjs.metrics:compileShader\\' );\\n            gl.compileShader( this.shader );\\n            if ( !gl.getShaderParameter( this.shader, gl.COMPILE_STATUS ) && !gl.isContextLost() ) {\\n                Notify.log( \\'can\\\\\\'t compile shader:\\\\n\\' + this.text + \\'\\\\n\\' );\\n                var tmpText = \\'\\\\n\\' + this.text;\\n                var splittedText = tmpText.split( \\'\\\\n\\' );\\n                var newText = \\'\\\\n\\';\\n                for ( var i = 0, l = splittedText.length; i < l; ++i ) {\\n                    newText += i + \\' \\' + splittedText[ i ] + \\'\\\\n\\';\\n                }\\n                Notify.log( newText );\\n                Notify.log( gl.getShaderInfoLog( this.shader ) );\\n            }\\n        }\\n    };\\n\\n    Shader.create = function ( type, text ) {\\n        Notify.log( \\'Shader.create is deprecated, use new Shader with the same arguments instead\\' );\\n        return new Shader( type, text );\\n    };\\n\\n    return Shader;\\n} );\\n\\n//# sourceURL=/osg/Shader.js\");\n\n",
    "eval(\"define( \\'osg/TextureManager\\',[\\n    \\'osg/Notify\\'\\n\\n], function ( Notify ) {\\n\\n    var TextureProfile = function( target, internalFormat, width, height ) {\\n        this._target = target;\\n        this._internalFormat = internalFormat;\\n        this._width = width;\\n        this._height = height;\\n        this._size = 0;\\n        this.computeSize();\\n    };\\n\\n    TextureProfile.prototype = {\\n        match: function( textureProfile ) {\\n            return textureProfile._target === this._target &&\\n                textureProfile._internalFormat === this._internalFormat &&\\n                textureProfile._width === this._width &&\\n                textureProfile._height === this._height;\\n        },\\n        computeSize: function() {\\n            var Texture = require( \\'osg/Texture\\' );\\n\\n            var numBitsPerTexel = 0;\\n            switch( this._internalFormat) {\\n            case(1): numBitsPerTexel = 8; break;\\n            case(Texture.ALPHA): numBitsPerTexel = 8; break;\\n            case(Texture.LUMINANCE): numBitsPerTexel = 8; break;\\n\\n            case(Texture.LUMINANCE_ALPHA): numBitsPerTexel = 16; break;\\n            case(2): numBitsPerTexel = 16; break;\\n\\n            case(Texture.RGB): numBitsPerTexel = 24; break;\\n            case(3): numBitsPerTexel = 24; break;\\n\\n            case(Texture.RGBA): numBitsPerTexel = 32; break;\\n            case(4): numBitsPerTexel = 32; break;\\n\\n            }\\n            this._size = (Math.ceil( this._width * this._height * numBitsPerTexel)/8.0);\\n        },\\n\\n        getSize: function() { return this._size; }\\n\\n    };\\n    TextureProfile.getHash = function() {\\n        var array = Array.prototype.slice.call( arguments );\\n        var hash = \\'\\';\\n        array.forEach( function( element ) {\\n            hash += element;\\n        });\\n        return hash;\\n    };\\n\\n\\n    var TextureObject = function( texture, id, textureSet ) {\\n        this._texture = texture;\\n        this._id = id;\\n        this._textureSet = textureSet;\\n    };\\n\\n    TextureObject.prototype = {\\n        target: function() { return this._textureSet._profile._target; },\\n        id: function() { return this._id; },\\n        getTextureSet: function() {\\n            return this._textureSet;\\n        },\\n        reset: function() {\\n            this._textureObject = null;\\n            this._texture = undefined;\\n        },\\n        bind: function( gl ) {\\n            gl.bindTexture( this.target(), this._id );\\n        }\\n    };\\n\\n    var TextureObjectSet = function( profile ) {\\n        this._profile = profile;\\n        this._usedTextureObjects = [];\\n        this._orphanedTextureObjects = [];\\n    };\\n\\n    TextureObjectSet.prototype = {\\n        getProfile: function() { return this._profile; },\\n        getUsedTextureObjects: function() { return this._usedTextureObjects; },\\n        getOrphanedTextureObjects: function() { return this._orphanedTextureObjects; },\\n        takeOrGenerate: function( gl, texture ) {\\n\\n            var textureObject;\\n            if ( this._orphanedTextureObjects.length > 0 ) {\\n                textureObject = this.takeFromOrphans();\\n                textureObject.setTexture( texture );\\n                this._usedTextureObjects.push( textureObject );\\n                return textureObject;\\n            }\\n\\n            var textureID = gl.createTexture();\\n            textureObject = new TextureObject( texture, textureID, this );\\n            this._usedTextureObjects.push( textureObject );\\n\\n            return textureObject;\\n        },\\n\\n        // get texture object from pool\\n        takeFromOrphans: function() {\\n            if ( this._orphanedTextureObjects.length ) {\\n                var textureObject = this._orphanedTextureObjects.pop();\\n                this._usedTextureObjects.push( textureObject );\\n                return textureObject;\\n            }\\n            return undefined;\\n        },\\n\\n        // release texture object\\n        orphan: function( textureObject ) {\\n            var index = this._usedTextureObjects.indexOf( textureObject );\\n            if ( index > -1 ) {\\n                this._orphanedTextureObjects.push( this._usedTextureObjects[ index ] );\\n                this._usedTextureObjects.splice( index, 1 );\\n            }\\n        },\\n        flushAllDeletedTextureObjects: function( gl ) {\\n            var nbTextures = this._orphanedTextureObjects.length;\\n            var size = this.getProfile().getSize();\\n            this._orphanedTextureObjects.forEach( function( textureObject ) {\\n                gl.deleteTexture( textureObject.id() );\\n                textureObject.reset();\\n            });\\n            this._orphanedTextureObjects.length = 0;\\n            Notify.info( \\'TextureManager: released \\' + nbTextures + \\' with \\' + (nbTextures*size/(1024*1024)) + \\' MB\\' );\\n        }\\n    };\\n\\n\\n    var TextureManager = function() {\\n        this._textureSetMap = {};\\n    };\\n\\n    TextureManager.prototype = {\\n\\n        generateTextureObject: function( gl,\\n                                         texture,\\n                                         target,\\n                                         internalFormat,\\n                                         width,\\n                                         height )\\n        {\\n            var hash = TextureProfile.getHash( target, internalFormat, width, height );\\n\\n            if ( this._textureSetMap[ hash ] === undefined ) {\\n                 this._textureSetMap[ hash ] = new TextureObjectSet( new TextureProfile( target, internalFormat, width, height ) );\\n            }\\n\\n            var textureSet = this._textureSetMap[ hash ];\\n            var textureObject = textureSet.takeOrGenerate( gl, texture );\\n            return textureObject;\\n        },\\n        reportStats: function() {\\n            var total = 0;\\n            Object.keys( this._textureSetMap ).forEach( function( key ) {\\n                var profile = this._textureSetMap[ key ].getProfile();\\n                var size = profile.getSize() / ( 1024 * 1024 );\\n                var nb = this._textureSetMap[ key ].getUsedTextureObjects().length;\\n                size *= nb;\\n                total += size ;\\n                Notify.notice( \\'\\'+ size + \\' MB with \\' + nb + \\' texture of \\' + profile._width +\\'x\\' + profile._height + \\' \\' + profile._internalFormat);\\n            }, this );\\n            Notify.notice( \\'\\'+ total + \\' MB in total\\');\\n\\n        },\\n\\n        flushAllDeletedTextureObjects: function( gl ) {\\n            Object.keys( this._textureSetMap ).forEach( function( key ) {\\n                this._textureSetMap[ key ].flushAllDeletedTextureObjects( gl );\\n            }, this );\\n        },\\n\\n        releaseTextureObject: function( textureObject ) {\\n            if ( textureObject ) {\\n                var ts = textureObject.getTextureSet();\\n                ts.orphan( textureObject );\\n            }\\n        }\\n\\n    };\\n\\n    return TextureManager;\\n\\n});\\n\\n//# sourceURL=/osg/TextureManager.js\");\n\n",
    "eval(\"define( \\'osgDB/Options\\',[\\n], function( ) {\\n\\n    var defaultOptions = {\\n\\n        // prefix to built url to load resource\\n        prefixURL: \\'\\',\\n\\n        // callback used when loading data\\n        progressXHRCallback: undefined,\\n\\n        // replacement of readImageURL to use your own code to load osg.Image\\n        // the function will be execute in the context of Input, see Input:readImageURL\\n        readImageURL: undefined,\\n\\n        // replacement of readBinaryArrayURL to use your own code to load binary array\\n        // the function will be execute in the context of Input, see Input:readBinaryArrayURL\\n        readBinaryArrayURL: undefined,\\n\\n        imageLoadingUsePromise: true, // use promise to load image instead of returning Image\\n        imageOnload: undefined, // use callback when loading an image\\n        imageCrossOrigin: undefined // use callback when loading an image\\n    };\\n\\n    return defaultOptions;\\n\\n});\\n\\n//# sourceURL=/osgDB/Options.js\");\n\n",
    "eval(\"define( \\'osgDB/Input\\',[\\n    \\'Q\\',\\n    \\'require\\',\\n    \\'osg/Utils\\',\\n    \\'osgNameSpace\\',\\n    \\'osgDB/ReaderParser\\',\\n    \\'osgDB/Options\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Image\\',\\n    \\'osg/BufferArray\\',\\n    \\'osg/DrawArrays\\',\\n    \\'osg/DrawArrayLengths\\',\\n    \\'osg/DrawElements\\',\\n    \\'osg/PrimitiveSet\\'\\n], function ( Q, require, MACROUTILS, osgNameSpace, ReaderParser, Options, Notify, Image, BufferArray, DrawArrays, DrawArrayLengths, DrawElements, PrimitiveSet ) {\\n\\n    var Input = function ( json, identifier ) {\\n        this._json = json;\\n        var map = identifier;\\n        if ( map === undefined ) {\\n            map = {};\\n        }\\n        this._identifierMap = map;\\n        this._objectRegistry = {};\\n        // this._progressXHRCallback = undefined;\\n        // this._prefixURL = \\'\\';\\n        // this.setImageLoadingOptions( {\\n        //     promise: true,\\n        //     onload: undefined\\n        // } );\\n\\n        this.setOptions ( MACROUTILS.objectMix( {}, Options) );\\n\\n        // {\\n        //     prefixURL: \\'\\',\\n        //     progressXHRCallback: undefined,\\n        //     readImageURL: undefined,\\n        //     imageLoadingUsePromise: undefined,\\n        //     imageOnload: undefined,\\n        // };\\n    };\\n\\n\\n    // keep one instance of image fallback\\n    if ( !Input.imageFallback ) {\\n        Input.imageFallback = ( function () {\\n            var fallback = new window.Image();\\n            fallback.src = \\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQIW2P8DwQACgAD/il4QJ8AAAAASUVORK5CYII=\\';\\n            return fallback;\\n        } )();\\n    }\\n\\n    Input.prototype = {\\n\\n        setOptions: function ( options ) {\\n            this._defaultOptions = options;\\n        },\\n        getOptions: function () {\\n            return this._defaultOptions;\\n        },\\n        setProgressXHRCallback: function ( func ) {\\n            this._defaultOptions.progressXHRCallback = func;\\n        },\\n\\n        // used to override the type from pathname\\n        // typically if you want to create proxy object\\n        registerObject: function ( fullyQualifiedObjectname, constructor ) {\\n            this._objectRegistry[ fullyQualifiedObjectname ] = constructor;\\n        },\\n\\n        getJSON: function () {\\n            return this._json;\\n        },\\n\\n        setJSON: function ( json ) {\\n            this._json = json;\\n            return this;\\n        },\\n\\n        setPrefixURL: function ( prefix ) {\\n            this._defaultOptions.prefixURL = prefix;\\n        },\\n        getPrefixURL: function () {\\n            return this._defaultOptions.prefixURL;\\n        },\\n        computeURL: function ( url ) {\\n            if ( this._defaultOptions.prefixURL === undefined ) {\\n                return url;\\n            }\\n            return this._defaultOptions.prefixURL + url;\\n        },\\n        getObjectWrapper: function ( path ) {\\n            if ( this._objectRegistry[ path ] !== undefined ) {\\n                return new( this._objectRegistry[ path ] )();\\n            }\\n\\n            var scope = osgNameSpace;\\n            var splittedPath = path.split( \\'.\\' );\\n            for ( var i = 0, l = splittedPath.length; i < l; i++ ) {\\n                var obj = scope[ splittedPath[ i ] ];\\n                if ( obj === undefined ) {\\n                    return undefined;\\n                }\\n                scope = obj;\\n            }\\n            var ClassName = scope;\\n            // create the new obj\\n            return new( ClassName )();\\n        },\\n\\n        fetchImage: function ( image, url, options, defer ) {\\n            var checkInlineImage = \\'data:image/\\';\\n            // crossOrigin does not work for inline data image\\n            var isInlineImage = ( url.substring( 0, checkInlineImage.length ) === checkInlineImage );\\n            var img = new window.Image();\\n            img.onerror = function () {\\n                Notify.warn( \\'warning use white texture as fallback instead of \\' + url );\\n                image.setImage( Input.imageFallback );\\n                if ( defer ) {\\n                    defer.resolve( image );\\n                }\\n            };\\n\\n            if ( !isInlineImage && options.imageCrossOrigin ) {\\n                img.crossOrigin = options.imageCrossOrigin;\\n            }\\n\\n            img.onload = function () {\\n\\n                if ( defer ) {\\n                    if ( options.imageOnload ) options.imageOnload.call( image );\\n                    defer.resolve( image );\\n                } else if ( options.imageOnload )\\n                    options.imageOnload.call( image );\\n\\n            };\\n\\n            image.setURL( url );\\n            image.setImage( img );\\n\\n            img.src = url;\\n            return image;\\n        },\\n\\n        readImageURL: function ( url, options ) {\\n\\n            if ( options === undefined ) {\\n                options = this._defaultOptions;\\n            }\\n\\n            // hook reader\\n            if ( options.readImageURL ) {\\n                // be carefull if you plan to call hook the call and after\\n                // call the original readImageURL, you will need to remove\\n                // from options the readImageURL if you dont want an infinte\\n                // recursion call\\n                return options.readImageURL.call(this, url, options );\\n            }\\n\\n            // if image is on inline image skip url computation\\n            if ( url.substr( 0, 10 ) !== \\'data:image\\' ) {\\n                url = this.computeURL( url );\\n            }\\n\\n\\n            var image = new Image();\\n            if ( options.imageLoadingUsePromise !== true ) {\\n                return this.fetchImage( image, url, options );\\n            }\\n\\n            var defer = Q.defer();\\n            this.fetchImage( image, url, options, defer );\\n\\n            return defer.promise;\\n        },\\n\\n\\n        readNodeURL: function ( url, options ) {\\n            url = this.computeURL( url );\\n\\n            var defer = Q.defer();\\n\\n            options = options || {};\\n            var opt = MACROUTILS.objectMix( {}, options );\\n\\n            // automatic prefix if non specfied\\n            if ( opt.prefixURL === undefined ) {\\n                var prefix = this.getPrefixURL();\\n                var index = url.lastIndexOf( \\'/\\' );\\n                if ( index !== -1 ) {\\n                    prefix = url.substring( 0, index + 1 );\\n                }\\n                opt.prefixURL = prefix;\\n            }\\n\\n            var req = new XMLHttpRequest();\\n            req.open( \\'GET\\', url, true );\\n            req.onreadystatechange = function ( /*aEvt*/ ) {\\n                if ( req.readyState === 4 ) {\\n                    if ( req.status === 200 ) {\\n                        var ReaderParser = require( \\'osgDB/ReaderParser\\' );\\n                        Q.when( ReaderParser.parseSceneGraph( JSON.parse( req.responseText ),\\n                                opt ),\\n                            function ( child ) {\\n                                defer.resolve( child );\\n                                Notify.log( \\'loaded \\' + url );\\n\\n                            } ).fail( function ( error ) {\\n                            defer.reject( error );\\n                        } );\\n                    } else {\\n                        defer.reject( req.status );\\n                    }\\n                }\\n            };\\n            req.send( null );\\n            return defer.promise;\\n        },\\n\\n        readBinaryArrayURL: function ( url, options ) {\\n\\n            if ( options === undefined ) {\\n                options = this._defaultOptions;\\n            }\\n\\n            if ( options.readBinaryArrayURL ) {\\n                return options.readBinaryArrayURL.call( this, url, options );\\n            }\\n\\n            url = this.computeURL( url );\\n\\n\\n            if ( this._identifierMap[ url ] !== undefined ) {\\n                return this._identifierMap[ url ];\\n            }\\n            var defer = Q.defer();\\n            var xhr = new XMLHttpRequest();\\n            xhr.open( \\'GET\\', url, true );\\n            xhr.responseType = \\'arraybuffer\\';\\n\\n            if ( this._defaultOptions.progressXHRCallback ) {\\n                xhr.addEventListener( \\'progress\\', this._defaultOptions.progressXHRCallback, false );\\n            }\\n\\n            xhr.addEventListener( \\'error\\', function () {\\n                defer.reject();\\n            }, false );\\n\\n            var self = this;\\n            xhr.addEventListener( \\'load\\', function ( /*oEvent */ ) {\\n                var arrayBuffer = xhr.response; // Note: not oReq.responseText\\n                if ( arrayBuffer ) {\\n                    // var byteArray = new Uint8Array(arrayBuffer);\\n                    self._identifierMap[ url ] = arrayBuffer;\\n                    defer.resolve( arrayBuffer );\\n                } else {\\n                    defer.reject();\\n                }\\n            }, false );\\n\\n            xhr.send( null );\\n            this._identifierMap[ url ] = defer.promise;\\n            return defer.promise;\\n        },\\n\\n        readBufferArray: function () {\\n            var jsonObj = this.getJSON();\\n\\n            var uniqueID = jsonObj.UniqueID;\\n            var osgjsObject;\\n            if ( uniqueID !== undefined ) {\\n                osgjsObject = this._identifierMap[ uniqueID ];\\n                if ( osgjsObject !== undefined ) {\\n                    return osgjsObject;\\n                }\\n            }\\n\\n            var check = function ( o ) {\\n                if ( ( o.Elements !== undefined || o.Array !== undefined ) &&\\n                    o.ItemSize !== undefined &&\\n                    o.Type ) {\\n                    return true;\\n                }\\n                return false;\\n            };\\n\\n            if ( !check( jsonObj ) ) {\\n                return undefined;\\n            }\\n\\n            var obj, defer;\\n\\n            // inline array\\n            if ( jsonObj.Elements !== undefined ) {\\n                obj = new BufferArray( BufferArray[ jsonObj.Type ], jsonObj.Elements, jsonObj.ItemSize );\\n\\n            } else if ( jsonObj.Array !== undefined ) {\\n\\n                var buf = new BufferArray( BufferArray[ jsonObj.Type ] );\\n                buf.setItemSize( jsonObj.ItemSize );\\n\\n                var vb, type;\\n                if ( jsonObj.Array.Float32Array !== undefined ) {\\n                    vb = jsonObj.Array.Float32Array;\\n                    type = \\'Float32Array\\';\\n                } else if ( jsonObj.Array.Uint16Array !== undefined ) {\\n                    vb = jsonObj.Array.Uint16Array;\\n                    type = \\'Uint16Array\\';\\n                } else {\\n                    Notify.warn( \\'Typed Array \\' + window.Object.keys( jsonObj.Array )[ 0 ] );\\n                    type = \\'Float32Array\\';\\n                }\\n\\n                if ( vb !== undefined ) {\\n                    if ( vb.File !== undefined ) {\\n                        var url = vb.File;\\n\\n                        defer = Q.defer();\\n                        Q.when( this.readBinaryArrayURL( url ) ).then( function ( array ) {\\n\\n                            var typedArray;\\n                            // manage endianness\\n                            var bigEndian;\\n                            ( function () {\\n                                var a = new Uint8Array( [ 0x12, 0x34 ] );\\n                                var b = new Uint16Array( a.buffer );\\n                                bigEndian = ( ( b[ 0 ] ).toString( 16 ) === \\'1234\\' );\\n                            } )();\\n\\n                            var offset = 0;\\n                            if ( vb.Offset !== undefined ) {\\n                                offset = vb.Offset;\\n                            }\\n\\n                            var bytesPerElement = MACROUTILS[ type ].BYTES_PER_ELEMENT;\\n                            var nbItems = vb.Size;\\n                            var nbCoords = buf.getItemSize();\\n                            var totalSizeInBytes = nbItems * bytesPerElement * nbCoords;\\n\\n                            if ( bigEndian ) {\\n                                Notify.log( \\'big endian detected\\' );\\n                                var TypedArray = MACROUTILS[ type ];\\n                                var tmpArray = new TypedArray( nbItems * nbCoords );\\n                                var data = new DataView( array, offset, totalSizeInBytes );\\n                                var i = 0,\\n                                    l = tmpArray.length;\\n                                if ( type === \\'Uint16Array\\' ) {\\n                                    for ( ; i < l; i++ ) {\\n                                        tmpArray[ i ] = data.getUint16( i * bytesPerElement, true );\\n                                    }\\n                                } else if ( type === \\'Float32Array\\' ) {\\n                                    for ( ; i < l; i++ ) {\\n                                        tmpArray[ i ] = data.getFloat32( i * bytesPerElement, true );\\n                                    }\\n                                }\\n                                typedArray = tmpArray;\\n                                data = null;\\n                            } else {\\n                                typedArray = new MACROUTILS[ type ]( array, offset, nbCoords * nbItems );\\n                            }\\n\\n                            buf.setElements( typedArray );\\n                            defer.resolve( buf );\\n                        } );\\n                    } else if ( vb.Elements !== undefined ) {\\n                        var elements = new MACROUTILS[ type ]( vb.Elements );\\n                        buf.setElements( elements );\\n                    }\\n                }\\n                obj = buf;\\n            }\\n\\n            if ( uniqueID !== undefined ) {\\n                this._identifierMap[ uniqueID ] = obj;\\n            }\\n\\n            if ( defer !== undefined ) {\\n                return defer.promise;\\n            }\\n            return obj;\\n        },\\n\\n        readUserDataContainer: function () {\\n            var jsonObj = this.getJSON();\\n            var osgjsObject;\\n            var uniqueID = jsonObj.UniqueID;\\n            if ( uniqueID !== undefined ) {\\n                osgjsObject = this._identifierMap[ uniqueID ];\\n                if ( osgjsObject !== undefined ) {\\n                    return osgjsObject.Values;\\n                }\\n            }\\n\\n            this._identifierMap[ uniqueID ] = jsonObj;\\n            return jsonObj.Values;\\n        },\\n\\n        readPrimitiveSet: function () {\\n            var jsonObj = this.getJSON();\\n            var uniqueID;\\n            var osgjsObject;\\n\\n            var obj;\\n            var defer;\\n            var mode;\\n            var first, count;\\n            var drawElementPrimitive = jsonObj.DrawElementUShort || jsonObj.DrawElementUByte || jsonObj.DrawElementUInt || jsonObj.DrawElementsUShort || jsonObj.DrawElementsUByte || jsonObj.DrawElementsUInt || undefined;\\n            if ( drawElementPrimitive ) {\\n\\n                uniqueID = drawElementPrimitive.UniqueID;\\n                if ( uniqueID !== undefined ) {\\n                    osgjsObject = this._identifierMap[ uniqueID ];\\n                    if ( osgjsObject !== undefined ) {\\n                        return osgjsObject;\\n                    }\\n                }\\n\\n                defer = Q.defer();\\n                var jsonArray = drawElementPrimitive.Indices;\\n                var prevJson = jsonObj;\\n\\n                mode = drawElementPrimitive.Mode;\\n                if ( !mode ) {\\n                    mode = PrimitiveSet.TRIANGLES;\\n                } else {\\n                    mode = PrimitiveSet[ mode ];\\n                }\\n                obj = new DrawElements( mode );\\n\\n                this.setJSON( jsonArray );\\n                Q.when( this.readBufferArray() ).then(\\n                    function ( array ) {\\n                        obj.setIndices( array );\\n                        defer.resolve( obj );\\n                    } );\\n                this.setJSON( prevJson );\\n            }\\n\\n            var drawArrayPrimitive = jsonObj.DrawArray || jsonObj.DrawArrays;\\n            if ( drawArrayPrimitive ) {\\n\\n                uniqueID = drawArrayPrimitive.UniqueID;\\n                if ( uniqueID !== undefined ) {\\n                    osgjsObject = this._identifierMap[ uniqueID ];\\n                    if ( osgjsObject !== undefined ) {\\n                        return osgjsObject;\\n                    }\\n                }\\n\\n                mode = drawArrayPrimitive.Mode || drawArrayPrimitive.mode;\\n                first = drawArrayPrimitive.First !== undefined ? drawArrayPrimitive.First : drawArrayPrimitive.first;\\n                count = drawArrayPrimitive.Count !== undefined ? drawArrayPrimitive.Count : drawArrayPrimitive.count;\\n                var drawArray = new DrawArrays( PrimitiveSet[ mode ], first, count );\\n                obj = drawArray;\\n            }\\n\\n            var drawArrayLengthsPrimitive = jsonObj.DrawArrayLengths || undefined;\\n            if ( drawArrayLengthsPrimitive ) {\\n\\n                uniqueID = drawArrayLengthsPrimitive.UniqueID;\\n                if ( uniqueID !== undefined ) {\\n                    osgjsObject = this._identifierMap[ uniqueID ];\\n                    if ( osgjsObject !== undefined ) {\\n                        return osgjsObject;\\n                    }\\n                }\\n\\n                mode = drawArrayLengthsPrimitive.Mode;\\n                first = drawArrayLengthsPrimitive.First;\\n                var array = drawArrayLengthsPrimitive.ArrayLengths;\\n                var drawArrayLengths = new DrawArrayLengths( PrimitiveSet[ mode ], first, array );\\n                obj = drawArrayLengths;\\n            }\\n\\n            if ( uniqueID !== undefined ) {\\n                this._identifierMap[ uniqueID ] = obj;\\n            }\\n\\n            if ( defer ) {\\n                return defer.promise;\\n            }\\n            return obj;\\n        },\\n\\n\\n        readObject: function () {\\n\\n            var jsonObj = this.getJSON();\\n            var prop = window.Object.keys( jsonObj )[ 0 ];\\n            if ( !prop ) {\\n                Notify.warn( \\'can\\\\\\'t find property for object \\' + jsonObj );\\n                return undefined;\\n            }\\n\\n            var uniqueID = jsonObj[ prop ].UniqueID;\\n            var osgjsObject;\\n            if ( uniqueID !== undefined ) {\\n                osgjsObject = this._identifierMap[ uniqueID ];\\n                if ( osgjsObject !== undefined ) {\\n                    return osgjsObject;\\n                }\\n            }\\n\\n            var obj = this.getObjectWrapper( prop );\\n            if ( !obj ) {\\n                Notify.warn( \\'can\\\\\\'t instanciate object \\' + prop );\\n                return undefined;\\n            }\\n            var ReaderParser = require( \\'osgDB/ReaderParser\\' );\\n            var scope = ReaderParser.ObjectWrapper.serializers;\\n            var splittedPath = prop.split( \\'.\\' );\\n            for ( var i = 0, l = splittedPath.length; i < l; i++ ) {\\n                var reader = scope[ splittedPath[ i ] ];\\n                if ( reader === undefined ) {\\n                    Notify.warn( \\'can\\\\\\'t find function to read object \\' + prop + \\' - undefined\\' );\\n                    return undefined;\\n                }\\n                scope = reader;\\n            }\\n\\n            var promise = scope( this.setJSON( jsonObj[ prop ] ), obj );\\n\\n            if ( uniqueID !== undefined ) {\\n                this._identifierMap[ uniqueID ] = obj;\\n                obj._uniqueID = uniqueID;\\n            }\\n            return promise;\\n        }\\n    };\\n\\n    return Input;\\n} );\\n\\n//# sourceURL=/osgDB/Input.js\");\n\n",
    "eval(\"define( \\'osgDB/ReaderParser\\',[\\n    \\'Q\\',\\n    \\'require\\',\\n    \\'osgDB/Input\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/BlendFunc\\',\\n    \\'osg/Material\\',\\n    \\'osg/Geometry\\',\\n    \\'osg/BufferArray\\',\\n    \\'osg/PrimitiveSet\\',\\n    \\'osg/DrawArrays\\',\\n    \\'osg/DrawElements\\',\\n    \\'osg/StateSet\\',\\n    \\'osg/Node\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/MatrixTransform\\',\\n    \\'osg/Projection\\'\\n], function ( Q, require, Input, Notify, MACROUTILS, Texture, Uniform, BlendFunc, Material, Geometry, BufferArray, PrimitiveSet, DrawArrays, DrawElements, StateSet, Node, Matrix, MatrixTransform, Projection ) {\\n\\n    require( [ \\'osg/Material\\' ], function ( CircularDependency ) {\\n        Material = CircularDependency;\\n    } );\\n\\n    var ReaderParser = {};\\n\\n    ReaderParser.ObjectWrapper = {};\\n    ReaderParser.ObjectWrapper.serializers = {};\\n\\n    ReaderParser.readImage = function ( url, options ) {\\n        return ReaderParser.registry().readImageURL( url, options );\\n    };\\n    ReaderParser.readImageURL = ReaderParser.readImage; // alias\\n\\n    ReaderParser.readNodeURL = function ( url, options ) {\\n        return ReaderParser.registry().readNodeURL( url, options );\\n    };\\n\\n    ReaderParser.registry = function () {\\n        var Input = require( \\'osgDB/Input\\' );\\n        if ( ReaderParser.registry._input === undefined ) {\\n            ReaderParser.registry._input = new Input();\\n        }\\n        return ReaderParser.registry._input;\\n    };\\n\\n    ReaderParser.parseSceneGraph = function ( node, options ) {\\n        if ( node.Version !== undefined && node.Version > 0 ) {\\n            MACROUTILS.time(\\'osgjs.metric:ReaderParser.parseSceneGraph\\');\\n\\n            var getPropertyValue = function ( o ) {\\n                var props = window.Object.keys( o );\\n                for ( var i = 0, l = props.length; i < l; i++ ) {\\n                    if ( props[ i ] !== \\'Generator\\' && props[ i ] !== \\'Version\\' ) {\\n                        return props[ i ];\\n                    }\\n                }\\n                return undefined;\\n            };\\n\\n            var key = getPropertyValue( node );\\n            if ( key ) {\\n                var obj = {};\\n                obj[ key ] = node[ key ];\\n                var Input = require( \\'osgDB/Input\\' );\\n                var input = new Input( obj );\\n\\n                // copy global options and override with user options\\n                var opt = MACROUTILS.objectMix( MACROUTILS.objectMix( {}, ReaderParser.registry().getOptions() ), options || {} );\\n                input.setOptions( opt );\\n                var object = input.readObject();\\n                MACROUTILS.timeEnd(\\'osgjs.metric:ReaderParser.parseSceneGraph\\');\\n                return object;\\n            } else {\\n                Notify.log( \\'can\\\\\\'t parse scenegraph \\' + node );\\n            }\\n        } else {\\n            MACROUTILS.time(\\'osgjs.metric:ReaderParser.parseSceneGraphDeprecated\\');\\n            var nodeOld = ReaderParser.parseSceneGraphDeprecated( node );\\n            MACROUTILS.timeEnd(\\'osgjs.metric:ReaderParser.parseSceneGraphDeprecated\\');\\n            return nodeOld;\\n        }\\n        return undefined;\\n    };\\n\\n    ReaderParser.parseSceneGraphDeprecated = function ( node ) {\\n        var getFieldBackwardCompatible = function ( field, json ) {\\n            var value = json[ field ];\\n            if ( value === undefined ) {\\n                value = json[ field.toLowerCase() ];\\n            }\\n            return value;\\n        };\\n        var setName = function ( osgjs, json ) {\\n            var name = getFieldBackwardCompatible( \\'Name\\', json );\\n            if ( name && osgjs.setName !== undefined ) {\\n                osgjs.setName( name );\\n            }\\n        };\\n\\n        var setMaterial = function ( osgjs, json ) {\\n            setName( osgjs, json );\\n            osgjs.setAmbient( getFieldBackwardCompatible( \\'Ambient\\', json ) );\\n            osgjs.setDiffuse( getFieldBackwardCompatible( \\'Diffuse\\', json ) );\\n            osgjs.setEmission( getFieldBackwardCompatible( \\'Emission\\', json ) );\\n            osgjs.setSpecular( getFieldBackwardCompatible( \\'Specular\\', json ) );\\n            osgjs.setShininess( getFieldBackwardCompatible( \\'Shininess\\', json ) );\\n        };\\n\\n        var setBlendFunc = function ( osgjs, json ) {\\n            setName( osgjs, json );\\n            osgjs.setSourceRGB( json.SourceRGB );\\n            osgjs.setSourceAlpha( json.SourceAlpha );\\n            osgjs.setDestinationRGB( json.DestinationRGB );\\n            osgjs.setDestinationAlpha( json.DestinationAlpha );\\n        };\\n\\n        var setTexture = function ( osgjs, json ) {\\n            var magFilter = json.MagFilter || json[\\'mag_filter\\'] || undefined;\\n            if ( magFilter ) {\\n                osgjs.setMagFilter( magFilter );\\n            }\\n            var minFilter = json.MinFilter || json[\\'min_filter\\'] || undefined;\\n            if ( minFilter ) {\\n                osgjs.setMinFilter( minFilter );\\n            }\\n            var wrapT = json.WrapT || json[\\'wrap_t\\'] || undefined;\\n            if ( wrapT ) {\\n                osgjs.setWrapT( wrapT );\\n            }\\n            var wrapS = json.WrapS || json[\\'wrap_s\\'] || undefined;\\n            if ( wrapS ) {\\n                osgjs.setWrapS( wrapS );\\n            }\\n            var file = getFieldBackwardCompatible( \\'File\\', json );\\n            Q.when( ReaderParser.readImage( file ) ).then(\\n                function ( img ) {\\n                    osgjs.setImage( img );\\n                } );\\n        };\\n\\n        var setStateSet = function ( osgjs, json ) {\\n            setName( osgjs, json );\\n            var textures = getFieldBackwardCompatible( \\'Textures\\', json ) || getFieldBackwardCompatible( \\'TextureAttributeList\\', json ) || undefined;\\n            if ( textures ) {\\n                for ( var t = 0, tl = textures.length; t < tl; t++ ) {\\n                    var file = getFieldBackwardCompatible( \\'File\\', textures[ t ] );\\n                    if ( !file ) {\\n                        Notify.log( \\'no texture on unit \\' + t + \\' skip it\\' );\\n                        continue;\\n                    }\\n                    var Texture = require( \\'osg/Texture\\' );\\n                    var tex = new Texture();\\n                    setTexture( tex, textures[ t ] );\\n\\n                    osgjs.setTextureAttributeAndMode( t, tex );\\n                    osgjs.addUniform( Uniform.createInt1( t, \\'Texture\\' + t ) );\\n                }\\n            }\\n\\n            var blendfunc = getFieldBackwardCompatible( \\'BlendFunc\\', json );\\n            if ( blendfunc ) {\\n                var newblendfunc = new BlendFunc();\\n                setBlendFunc( newblendfunc, blendfunc );\\n                osgjs.setAttributeAndMode( newblendfunc );\\n            }\\n\\n            var material = getFieldBackwardCompatible( \\'Material\\', json );\\n            if ( material ) {\\n                var newmaterial = new Material();\\n                setMaterial( newmaterial, material );\\n                osgjs.setAttributeAndMode( newmaterial );\\n            }\\n        };\\n\\n\\n        var newnode;\\n        var children = node.children;\\n        var primitives = node.primitives || node.Primitives || undefined;\\n        var attributes = node.attributes || node.Attributes || undefined;\\n        if ( primitives || attributes ) {\\n            newnode = new Geometry();\\n\\n            setName( newnode, node );\\n\\n            MACROUTILS.extend( newnode, node ); // we should not do that\\n            node = newnode;\\n            node.primitives = primitives; // we should not do that\\n            node.attributes = attributes; // we should not do that\\n\\n            for ( var p = 0, lp = primitives.length; p < lp; p++ ) {\\n                var mode = primitives[ p ].mode;\\n                if ( primitives[ p ].indices ) {\\n                    var array = primitives[ p ].indices;\\n                    array = new BufferArray( BufferArray[ array.type ], array.elements, array.itemSize );\\n                    if ( !mode ) {\\n                        mode = \\'TRIANGLES\\';\\n                    } else {\\n                        mode = PrimitiveSet[ mode ];\\n                    }\\n                    primitives[ p ] = new DrawElements( mode, array );\\n                } else {\\n                    mode = PrimitiveSet[ mode ];\\n                    var first = primitives[ p ].first;\\n                    var count = primitives[ p ].count;\\n                    primitives[ p ] = new DrawArrays( mode, first, count );\\n                }\\n            }\\n\\n            for ( var key in attributes ) {\\n                if ( attributes.hasOwnProperty( key ) ) {\\n                    var attributeArray = attributes[ key ];\\n                    attributes[ key ] = new BufferArray( attributeArray.type, attributeArray.elements, attributeArray.itemSize );\\n                }\\n            }\\n        }\\n\\n        var stateset = getFieldBackwardCompatible( \\'StateSet\\', node );\\n        if ( stateset ) {\\n            var newstateset = new StateSet();\\n            setStateSet( newstateset, stateset );\\n            node.stateset = newstateset;\\n        }\\n\\n        var matrix = node.matrix || node.Matrix || undefined;\\n        if ( matrix ) {\\n            newnode = new MatrixTransform();\\n            setName( newnode, node );\\n\\n            MACROUTILS.extend( newnode, node );\\n            Matrix.copy( matrix, newnode.getMatrix() );\\n            node = newnode;\\n        }\\n\\n        var projection = node.projection || node.Projection || undefined;\\n        if ( projection ) {\\n            newnode = new Projection();\\n            setName( newnode, node );\\n            MACROUTILS.extend( newnode, node );\\n            Matrix.copy( projection, newnode.setProjectionMatrix() );\\n            node = newnode;\\n        }\\n\\n        // default type\\n        if ( node.typeID === undefined ) {\\n            newnode = new Node();\\n            setName( newnode, node );\\n            MACROUTILS.extend( newnode, node );\\n            node = newnode;\\n        }\\n\\n\\n        if ( children ) {\\n            // disable children, it will be processed in the end\\n            node.children = [];\\n\\n            for ( var child = 0, childLength = children.length; child < childLength; child++ ) {\\n                node.addChild( ReaderParser.parseSceneGraphDeprecated( children[ child ] ) );\\n            }\\n        }\\n\\n        return node;\\n    };\\n\\n    return ReaderParser;\\n} );\\n\\n//# sourceURL=/osgDB/ReaderParser.js\");\n\n",
    "eval(\"define( \\'osg/Texture\\',[\\n    \\'Q\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/TextureManager\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Image\\',\\n    \\'osgShader/ShaderGeneratorProxy\\',\\n    \\'osgDB/ReaderParser\\',\\n    \\'osg/Map\\'\\n], function ( Q, Notify, MACROUTILS, TextureManager, StateAttribute, Uniform, Image, ShaderGenerator, ReaderParser, Map ) {\\n\\n    // helper\\n    var isPowerOf2 = function ( x ) {\\n        /*jshint bitwise: false */\\n        return ( ( x !== 0 ) && ( ( x & ( ~x + 1 ) ) === x ) );\\n        /*jshint bitwise: true */\\n    };\\n\\n\\n    /**\\n     * Texture encapsulate webgl texture object\\n     * @class Texture\\n     * @inherits StateAttribute\\n     */\\n    var Texture = function () {\\n        StateAttribute.call( this );\\n        this.setDefaultParameters();\\n        this._applyTexImage2DCallbacks = [];\\n    };\\n    Texture.DEPTH_COMPONENT = 0x1902;\\n    Texture.ALPHA = 0x1906;\\n    Texture.RGB = 0x1907;\\n    Texture.RGBA = 0x1908;\\n    Texture.LUMINANCE = 0x1909;\\n    Texture.LUMINANCE_ALPHA = 0x190A;\\n\\n    // filter mode\\n    Texture.LINEAR = 0x2601;\\n    Texture.NEAREST = 0x2600;\\n    Texture.NEAREST_MIPMAP_NEAREST = 0x2700;\\n    Texture.LINEAR_MIPMAP_NEAREST = 0x2701;\\n    Texture.NEAREST_MIPMAP_LINEAR = 0x2702;\\n    Texture.LINEAR_MIPMAP_LINEAR = 0x2703;\\n\\n    // wrap mode\\n    Texture.CLAMP_TO_EDGE = 0x812F;\\n    Texture.REPEAT = 0x2901;\\n    Texture.MIRRORED_REPEAT = 0x8370;\\n\\n    // target\\n    Texture.TEXTURE_2D = 0x0DE1;\\n    Texture.TEXTURE_CUBE_MAP = 0x8513;\\n    Texture.TEXTURE_BINDING_CUBE_MAP = 0x8514;\\n    Texture.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;\\n    Texture.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;\\n    Texture.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;\\n    Texture.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;\\n    Texture.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;\\n    Texture.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;\\n    Texture.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;\\n\\n    Texture.UNSIGNED_BYTE = 0x1401;\\n    Texture.FLOAT = 0x1406;\\n\\n    Texture.textureManager = new TextureManager();\\n\\n    /** @lends Texture.prototype */\\n    Texture.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'Texture\\',\\n        cloneType: function () {\\n            var t = new Texture();\\n            t.defaultType = true;\\n            return t;\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        getOrCreateUniforms: function ( unit ) {\\n            if ( Texture.uniforms === undefined ) {\\n                Texture.uniforms = [];\\n            }\\n            if ( Texture.uniforms[ unit ] === undefined ) {\\n                var name = this.getType() + unit;\\n                var uniformMap = new Map();\\n                var uniform = Uniform.createInt1( unit, name );\\n                uniformMap.setMap( {\\n                    texture: uniform\\n                } );\\n                //gives uniformMap[\\'texture\\'] = uniform;\\n                uniform.dirty();\\n                Texture.uniforms[ unit ] = uniformMap;\\n            }\\n            // uniform for an texture attribute should directly in Texture.uniforms[unit]\\n            // and not in Texture.uniforms[unit][Texture0]\\n            // TODO tk: understand this comment: Why it\\'s in Texture.uniforms[unit][\\'texture\\'] then ?\\n            return Texture.uniforms[ unit ];\\n        },\\n        setDefaultParameters: function () {\\n            this._image = undefined;\\n            this._magFilter = Texture.LINEAR;\\n            this._minFilter = Texture.LINEAR;\\n            this._wrapS = Texture.CLAMP_TO_EDGE;\\n            this._wrapT = Texture.CLAMP_TO_EDGE;\\n            this._textureWidth = 0;\\n            this._textureHeight = 0;\\n            this._unrefImageDataAfterApply = false;\\n            this._internalFormat = undefined;\\n            this._textureTarget = Texture.TEXTURE_2D;\\n            this._type = Texture.UNSIGNED_BYTE;\\n        },\\n        getTextureTarget: function () {\\n            return this._textureTarget;\\n        },\\n        getTextureObject: function () {\\n            return this._textureObject;\\n        },\\n        setTextureSize: function ( w, h ) {\\n            this._textureWidth = w;\\n            this._textureHeight = h;\\n        },\\n        init: function ( gl ) {\\n            if ( !this._textureObject ) {\\n                this._textureObject = Texture.textureManager.generateTextureObject( gl,\\n                    this,\\n                    this._textureTarget,\\n                    this._internalFormat,\\n                    this._textureWidth,\\n                    this._textureHeight );\\n                this.dirty();\\n            }\\n        },\\n        addApplyTexImage2DCallback: function ( callback ) {\\n            var index = this._applyTexImage2DCallbacks.indexOf( callback );\\n            if ( index < 0 ) {\\n                this._applyTexImage2DCallbacks.push( callback );\\n            }\\n        },\\n        removeApplyTexImage2DCallback: function ( callback ) {\\n            var index = this._applyTexImage2DCallbacks.indexOf( callback );\\n            if ( index >= 0 ) {\\n                this._applyTexImage2DCallbacks.splice( index, 1 );\\n            }\\n        },\\n        getWidth: function () {\\n            return this._textureWidth;\\n        },\\n        getHeight: function () {\\n            return this._textureHeight;\\n        },\\n        releaseGLObjects: function ( gl ) {\\n\\n            if ( this._textureObject !== undefined && this._textureObject !== null ) {\\n                this._textureObject.releaseTextureObject( gl );\\n                this._textureObject = undefined;\\n                this._image = undefined;\\n            }\\n        },\\n        setWrapS: function ( value ) {\\n            if ( typeof ( value ) === \\'string\\' ) {\\n                this._wrapS = Texture[ value ];\\n            } else {\\n                this._wrapS = value;\\n            }\\n        },\\n        setWrapT: function ( value ) {\\n            if ( typeof ( value ) === \\'string\\' ) {\\n                this._wrapT = Texture[ value ];\\n            } else {\\n                this._wrapT = value;\\n            }\\n        },\\n\\n        getWrapT: function () {\\n            return this._wrapT;\\n        },\\n        getWrapS: function () {\\n            return this._wrapS;\\n        },\\n        getMinFilter: function () {\\n            return this._minFilter;\\n        },\\n        getMagFilter: function () {\\n            return this._magFilter;\\n        },\\n\\n        setMinFilter: function ( value ) {\\n            if ( typeof ( value ) === \\'string\\' ) {\\n                this._minFilter = Texture[ value ];\\n            } else {\\n                this._minFilter = value;\\n            }\\n        },\\n        setMagFilter: function ( value ) {\\n            if ( typeof ( value ) === \\'string\\' ) {\\n                this._magFilter = Texture[ value ];\\n            } else {\\n                this._magFilter = value;\\n            }\\n        },\\n\\n        setImage: function ( img, imageFormat ) {\\n\\n            var image = img;\\n            if ( img instanceof window.Image ||\\n                img instanceof HTMLCanvasElement ||\\n                img instanceof Uint8Array ) {\\n                image = new Image( img );\\n            }\\n\\n            this._image = image;\\n            this.setImageFormat( imageFormat );\\n            this.dirty();\\n        },\\n        getImage: function () {\\n            return this._image;\\n        },\\n        setImageFormat: function ( imageFormat ) {\\n            if ( imageFormat ) {\\n                if ( typeof ( imageFormat ) === \\'string\\' ) {\\n                    imageFormat = Texture[ imageFormat ];\\n                }\\n                this._imageFormat = imageFormat;\\n            } else {\\n                this._imageFormat = Texture.RGBA;\\n            }\\n        },\\n        setType: function ( value ) {\\n            if ( typeof ( value ) === \\'string\\' ) {\\n                this._type = Texture[ value ];\\n            } else {\\n                this._type = value;\\n            }\\n        },\\n        setUnrefImageDataAfterApply: function ( bool ) {\\n            this._unrefImageDataAfterApply = bool;\\n        },\\n        setInternalFormat: function ( internalFormat ) {\\n            this._internalFormat = internalFormat;\\n        },\\n        getInternalFormat: function () {\\n            return this._internalFormat;\\n        },\\n\\n        applyFilterParameter: function ( gl, target ) {\\n\\n            var powerOfTwo = isPowerOf2( this._textureWidth ) && isPowerOf2( this._textureHeight );\\n            if ( !powerOfTwo ) {\\n                this.setWrapT( Texture.CLAMP_TO_EDGE );\\n                this.setWrapS( Texture.CLAMP_TO_EDGE );\\n\\n                if ( this._minFilter === Texture.LINEAR_MIPMAP_LINEAR ||\\n                    this._minFilter === Texture.LINEAR_MIPMAP_NEAREST ) {\\n                    this.setMinFilter( Texture.LINEAR );\\n                }\\n            }\\n\\n            gl.texParameteri( target, gl.TEXTURE_MAG_FILTER, this._magFilter );\\n            gl.texParameteri( target, gl.TEXTURE_MIN_FILTER, this._minFilter );\\n            gl.texParameteri( target, gl.TEXTURE_WRAP_S, this._wrapS );\\n            gl.texParameteri( target, gl.TEXTURE_WRAP_T, this._wrapT );\\n        },\\n\\n        generateMipmap: function ( gl, target ) {\\n            if ( this._minFilter === gl.NEAREST_MIPMAP_NEAREST ||\\n                this._minFilter === gl.LINEAR_MIPMAP_NEAREST ||\\n                this._minFilter === gl.NEAREST_MIPMAP_LINEAR ||\\n                this._minFilter === gl.LINEAR_MIPMAP_LINEAR ) {\\n                gl.generateMipmap( target );\\n            }\\n        },\\n        applyTexImage2D: function ( gl ) {\\n            var args = Array.prototype.slice.call( arguments, 1 );\\n            MACROUTILS.timeStamp( \\'osgjs.metrics:Texture.texImage2d\\' );\\n            gl.texImage2D.apply( gl, args );\\n\\n            // call a callback when upload is done if there is one\\n            var numCallback = this._applyTexImage2DCallbacks.length;\\n            if ( numCallback > 0 ) {\\n                for ( var i = 0, l = numCallback; i < l; i++ ) {\\n                    this._applyTexImage2DCallbacks[ i ].call( this );\\n                }\\n            }\\n        },\\n        computeTextureFormat: function () {\\n            if ( !this._internalFormat ) {\\n                this._internalFormat = this._imageFormat || Texture.RGBA;\\n                this._imageFormat = this._internalFormat;\\n            } else {\\n                this._imageFormat = this._internalFormat;\\n            }\\n\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n\\n            if ( this._textureObject !== undefined && !this.isDirty() ) {\\n                this._textureObject.bind( gl );\\n            } else if ( this.defaultType ) {\\n                gl.bindTexture( this._textureTarget, null );\\n            } else {\\n                var image = this._image;\\n                if ( image !== undefined ) {\\n\\n                    // when data is ready we will upload it to the gpu\\n                    if ( image.isReady() ) {\\n\\n                        // must be called before init\\n                        this.computeTextureFormat();\\n\\n                        var imgWidth = image.getWidth() || this._textureWidth;\\n                        var imgHeight = image.getHeight() || this._textureHeight;\\n\\n                        this.setTextureSize( imgWidth, imgHeight );\\n\\n                        if ( !this._textureObject ) {\\n                            this.init( gl );\\n                        }\\n\\n                        this.setDirty( false );\\n                        this._textureObject.bind( gl );\\n\\n                        if ( image.isTypedArray() ) {\\n                            this.applyTexImage2D( gl,\\n                                this._textureTarget,\\n                                0,\\n                                this._internalFormat,\\n                                this._textureWidth,\\n                                this._textureHeight,\\n                                0,\\n                                this._internalFormat,\\n                                this._type,\\n                                this._image.getImage() );\\n                        } else {\\n                            this.applyTexImage2D( gl,\\n                                this._textureTarget,\\n                                0,\\n                                this._internalFormat,\\n                                this._internalFormat,\\n                                this._type,\\n                                image.getImage() );\\n                        }\\n\\n                        this.applyFilterParameter( gl, this._textureTarget );\\n                        this.generateMipmap( gl, this._textureTarget );\\n\\n                        if ( this._unrefImageDataAfterApply ) {\\n                            this._image = undefined;\\n                        }\\n\\n                    } else {\\n                        gl.bindTexture( this._textureTarget, null );\\n                    }\\n\\n                } else if ( this._textureHeight !== 0 && this._textureWidth !== 0 ) {\\n\\n                    // must be called before init\\n                    this.computeTextureFormat();\\n\\n                    if ( !this._textureObject ) {\\n                        this.init( gl );\\n                    }\\n                    this._textureObject.bind( gl );\\n                    this.applyTexImage2D( gl, this._textureTarget, 0, this._internalFormat, this._textureWidth, this._textureHeight, 0, this._internalFormat, this._type, null );\\n\\n                    this.applyFilterParameter( gl, this._textureTarget );\\n                    this.generateMipmap( gl, this._textureTarget );\\n                    this.setDirty( false );\\n                }\\n            }\\n        },\\n        getHash: function () {\\n            return \\'osgTexture\\';\\n        }\\n    } ), \\'osg\\', \\'Texture\\' );\\n\\n\\n    Texture.createFromURL = function ( imageSource, format ) {\\n        var texture = new Texture();\\n        Q.when( ReaderParser.readImage( imageSource ) ).then(\\n            function ( img ) {\\n                texture.setImage( img, format );\\n            }\\n        );\\n        return texture;\\n    };\\n\\n    Texture.createFromImage = function ( image, format ) {\\n        var a = new Texture();\\n        a.setImage( image, format );\\n        return a;\\n    };\\n\\n    Texture.createFromCanvas = function ( canvas, format ) {\\n        return Texture.createFromImage( canvas, format );\\n    };\\n\\n    Texture.create = function ( url ) {\\n        Notify.log( \\'Texture.create is deprecated, use Texture.createFromURL instead\\' );\\n        return Texture.createFromURL( url );\\n    };\\n\\n    return Texture;\\n} );\\n\\n//# sourceURL=/osg/Texture.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/utils/sprintf\\',[\\n\\n], function ( ) {\\n\\n    var sprintf = function (string, args) {\\n        if (!string || !args) {\\n            return \\'\\';\\n        }\\n\\n        var arg, reg;\\n\\n        for (var index in args) {\\n            arg = args[index];\\n\\n            if (typeof arg === \\'string\\') {\\n                reg = \\'%s\\';\\n            } else if (typeof arg === \\'number\\' && /\\\\./.test(arg.toString())) {\\n                reg = \\'%f\\';\\n            } else if (typeof arg === \\'number\\') {\\n                reg = \\'%d\\';\\n            } else {\\n                continue;\\n            }\\n            string = string.replace(reg, arg);\\n        }\\n        return string;\\n    };\\n\\n    return sprintf;\\n});\\n\\n//# sourceURL=/osgShader/utils/sprintf.js\");\n\n",
    "eval(\"define ( \\'osgShader/shaderNode/Node\\',[\\n    \\'require\\'\\n], function ( require ) {\\n\\n    var instance = 0;\\n    var Node = function() {\\n        this._name = \\'AbstractNode\\';\\n        this._inputs = [];\\n        this._outputs = [];\\n        this._id = instance++;\\n        this.connectInputs.apply(this, arguments );\\n    };\\n\\n    Node.prototype = {\\n        toString: function () {\\n            return this._name + \\' : { input: \\' + this._inputs.toString() + \\' }, output: { \\' + this._output.toString() + \\' } \\';\\n        },\\n        connectInput: function ( input ) {\\n            this._inputs.push( input );\\n        },\\n        connectInputs: function () {\\n\\n            // circular denpendency\\n            var data = require(\\'osgShader/shaderNode/data\\');\\n            var InlineConstant = data.InlineConstant;\\n            for ( var i = 0, l = arguments.length; i < l; i++ ) {\\n\\n                var input = arguments[ i ];\\n                if ( input === undefined ) {\\n                    break;\\n                }\\n\\n                // make it possible to use inline constant for input\\n                if ( typeof input === \\'string\\' ) {\\n                    input = new InlineConstant( input );\\n                }\\n\\n                this._inputs.push( input );\\n            }\\n        },\\n        connectOutput: function ( i ) {\\n            this._outputs.push( i );\\n            this.autoLink( i );\\n        },\\n        getOutput: function () {\\n            return this._outputs[ 0 ];\\n        },\\n        getOutputs: function () {\\n            return this._outputs;\\n        },\\n        getInputs: function () {\\n            return this._inputs;\\n        },\\n        autoLink: function ( output ) {\\n            if ( output === undefined ) {\\n                return;\\n            }\\n            output.connectInput( this );\\n        },\\n        connectUniforms: function ( context, attribute ) {\\n            var uniformMap = attribute.getOrCreateUniforms();\\n            var uniformMapKeys = uniformMap.getKeys();\\n\\n            for ( var m = 0, ml = uniformMapKeys.length; m < ml; m++ ) {\\n\\n                var kk = uniformMapKeys[ m ];\\n\\n                var kkey = uniformMap[ kk ];\\n                // check if uniform is already declared\\n\\n                var uniform = context.getVariable( kkey.name );\\n                if ( uniform === undefined ) {\\n                    uniform = context.Uniform( kkey.type, kkey.name );\\n                }\\n                // connect uniform to this node\\n                this.connectInput( uniform );\\n            }\\n        },\\n        computeFragment: function () {\\n            return undefined;\\n        },\\n        computeVertex: function () {\\n            return undefined;\\n        },\\n        comment: function ( txt ) {\\n            this._comment = \\'//\\' + txt;\\n        },\\n        getComment: function () {\\n            return this._comment;\\n        }\\n    };\\n\\n\\n    return Node;\\n});\\n\\n//# sourceURL=/osgShader/shaderNode/Node.js\");\n\n",
    "eval(\"/*global define */\\ndefine ( \\'osgShader/shaderNode/data\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n\\n    var Variable = function ( type, prefix ) {\\n        Node.call( this );\\n        this._name = \\'Variable\\';\\n        this._prefix = prefix;\\n        this._type = type;\\n        this._defaultValue = 10;\\n        this._disabledValue = 0;\\n        this._value = undefined;\\n    };\\n    Variable.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        getType: function () {\\n            return this._type;\\n        },\\n        getVariable: function () {\\n            return this._prefix;\\n        },\\n        setValue: function ( value ) {\\n            this._value = value;\\n        },\\n        declare: function () {\\n            if ( this._value !== undefined ) {\\n                return this._type + \\' \\' + this.getVariable() + \\' = \\' + this._value + \\';\\';\\n            }\\n            else {\\n                return this._type + \\' \\' + this.getVariable() + \\';\\';\\n            }\\n        }\\n    } );\\n\\n    var InlineConstant = function ( content ) {\\n        Node.call( this );\\n        this._value = content;\\n    };\\n    InlineConstant.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        getVariable: function () {\\n            return this._value;\\n        },\\n        setValue: function ( value ) {\\n            this._value = value;\\n        }\\n\\n    } );\\n\\n    var VariableRange = function ( type, prefix ) {\\n        Node.call( this );\\n        this._name = \\'VariableRange\\';\\n        this._prefix = prefix;\\n        this._type = type;\\n        this._min = 0;\\n        this._max = 1;\\n        this._step = 0.01;\\n        this._defaultValue = 10;\\n        this._disabledValue = 0;\\n        this._value = undefined;\\n    };\\n    VariableRange.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        getType: function () {\\n            return this._type;\\n        },\\n        getVariable: function () {\\n            return this._prefix;\\n        },\\n\\n        setValue: function ( value ) {\\n            this._value = value;\\n        },\\n        declare: function () {\\n            if ( this._value !== undefined ) {\\n                return this._type + \\' \\' + this.getVariable() + \\' = \\' + this._value + \\';\\';\\n            }\\n            else {\\n                return this._type + \\' \\' + this.getVariable() + \\';\\';\\n            }\\n        }\\n    } );\\n\\n    var VariableSet = function ( type, prefix, values ) {\\n        Node.call( this );\\n        this._name = \\'VariableSet\\';\\n        this._prefix = prefix;\\n        this._type = type;\\n        this._values = values; //ie [\\'true\\', \\'false\\'];\\n        this._value = undefined;\\n    };\\n    VariableSet.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        getType: function () {\\n            return this._type;\\n        },\\n        getVariable: function () {\\n            return this._prefix;\\n        },\\n\\n        setValue: function ( value ) {\\n            this._value = value;\\n        },\\n        declare: function () {\\n            if ( this._value !== undefined ) {\\n                return this._type + \\' \\' + this.getVariable() + \\' = \\' + this._value + \\';\\';\\n            }\\n            else {\\n                return this._type + \\' \\' + this.getVariable() + \\';\\';\\n            }\\n        }\\n    } );\\n\\n\\n    var Uniform = function ( type, prefix ) {\\n        Variable.call( this, type, prefix );\\n    };\\n    Uniform.prototype = MACROUTILS.objectInherit( Variable.prototype, {\\n        declare: function () {\\n            return undefined;\\n        },\\n        globalDeclaration: function () {\\n            return \\'uniform \\' + this._type + \\' \\' + this.getVariable() + \\';\\';\\n        }\\n    } );\\n\\n    var Varying = function ( type, prefix ) {\\n        Variable.call( this, type, prefix );\\n    };\\n    Varying.prototype = MACROUTILS.objectInherit( Variable.prototype, {\\n        declare: function () {\\n            return undefined;\\n        },\\n        globalDeclaration: function () {\\n            return \\'varying \\' + this._type + \\' \\' + this.getVariable() + \\';\\';\\n        }\\n    } );\\n\\n    var Sampler = function ( type, prefix ) {\\n        Variable.call( this, type, prefix );\\n    };\\n    Sampler.prototype = MACROUTILS.objectInherit( Variable.prototype, {\\n        declare: function () {\\n            return undefined;\\n        },\\n        globalDeclaration: function () {\\n            return \\'uniform \\' + this._type + \\' \\' + this.getVariable() + \\';\\';\\n        }\\n    } );\\n\\n    return {\\n        \\'Sampler\\': Sampler,\\n        \\'Variable\\': Variable,\\n        \\'Varying\\': Varying,\\n        \\'Uniform\\': Uniform,\\n        \\'VariableSet\\': VariableSet,\\n        \\'VariableRange\\': VariableRange,\\n        \\'InlineConstant\\': InlineConstant\\n    };\\n\\n} );\\n\\n//# sourceURL=/osgShader/shaderNode/data.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/shaderNode/textures\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n    var TextureRGB = function ( sampler, uv, output ) {\\n        Node.call( this );\\n        this._sampler = sampler;\\n        this.connectInput( sampler );\\n        this.connectInput( uv );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n        this._uv = uv;\\n    };\\n    TextureRGB.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'TextureRGB\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureRGB( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'vec3 textureRGB(const in sampler2D texture, const in vec2 uv) {\\',\\n                        \\'  return texture2D(texture, uv).rgb;\\',\\n                        \\'}\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n\\n    var TextureRGBA = function ( sampler, uv, output ) {\\n        TextureRGB.call( this, sampler, uv, output );\\n    };\\n    TextureRGBA.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\\n        type: \\'TextureRGBA\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureRGBA( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'vec4 textureRGBA(const in sampler2D texture, const in vec2 uv) {\\',\\n                        \\'  return texture2D(texture, uv);\\',\\n                        \\'}\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n\\n    var TextureAlpha = function ( sampler, uv, output ) {\\n        TextureRGB.call( this, sampler, uv, output );\\n    };\\n    TextureAlpha.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\\n        type: \\'TextureAlpha\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureAlpha( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'float textureAlpha(const in sampler2D texture, const in vec2 uv) {\\',\\n                        \\'  return texture2D(texture, uv).a;\\',\\n                        \\'}\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n\\n    var TextureCubemapRGB = function ( sampler, uv, output ) {\\n        TextureRGB.call( this, sampler, uv, output );\\n    };\\n    TextureCubemapRGB.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\\n        type: \\'TextureCubemapRGB\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureCubemapRGB( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xyz);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var TextureSpheremap = function ( sampler, uv, output ) {\\n        TextureRGBA.call( this, sampler, uv, output );\\n    };\\n    TextureSpheremap.prototype = MACROUTILS.objectInherit( TextureRGBA.prototype, {\\n        type: \\'TextureSpheremap\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureSpheremap( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xyz);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var TextureSpheremapHDR = function ( sampler, size, uv, output ) {\\n        TextureRGBA.call( this, sampler, uv, output );\\n\\n        this._size = size;\\n        this.connectInput( size );\\n    };\\n    TextureSpheremapHDR.prototype = MACROUTILS.objectInherit( TextureRGBA.prototype, {\\n        type: \\'TextureSpheremapHDR\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureSpheremapHDR( \\' + this._sampler.getVariable() + \\', \\' + this._size.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xyz);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var TextureTranslucency = function ( sampler, uv ) {\\n        TextureAlpha.call( this, sampler, uv );\\n    };\\n    TextureTranslucency.prototype = MACROUTILS.objectInherit( TextureAlpha.prototype, {\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = 1.0 - textureAlpha( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var TextureIntensity = function ( sampler, uv, output ) {\\n        TextureRGB.call( this, sampler, uv, output );\\n    };\\n    TextureIntensity.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\\n        type: \\'TextureIntensity\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureIntensity( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n\\n    var TextureNormal = function ( sampler, uv, output ) {\\n        TextureRGB.call( this, sampler, uv, output );\\n    };\\n    TextureNormal.prototype = MACROUTILS.objectInherit( TextureRGB.prototype, {\\n        type: \\'TextureNormal\\',\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureNormal( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy);\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n\\n    var TextureGradient = function(sampler, coord, size, output) {\\n        TextureRGB.call(this, sampler, coord, output);\\n        this._step = size;\\n        this.connectInput(size);\\n    };\\n    TextureGradient.prototype = MACROUTILS.objectInherit(TextureRGB.prototype, {\\n        type: \\'TextureGradient\\',\\n        computeFragment: function() {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = textureGradient( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xy, \\' + this._step.getVariable() + \\');\\'\\n                      ].join(\\'\\\\n\\');\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function() {\\n            var str = [ \\'\\',\\n                        \\'#pragma include \\\"textures.glsl\\\"\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    });\\n\\n\\n    return { \\'TextureRGB\\': TextureRGB,\\n             \\'TextureRGBA\\': TextureRGBA,\\n             \\'TextureAlpha\\': TextureAlpha,\\n             \\'TextureCubemapRGB\\': TextureCubemapRGB,\\n             \\'TextureSpheremap\\': TextureSpheremap,\\n             \\'TextureSpheremapHDR\\': TextureSpheremapHDR,\\n             \\'TextureTranslucency\\': TextureTranslucency,\\n             \\'TextureIntensity\\': TextureIntensity,\\n             \\'TextureNormal\\': TextureNormal,\\n             \\'TextureGradient\\': TextureGradient\\n           };\\n});\\n\\n//# sourceURL=/osgShader/shaderNode/textures.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/shaderNode/functions\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n    // TODO populate function.glsl replacement\\n\\n\\n    var NormalizeNormalAndEyeVector = function(fnormal, fpos) {\\n        Node.apply(this, arguments);\\n        this._normal = fnormal;\\n        this._position = fpos;\\n    };\\n    NormalizeNormalAndEyeVector.prototype = MACROUTILS.objectInherit(Node.prototype, {\\n        type: \\'NormalizeNormalAndEyeVector\\',\\n        connectOutputNormal: function(n) {\\n            this._outputNormal = n;\\n            this.autoLink(this._outputNormal);\\n        },\\n        connectOutputEyeVector: function(n) {\\n            this._outputEyeVector = n;\\n            this.autoLink(this._outputEyeVector);\\n        },\\n        computeFragment: function() {\\n            var str = [ \\'\\',\\n                        this._outputNormal.getVariable() + \\' = normalize(\\'+this._normal.getVariable() +\\');\\',\\n                        this._outputEyeVector.getVariable() + \\' = -normalize(\\'+this._position.getVariable() + \\');\\'\\n                      ].join(\\'\\\\n\\');\\n            return str;\\n        }\\n    });\\n\\n    var sRGB2Linear = function ( input, output ) {\\n        Node.call( this, input );\\n        this.connectOutput( output );\\n    };\\n    sRGB2Linear.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'sRGB2Linear\\',\\n        computeFragment: function () {\\n            var inputType = this._inputs[ 0 ].getType();\\n            return this.getOutput().getVariable() + \\' = srgb2linearrgb_\\' + inputType + \\'(\\' + this._inputs[ 0 ].getVariable() + \\');\\';\\n        },\\n        globalFunctionDeclaration: function () {\\n            var str = [\\n                \\'#pragma include \\\"functions.glsl\\\"\\',\\n                \\'\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var Linear2sRGB = function ( input, output, gamma ) {\\n        Node.call( this, input );\\n        this.connectOutput( output );\\n        this._gamma = gamma;\\n    };\\n    Linear2sRGB.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'Linear2sRGB\\',\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = linearrgb2srgb_\\' + this._inputs[ 0 ].getType() + \\'(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._gamma.getVariable() + \\');\\';\\n        },\\n        globalFunctionDeclaration: function () {\\n            var str = [\\n                \\'#pragma include \\\"functions.glsl\\\"\\',\\n                \\'\\',\\n                \\'\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n    Linear2sRGB.defaultGamma = 2.4;\\n\\n\\n    var DotClamp = function () {\\n        Node.call( this );\\n    };\\n    DotClamp.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'DotClamp\\',\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = max( dot(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._inputs[ 1 ].getVariable() + \\'), 0.0);\\';\\n        }\\n    } );\\n\\n    var NormalTangentSpace = function ( tangent, normal, texNormal, output ) {\\n        Node.call( this, tangent, normal, texNormal );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n    };\\n    NormalTangentSpace.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'NormalTangentSpace\\',\\n        globalFunctionDeclaration: function () {\\n            // about the default normal to 0.0, 1.0, 0.0\\n            // http://www.opengl.org/discussion_boards/showthread.php/171971-GLSL-normalize-and-length-on-zero-vectors\\n            var str = [\\n                \\'#pragma include \\\"functions.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n        computeFragment: function () {\\n            return \\'mtex_nspace_tangent(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._inputs[ 1 ].getVariable() + \\', \\' + this._inputs[ 2 ].getVariable() + \\', \\' + this.getOutput().getVariable() + \\');\\';\\n        }\\n    } );\\n\\n\\n    var EnvironmentTransform = function ( environmentTransform, direction, output ) {\\n        Node.call( this );\\n        this.connectInputs( environmentTransform, direction );\\n        this._direction = direction;\\n        this._environmentTransform = environmentTransform;\\n\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n\\n        this._output = output;\\n    };\\n    EnvironmentTransform.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'EnvironmentTransform\\',\\n\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        this.getOutput().getVariable() + \\' = environmentTransform(\\' + this._environmentTransform.getVariable() + \\', \\' + this._direction.getVariable() + \\');\\'\\n                      ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'vec3 environmentTransform(const in mat4 transform, const in vec3 direction)\\',\\n                \\'{\\',\\n                \\'  // it s done manually instead of mat3(transform) because of bug in some\\',\\n                \\'  // mobile driver\\',\\n                \\'  vec3 x = vec3(transform[0][0], transform[1][0], transform[2][0]);\\',\\n                \\'  vec3 y = vec3(transform[0][1], transform[1][1], transform[2][1]);\\',\\n                \\'  vec3 z = vec3(transform[0][2], transform[1][2], transform[2][2]);\\',\\n                \\'  mat3 m = mat3(x,y,z);\\',\\n                \\'  return m*direction;\\',\\n                \\'  //return direction*mat3(transform);\\',\\n                \\'}\\',\\n                \\'\\' ].join( \\'\\\\n\\' );\\n        }\\n    } );\\n\\n\\n    var Bumpmap = function ( tangent, normal, gradient, output ) {\\n        Node.call( this, tangent, normal, gradient );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n    };\\n    Bumpmap.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'Bumpmap\\',\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = bump_map(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._inputs[ 1 ].getVariable() + \\', \\' + this._inputs[ 2 ].getVariable() + \\');\\';\\n        },\\n        globalFunctionDeclaration: function () {\\n            var str = [\\n                \\'\\',\\n                \\'vec3 bump_map(const in vec4 tangent, const in vec3 normal, const in vec2 gradient) {\\',\\n                \\'vec3 outnormal;\\',\\n                \\'if (length(tangent.xyz) != 0.0) {\\',\\n                \\'\\tvec3 tang =  normalize(tangent.xyz);\\',\\n                \\'\\tvec3 binormal = tangent.w * cross(normal, tang);\\',\\n                \\'\\toutnormal = normal + gradient.x * tang + gradient.y * binormal;\\',\\n                \\'}\\',\\n                \\'else{\\',\\n                \\'\\toutnormal = vec3(normal.x + gradient.x, normal.y + gradient.y, normal.z);\\',\\n                \\'}\\',\\n                \\'return normalize(outnormal);\\',\\n                \\'}\\'\\n            ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var TonemapHDR = function ( input, parameters, output ) {\\n        Node.call( this, input );\\n        this.connectInputs( parameters );\\n        this._parameters = parameters;\\n        this.connectOutput( output );\\n    };\\n    TonemapHDR.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'TonemapHDR\\',\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = tonemapHDR(\\' + this._inputs[ 0 ].getVariable() +\\');\\';\\n        },\\n        globalFunctionDeclaration: function () {\\n            var str = [\\n                \\'vec3 tonemapHDR(const in vec3 hdr) {\\',\\n                \\'  float e = 1.0;\\',\\n                \\'  return hdr * e;\\',\\n                \\'}\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var NormalMatcap = function ( input, output ) {\\n        Node.call( this, input );\\n        this.connectOutput( output );\\n    };\\n    NormalMatcap.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'NormalMatcap\\',\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = normalMatcap(\\' + this._inputs[ 0 ].getVariable() +\\');\\';\\n        },\\n        globalFunctionDeclaration: function () {\\n            var str = [\\n                \\'vec2 normalMatcap(const in vec3 normal) {\\',\\n                \\'vec3 nm_z = normalize(-FragEyeVector);\\',\\n                \\'vec3 nm_x = cross(nm_z, vec3(0.0, 1.0, 0.0));\\',\\n                \\'vec3 nm_y = cross(nm_x, nm_z);\\',\\n                \\'vec3 nTrans = normalize(normal);\\',\\n                \\'vec3 coord = vec3(dot(nTrans, nm_x), dot(nTrans, nm_y), dot(nTrans, nm_z));\\',\\n                \\'vec2 texCoord = vec2( 0.5 * coord.x + 0.5, 0.5 * coord.y + 0.5 );\\',\\n                \\'return texCoord;\\',\\n                \\'}\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    var FrontNormal = function ( input, output ) {\\n        Node.call( this, input );\\n        this.connectOutput( output );\\n    };\\n    FrontNormal.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'FrontNormal\\',\\n        computeFragment: function() {\\n            return this.getOutput().getVariable() + \\' = gl_FrontFacing ? \\' + this._inputs[ 0 ].getVariable() + \\' : -\\' + this._inputs[ 0 ].getVariable() + \\';\\';\\n        },\\n    } );\\n\\n    return {\\n        \\'sRGB2Linear\\': sRGB2Linear,\\n        \\'Linear2sRGB\\': Linear2sRGB,\\n        \\'DotClamp\\': DotClamp,\\n        \\'NormalTangentSpace\\': NormalTangentSpace,\\n        \\'EnvironmentTransform\\': EnvironmentTransform,\\n        \\'TomemapHDR\\': TonemapHDR,\\n        \\'Bumpmap\\': Bumpmap,\\n        \\'NormalizeNormalAndEyeVector\\': NormalizeNormalAndEyeVector,\\n        \\'NormalMatcap\\': NormalMatcap,\\n        \\'FrontNormal\\': FrontNormal\\n    };\\n\\n} );\\n\\n//# sourceURL=/osgShader/shaderNode/functions.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/shaderNode/operations\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n\\n    var Blend = function ( mode, val0, val1, t ) {\\n        Node.call( this, val0, val1, t );\\n        this._mode = mode;\\n    };\\n    Blend.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        computeFragment: function () {\\n            var mode = this._mode;\\n            if ( this[ mode ] === undefined ) {\\n                mode = \\'MIX\\';\\n            }\\n            return this[ mode ]();\\n        },\\n        ADD: function () {\\n            return this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable() + \\' + (\\' + this._inputs[ 1 ].getVariable() + \\' * \\' + this._inputs[ 2 ].getVariable() + \\');\\';\\n        },\\n        MIX: function () {\\n            // result = val0*(1.0-t) + t*val1\\n            return this.getOutput().getVariable() + \\' = mix(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._inputs[ 1 ].getVariable() + \\', \\' + this._inputs[ 2 ].getVariable() + \\');\\';\\n\\n        },\\n\\n        MULTIPLY: function () {\\n            return this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable() + \\' * mix( \\' + this._inputs[ 0 ].getType() + \\'(1.0), \\' + this._inputs[ 1 ].getVariable() + \\', \\' + this._inputs[ 2 ].getVariable() + \\');\\';\\n        }\\n\\n    } );\\n\\n    var AddVector = function () {\\n        Node.apply( this, arguments );\\n    };\\n    AddVector.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'AddVector\\',\\n        computeFragment: function () {\\n            var str = this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable();\\n            for ( var i = 1, l = this._inputs.length; i < l; i++ ) {\\n                str += \\' + \\' + this._inputs[ i ].getVariable();\\n            }\\n            str += \\';\\';\\n            return str;\\n        }\\n    } );\\n\\n\\n    var InlineCode = function () {\\n        Node.apply( this, arguments );\\n    };\\n    InlineCode.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'InlineCode\\',\\n        setCode: function ( txt ) {\\n            this._text = txt;\\n        },\\n        computeFragment: function () {\\n            return this._text;\\n        }\\n    } );\\n\\n\\n\\n\\n    var ReflectionVector = function () {\\n        Node.apply( this, arguments );\\n    };\\n    ReflectionVector.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'ReflectionVector\\',\\n        computeFragment: function () {\\n            var str = \\'  reflection_spec(\\' + this._inputs[ 0 ].getVariable() + \\', \\' + this._inputs[ 1 ].getVariable() + \\', \\' + this.getOutput().getVariable() + \\');\\';\\n            return str;\\n        }\\n    } );\\n\\n    var SetAlpha = function ( color, alpha, output ) {\\n        Node.call( this, color, alpha );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n    };\\n    SetAlpha.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'SetAlpha\\',\\n        computeFragment: function () {\\n            var str = this.getOutput().getVariable() + \\' = vec4(\\' + this._inputs[ 0 ].getVariable() + \\'.rgb, \\' + this._inputs[ 1 ].getVariable() + \\');\\';\\n            return str;\\n        }\\n    } );\\n\\n\\n\\n    var PassValue = function ( input, output ) {\\n        Node.call( this, input );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n    };\\n    PassValue.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable() + \\';\\';\\n        }\\n    } );\\n\\n    var Vec3ToVec4 = function ( input, value, output ) {\\n        Node.call( this, input );\\n        this._lastValue = value;\\n        this.connectOutput( output );\\n    };\\n\\n    Vec3ToVec4.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = vec4(\\' + this._inputs[ 0 ].getVariable() + \\',\\' + this._lastValue.toString() + \\');\\';\\n        }\\n    } );\\n\\n\\n    var DotVector = function () {\\n        Node.apply( this, arguments );\\n    };\\n    DotVector.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        computeFragment: function () {\\n            return this.getOutput().getVariable() + \\' = dot(\\' + this._inputs[ 0 ].getVariable() + \\',\\' + this._inputs[ 1 ].getVariable() + \\');\\';\\n        }\\n    } );\\n\\n\\n    var PreMultAlpha = function ( color, output ) {\\n        Node.call( this, color );\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n    };\\n    PreMultAlpha.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'PreMultAlpha\\',\\n        computeFragment: function () {\\n            var str = this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable() + \\'.rgb * \\' + this._inputs[ 0 ].getVariable() + \\'.a;\\';\\n            return str;\\n        }\\n    } );\\n\\n\\n    var MultVector = function () {\\n        Node.apply( this, arguments );\\n    };\\n    MultVector.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'MultVector\\',\\n        computeFragment: function () {\\n            var str = this.getOutput().getVariable() + \\' = \\' + this._inputs[ 0 ].getVariable();\\n            this._inputs.forEach( function ( element, index /*, array */ ) {\\n                if ( index === 0 ) {\\n                    return;\\n                }\\n                str += \\' * \\' + element.getVariable();\\n            } );\\n            str += \\';\\\\n\\';\\n            return str;\\n        }\\n    } );\\n\\n\\n\\n    var FragColor = function () {\\n        Node.call( this );\\n        this._prefix = \\'gl_FragColor\\';\\n    };\\n    FragColor.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'gl_FragColor\\',\\n        connectOutput: function () { /* do nothing for variable */ },\\n        getVariable: function () {\\n            return this._prefix;\\n        }\\n    } );\\n\\n    return {\\n        \\'Blend\\': Blend,\\n        \\'MultVector\\': MultVector,\\n        \\'AddVector\\': AddVector,\\n        \\'InlineCode\\': InlineCode,\\n        \\'ReflectionVector\\': ReflectionVector,\\n        \\'SetAlpha\\': SetAlpha,\\n        \\'PassValue\\': PassValue,\\n        \\'Vec3ToVec4\\': Vec3ToVec4,\\n        \\'DotVector\\': DotVector,\\n        \\'PreMultAlpha\\': PreMultAlpha,\\n        \\'FragColor\\': FragColor\\n    };\\n\\n});\\n\\n//# sourceURL=/osgShader/shaderNode/operations.js\");\n\n",
    "eval(\"/*global define */\\n/*jshint unused: false */\\n/*jshint loopfunc: true */\\n\\ndefine( \\'osgShader/shaderNode/lights\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/utils/sprintf\\',\\n    \\'osgShader/shaderNode/Node\\',\\n    \\'osgShader/shaderNode/textures\\',\\n    \\'osgShader/shaderNode/operations\\'\\n\\n], function ( MACROUTILS, sprintf, Node, textures, operations ) {\\n\\n\\n    var Light = function ( light ) {\\n        Node.call( this );\\n        this._light = light;\\n    };\\n\\n    Light.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'Light\\',\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'#pragma include \\\"lights.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n\\n        INVERSE_SQUARE: function () {\\n            return this._attenuation.getVariable() + \\' = invSquareFalloff(\\' + this._light.getOrCreateUniforms().distance.getName() + \\' , \\' + this._distance.getVariable() + \\' );\\';\\n        },\\n\\n        INVERSE_LINEAR: function () {\\n            return this._attenuation.getVariable() + \\' = invLinearFalloff(\\' + this._light.getOrCreateUniforms().distance.getName() + \\', \\' + this._distance.getVariable() + \\');\\';\\n        },\\n\\n        SUN: function () {\\n            return \\'computeLightDirection(\\' + this._light.getOrCreateUniforms().position.getName() + \\' , \\' + this._lightVector.getVariable() + \\');\\';\\n        },\\n\\n        POINT: function () {\\n            return \\'computeLightPoint(\\' + this._eyePosition.getVariable() + \\',\\' + this._light.getOrCreateUniforms().position.getName() + \\' , \\' + this._lightVector.getVariable() + \\', \\' + this._distance.getVariable() + \\');\\';\\n        },\\n\\n        // like point light\\n        SPOT: function () {\\n            return \\'computeLightPoint(\\' + this._eyePosition.getVariable() + \\',\\' + this._light.getOrCreateUniforms().position.getName() + \\' , \\' + this._lightVector.getVariable() + \\', \\' + this._distance.getVariable() + \\');\\';\\n        },\\n\\n        init: function ( context ) {\\n            // connect uniforms to this node\\n            this.connectUniforms( context, this._light );\\n\\n            // declare some variable that will be computed here but used outside\\n            var ln = context.Variable( \\'vec3\\' );\\n            ln.comment( \\'light vector output\\' );\\n            this._lightVector = ln;\\n            this.connectOutput( ln );\\n\\n            var att = context.Variable( \\'float\\' );\\n            att.comment( \\'light attenuation output\\' );\\n            this._attenuation = att;\\n            this.connectOutput( att );\\n\\n            var dist = context.Variable( \\'float\\' );\\n            dist.comment( \\'distance from light\\' );\\n            this._distance = dist;\\n\\n            // from outside\\n            this._eyePosition = context.getVariable( \\'FragEyeVector\\' );\\n\\n        },\\n\\n        getOutputLightVector: function () {\\n            return this._lightVector;\\n        },\\n        getOutputAttenuation: function () {\\n            return this._attenuation;\\n        },\\n\\n        computeFragment: function () {\\n            // computeLightPoint(light, lightVectorResult, lightDistance);\\n            var light = this._light;\\n            light.getOrCreateUniforms();\\n\\n            var lightFalloff = \\'\\';\\n            var lightComputation = \\'\\';\\n\\n\\n            // compute light direction and attenuation\\n            if ( this[ light.getLightType() ] === undefined ) {\\n                lightComputation = this.SUN( this.getOutput() );\\n            }\\n            else {\\n                lightComputation = this[ light.getLightType() ]();\\n            }\\n\\n\\n            // no falloff for directionnal light\\n            if ( light.getLightType() !== \\'SUN\\' &&\\n                 light.getLightType() !== \\'HEMI\\' ) {\\n\\n                // fallof with the good type\\n                if ( this[ light.getFalloffType() ] !== undefined ) {\\n                    lightFalloff = this[ light.getFalloffType() ]();\\n                }\\n            }\\n\\n\\n            var str = [\\n                this._attenuation.getVariable() + \\' = 1.0;\\',\\n                this._lightVector.getVariable() + \\' = vec3(0.0);\\',\\n                lightComputation,\\n                lightFalloff,\\n                \\'\\' ].join( \\'\\\\n\\' );\\n\\n            return str;\\n        },\\n        getOrCreateUniforms: function () {\\n            return this._light.getOrCreateUniforms();\\n        }\\n    } );\\n\\n\\n    var Lambert = function ( color, normal, output ) {\\n        Node.call( this );\\n        this._color = color;\\n        this._normal = normal;\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n        this.connectInputs( color, normal );\\n        this._lights = [];\\n    };\\n\\n    Lambert.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'Lambert\\',\\n        connectLights: function ( lights ) {\\n            this._lights = lights;\\n        },\\n        createFragmentShaderGraph: function ( context ) {\\n            var lambertOutput = this.getOutput();\\n\\n            var accumulator = new operations.AddVector();\\n            accumulator.connectOutput( lambertOutput );\\n            accumulator.comment(\\'lambertOutput = ???\\');\\n\\n            // CP: TODO\\n            // lambert node use an light input ( direct )\\n            // the probleme is that an environment is not considered\\n            // as light and maybe it shoul to be used in this kind of node\\n            if ( this._lights.length === 0 ) {\\n                MACROUTILS.error( \\'using Lambert node with no light\\' );\\n            }\\n\\n            for ( var i = 0, l = this._lights.length; i < l; i++ ) {\\n                var nodeLight = this._lights[ i ];\\n\\n                // connect variable to light node\\n                var attenuation = nodeLight.getOutputAttenuation();\\n                var lightVector = nodeLight.getOutputLightVector();\\n\\n                var lightColor = context.getVariable( nodeLight.getOrCreateUniforms().color.name );\\n                var materialColor = this._color;\\n\\n                var lightColorMaterial = context.Variable( \\'vec3\\' );\\n                var normal = this._normal;\\n\\n                // lightColorMaterial = lightColor * materialColor\\n                ( function ( output ) {\\n                    var operator = new operations.MultVector( lightColor, materialColor );\\n                    operator.comment( \\'lambert_color = light_color * material_color\\' );\\n                    operator.connectOutput( output );\\n                } )( lightColorMaterial );\\n\\n\\n                // compute lambert term. term = max( LdotN * attenuation, 0.0)\\n                var term = context.Variable( \\'float\\' );\\n                ( function ( output ) {\\n                    var str = output.getVariable() + \\' = max(\\' + attenuation.getVariable() + \\' * dot(\\' + lightVector.getVariable() + \\', \\' + normal.getVariable() + \\') , 0.0);\\';\\n                    var operator = new operations.InlineCode( attenuation, lightVector, normal );\\n                    operator.comment( \\'lambert_term = max(NdotL*attenuation, 0.0)\\' );\\n                    operator.setCode( str );\\n                    operator.connectOutput( output );\\n                } )( term );\\n\\n                // diffuseOutput = ldotn * lightColorAttenuation\\n                var lightDiffuse = context.Variable( \\'vec3\\' );\\n                ( function ( output ) {\\n                    var operator = new operations.MultVector( term, lightColorMaterial );\\n                    operator.comment( \\'lambert_color_contribution = lambert_color * lambert_term\\' );\\n                    operator.connectOutput( output );\\n                } )( lightDiffuse );\\n\\n                // accumulate light contribution\\n                accumulator.connectInput( lightDiffuse );\\n            }\\n        },\\n        computeFragment: function () {\\n            return \\'\\';\\n        }\\n    } );\\n\\n\\n    var SpheremapReflection = function ( environmentTransform, texture, textureSize, eyeDirection, normal, output ) {\\n        Node.call( this );\\n        this.connectInputs( environmentTransform, texture, textureSize, eyeDirection, normal );\\n        this._sampler = texture;\\n        this._eye = eyeDirection;\\n        this._normal = normal;\\n        this._environmentTransform = environmentTransform;\\n        this._textureSize = textureSize;\\n\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n\\n        this._output = output;\\n    };\\n    SpheremapReflection.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'SpheremapReflection\\',\\n\\n        createFragmentShaderGraph: function ( context ) {\\n            var lambertOutput = this.getOutput();\\n\\n            var reflect = context.Variable( \\'vec3\\' );\\n\\n            // compute the reflection vector\\n            var operator = new operations.InlineCode( this._environmentTransform,\\n                                                      this._eye,\\n                                                      this._normal );\\n            var str = sprintf( \\'%s = computeAndRotateReflectionVector(%s,%s,%s);\\', [ reflect.getVariable(), this._environmentTransform.getVariable(), this._eye.getVariable(), this._normal.getVariable() ] );\\n            operator.setCode( str );\\n            operator.comment( \\'// environment reflection\\' );\\n            operator.connectOutput( reflect );\\n\\n            // get the texture filtered from the refelction vector\\n            var node = new textures.TextureSpheremapHDR( this._sampler, this._textureSize, reflect ).connectOutput( this._output );\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'#pragma include \\\"functions.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n    } );\\n\\n\\n    var CookTorrance = function ( color, normal, hardness, output ) {\\n        Node.call( this );\\n        this._color = color;\\n        this._normal = normal;\\n        this._hardness = hardness;\\n        if ( output !== undefined ) {\\n            this.connectOutput( output );\\n        }\\n        this.connectInputs( color, normal, hardness );\\n        this._lights = [];\\n    };\\n\\n    CookTorrance.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'CookTorrance\\',\\n        connectLights: function ( lights ) {\\n            this._lights = lights;\\n        },\\n        createFragmentShaderGraph: function ( context ) {\\n            var lambertOutput = this.getOutput();\\n\\n            var operator = new operations.AddVector();\\n            operator.connectOutput( lambertOutput );\\n\\n            for ( var i = 0, l = this._lights.length; i < l; i++ ) {\\n                var nodeLight = this._lights[ i ];\\n\\n                // connect variable to light node\\n                var attenuation = nodeLight.getOutputAttenuation();\\n                var lightVector = nodeLight.getOutputLightVector();\\n\\n                var lightColor = context.getVariable( nodeLight.getOrCreateUniforms().color.name );\\n                var materialColor = this._color;\\n                var viewVector = context.getVariable( \\'eyeVector\\' );\\n                var lightColorMaterial = context.Variable( \\'vec3\\' );\\n                var normal = this._normal;\\n                var hardness = this._hardness;\\n\\n                // lightColorMaterial = lightColor * materialColor\\n                ( function ( output ) {\\n                    var operator = new operations.MultVector( lightColor, materialColor );\\n                    operator.comment( \\'cooktorrance_color = light_color * material_color\\' );\\n                    operator.connectOutput( output );\\n                } )( lightColorMaterial );\\n\\n\\n                // compute lambert term. term = max( LdotN * attenuation, 0.0)\\n                var term = context.Variable( \\'float\\' );\\n\\n                ( function ( output ) {\\n                    var str = output.getVariable() + \\' = \\' + attenuation.getVariable() + \\' * specularCookTorrance(\\' + normal.getVariable() + \\', \\' + lightVector.getVariable() + \\', \\' + viewVector.getVariable() + \\', \\' + hardness.getVariable() + \\');\\';\\n                    var operator = new operations.InlineCode( attenuation, lightVector, normal );\\n                    operator.comment( \\'specular_term = attenuation * specularCookTorrance(normal, lightVector, viewVector, hardness)\\' );\\n                    operator.setCode( str );\\n                    operator.connectOutput( output );\\n                } )( term );\\n\\n                // specularOutput = specTerm * lightColorAttenuation\\n                var specularOutput = context.Variable( \\'vec3\\' );\\n                ( function ( output ) {\\n                    var operator = new operations.MultVector( term, lightColorMaterial );\\n                    operator.comment( \\'cooktorrance_color_contribution = cooktorrance_color * cooktorrance_term\\' );\\n                    operator.connectOutput( output );\\n                } )( specularOutput );\\n\\n                // accumulate light contribution\\n                operator.connectInput( specularOutput );\\n            }\\n        },\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'#pragma include \\\"lights.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n        computeFragment: function () {\\n            return \\'\\';\\n        }\\n    });\\n\\n\\n    return {\\n        \\'Light\\': Light,\\n        \\'Lambert\\': Lambert,\\n        \\'SpheremapReflection\\': SpheremapReflection,\\n        \\'CookTorrance\\': CookTorrance\\n    };\\n\\n} );\\n\\n//# sourceURL=/osgShader/shaderNode/lights.js\");\n\n",
    "eval(\"/*global define */\\n/*jshint unused: false*/\\n\\ndefine ( \\'osgShader/ShaderNode\\',[\\n    \\'osgShader/shaderNode/data\\',\\n    \\'osgShader/shaderNode/textures\\',\\n    \\'osgShader/shaderNode/functions\\',\\n    \\'osgShader/shaderNode/lights\\',\\n    \\'osgShader/shaderNode/operations\\'\\n\\n], function ( data, textures, functions, lights, operations ) {\\n\\n    var lib = {};\\n\\n    // use sublib except _ of course\\n    var subnamespace = Array.prototype.slice.call(arguments, 0);\\n\\n    // add all sub component to root level of the lib\\n    subnamespace.forEach( function( component, index ) {\\n        var shaderNodeEntries = Object.keys(component);\\n        shaderNodeEntries.forEach( function( key ) {\\n            var element = component[key];\\n            if ( this[key] !== undefined ) { // if exist throw exception\\n                throw \\'duplicate entry in ShaderNode library\\';\\n            }\\n            this[ key ] = element;\\n        }, this);\\n\\n    }, lib );\\n\\n    return lib;\\n});\\n\\n//# sourceURL=/osgShader/ShaderNode.js\");\n\n",
    "eval(\"/**\\n * @license RequireJS text 2.0.12 Copyright (c) 2010-2014, The Dojo Foundation All Rights Reserved.\\n * Available via the MIT or new BSD license.\\n * see: http://github.com/requirejs/text for details\\n */\\n/*jslint regexp: true */\\n/*global require, XMLHttpRequest, ActiveXObject,\\n  define, window, process, Packages,\\n  java, location, Components, FileUtils */\\n\\ndefine(\\'text\\',[\\'module\\'], function (module) {\\n    \\'use strict\\';\\n\\n    var text, fs, Cc, Ci, xpcIsWindows,\\n        progIds = [\\'Msxml2.XMLHTTP\\', \\'Microsoft.XMLHTTP\\', \\'Msxml2.XMLHTTP.4.0\\'],\\n        xmlRegExp = /^\\\\s*<\\\\?xml(\\\\s)+version=[\\\\\\'\\\\\\\"](\\\\d)*.(\\\\d)*[\\\\\\'\\\\\\\"](\\\\s)*\\\\?>/im,\\n        bodyRegExp = /<body[^>]*>\\\\s*([\\\\s\\\\S]+)\\\\s*<\\\\/body>/im,\\n        hasLocation = typeof location !== \\'undefined\\' && location.href,\\n        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\\\\:/, \\'\\'),\\n        defaultHostName = hasLocation && location.hostname,\\n        defaultPort = hasLocation && (location.port || undefined),\\n        buildMap = {},\\n        masterConfig = (module.config && module.config()) || {};\\n\\n    text = {\\n        version: \\'2.0.12\\',\\n\\n        strip: function (content) {\\n            //Strips <?xml ...?> declarations so that external SVG and XML\\n            //documents can be added to a document without worry. Also, if the string\\n            //is an HTML document, only the part inside the body tag is returned.\\n            if (content) {\\n                content = content.replace(xmlRegExp, \\\"\\\");\\n                var matches = content.match(bodyRegExp);\\n                if (matches) {\\n                    content = matches[1];\\n                }\\n            } else {\\n                content = \\\"\\\";\\n            }\\n            return content;\\n        },\\n\\n        jsEscape: function (content) {\\n            return content.replace(/([\\'\\\\\\\\])/g, \\'\\\\\\\\$1\\')\\n                .replace(/[\\\\f]/g, \\\"\\\\\\\\f\\\")\\n                .replace(/[\\\\b]/g, \\\"\\\\\\\\b\\\")\\n                .replace(/[\\\\n]/g, \\\"\\\\\\\\n\\\")\\n                .replace(/[\\\\t]/g, \\\"\\\\\\\\t\\\")\\n                .replace(/[\\\\r]/g, \\\"\\\\\\\\r\\\")\\n                .replace(/[\\\\u2028]/g, \\\"\\\\\\\\u2028\\\")\\n                .replace(/[\\\\u2029]/g, \\\"\\\\\\\\u2029\\\");\\n        },\\n\\n        createXhr: masterConfig.createXhr || function () {\\n            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.\\n            var xhr, i, progId;\\n            if (typeof XMLHttpRequest !== \\\"undefined\\\") {\\n                return new XMLHttpRequest();\\n            } else if (typeof ActiveXObject !== \\\"undefined\\\") {\\n                for (i = 0; i < 3; i += 1) {\\n                    progId = progIds[i];\\n                    try {\\n                        xhr = new ActiveXObject(progId);\\n                    } catch (e) {}\\n\\n                    if (xhr) {\\n                        progIds = [progId];  // so faster next time\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return xhr;\\n        },\\n\\n        /**\\n         * Parses a resource name into its component parts. Resource names\\n         * look like: module/name.ext!strip, where the !strip part is\\n         * optional.\\n         * @param {String} name the resource name\\n         * @returns {Object} with properties \\\"moduleName\\\", \\\"ext\\\" and \\\"strip\\\"\\n         * where strip is a boolean.\\n         */\\n        parseName: function (name) {\\n            var modName, ext, temp,\\n                strip = false,\\n                index = name.indexOf(\\\".\\\"),\\n                isRelative = name.indexOf(\\'./\\') === 0 ||\\n                             name.indexOf(\\'../\\') === 0;\\n\\n            if (index !== -1 && (!isRelative || index > 1)) {\\n                modName = name.substring(0, index);\\n                ext = name.substring(index + 1, name.length);\\n            } else {\\n                modName = name;\\n            }\\n\\n            temp = ext || modName;\\n            index = temp.indexOf(\\\"!\\\");\\n            if (index !== -1) {\\n                //Pull off the strip arg.\\n                strip = temp.substring(index + 1) === \\\"strip\\\";\\n                temp = temp.substring(0, index);\\n                if (ext) {\\n                    ext = temp;\\n                } else {\\n                    modName = temp;\\n                }\\n            }\\n\\n            return {\\n                moduleName: modName,\\n                ext: ext,\\n                strip: strip\\n            };\\n        },\\n\\n        xdRegExp: /^((\\\\w+)\\\\:)?\\\\/\\\\/([^\\\\/\\\\\\\\]+)/,\\n\\n        /**\\n         * Is an URL on another domain. Only works for browser use, returns\\n         * false in non-browser environments. Only used to know if an\\n         * optimized .js version of a text resource should be loaded\\n         * instead.\\n         * @param {String} url\\n         * @returns Boolean\\n         */\\n        useXhr: function (url, protocol, hostname, port) {\\n            var uProtocol, uHostName, uPort,\\n                match = text.xdRegExp.exec(url);\\n            if (!match) {\\n                return true;\\n            }\\n            uProtocol = match[2];\\n            uHostName = match[3];\\n\\n            uHostName = uHostName.split(\\':\\');\\n            uPort = uHostName[1];\\n            uHostName = uHostName[0];\\n\\n            return (!uProtocol || uProtocol === protocol) &&\\n                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&\\n                   ((!uPort && !uHostName) || uPort === port);\\n        },\\n\\n        finishLoad: function (name, strip, content, onLoad) {\\n            content = strip ? text.strip(content) : content;\\n            if (masterConfig.isBuild) {\\n                buildMap[name] = content;\\n            }\\n            onLoad(content);\\n        },\\n\\n        load: function (name, req, onLoad, config) {\\n            //Name has format: some.module.filext!strip\\n            //The strip part is optional.\\n            //if strip is present, then that means only get the string contents\\n            //inside a body tag in an HTML string. For XML/SVG content it means\\n            //removing the <?xml ...?> declarations so the content can be inserted\\n            //into the current doc without problems.\\n\\n            // Do not bother with the work if a build and text will\\n            // not be inlined.\\n            if (config && config.isBuild && !config.inlineText) {\\n                onLoad();\\n                return;\\n            }\\n\\n            masterConfig.isBuild = config && config.isBuild;\\n\\n            var parsed = text.parseName(name),\\n                nonStripName = parsed.moduleName +\\n                    (parsed.ext ? \\'.\\' + parsed.ext : \\'\\'),\\n                url = req.toUrl(nonStripName),\\n                useXhr = (masterConfig.useXhr) ||\\n                         text.useXhr;\\n\\n            // Do not load if it is an empty: url\\n            if (url.indexOf(\\'empty:\\') === 0) {\\n                onLoad();\\n                return;\\n            }\\n\\n            //Load the text. Use XHR if possible and in a browser.\\n            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {\\n                text.get(url, function (content) {\\n                    text.finishLoad(name, parsed.strip, content, onLoad);\\n                }, function (err) {\\n                    if (onLoad.error) {\\n                        onLoad.error(err);\\n                    }\\n                });\\n            } else {\\n                //Need to fetch the resource across domains. Assume\\n                //the resource has been optimized into a JS module. Fetch\\n                //by the module name + extension, but do not include the\\n                //!strip part to avoid file system issues.\\n                req([nonStripName], function (content) {\\n                    text.finishLoad(parsed.moduleName + \\'.\\' + parsed.ext,\\n                                    parsed.strip, content, onLoad);\\n                });\\n            }\\n        },\\n\\n        write: function (pluginName, moduleName, write, config) {\\n            if (buildMap.hasOwnProperty(moduleName)) {\\n                var content = text.jsEscape(buildMap[moduleName]);\\n                write.asModule(pluginName + \\\"!\\\" + moduleName,\\n                               \\\"define(function () { return \\'\\\" +\\n                                   content +\\n                               \\\"\\';});\\\\n\\\");\\n            }\\n        },\\n\\n        writeFile: function (pluginName, moduleName, req, write, config) {\\n            var parsed = text.parseName(moduleName),\\n                extPart = parsed.ext ? \\'.\\' + parsed.ext : \\'\\',\\n                nonStripName = parsed.moduleName + extPart,\\n                //Use a \\'.js\\' file name so that it indicates it is a\\n                //script that can be loaded across domains.\\n                fileName = req.toUrl(parsed.moduleName + extPart) + \\'.js\\';\\n\\n            //Leverage own load() method to load plugin value, but only\\n            //write out values that do not have the strip argument,\\n            //to avoid any potential issues with ! in file names.\\n            text.load(nonStripName, req, function (value) {\\n                //Use own write() method to construct full module value.\\n                //But need to create shell that translates writeFile\\'s\\n                //write() to the right interface.\\n                var textWrite = function (contents) {\\n                    return write(fileName, contents);\\n                };\\n                textWrite.asModule = function (moduleName, contents) {\\n                    return write.asModule(moduleName, fileName, contents);\\n                };\\n\\n                text.write(pluginName, nonStripName, textWrite, config);\\n            }, config);\\n        }\\n    };\\n\\n    if (masterConfig.env === \\'node\\' || (!masterConfig.env &&\\n            typeof process !== \\\"undefined\\\" &&\\n            process.versions &&\\n            !!process.versions.node &&\\n            !process.versions[\\'node-webkit\\'])) {\\n        //Using special require.nodeRequire, something added by r.js.\\n        fs = require.nodeRequire(\\'fs\\');\\n\\n        text.get = function (url, callback, errback) {\\n            try {\\n                var file = fs.readFileSync(url, \\'utf8\\');\\n                //Remove BOM (Byte Mark Order) from utf8 files if it is there.\\n                if (file.indexOf(\\'\\\\uFEFF\\') === 0) {\\n                    file = file.substring(1);\\n                }\\n                callback(file);\\n            } catch (e) {\\n                if (errback) {\\n                    errback(e);\\n                }\\n            }\\n        };\\n    } else if (masterConfig.env === \\'xhr\\' || (!masterConfig.env &&\\n            text.createXhr())) {\\n        text.get = function (url, callback, errback, headers) {\\n            var xhr = text.createXhr(), header;\\n            xhr.open(\\'GET\\', url, true);\\n\\n            //Allow plugins direct access to xhr headers\\n            if (headers) {\\n                for (header in headers) {\\n                    if (headers.hasOwnProperty(header)) {\\n                        xhr.setRequestHeader(header.toLowerCase(), headers[header]);\\n                    }\\n                }\\n            }\\n\\n            //Allow overrides specified in config\\n            if (masterConfig.onXhr) {\\n                masterConfig.onXhr(xhr, url);\\n            }\\n\\n            xhr.onreadystatechange = function (evt) {\\n                var status, err;\\n                //Do not explicitly handle errors, those should be\\n                //visible via console output in the browser.\\n                if (xhr.readyState === 4) {\\n                    status = xhr.status || 0;\\n                    if (status > 399 && status < 600) {\\n                        //An http 4xx or 5xx error. Signal an error.\\n                        err = new Error(url + \\' HTTP status: \\' + status);\\n                        err.xhr = xhr;\\n                        if (errback) {\\n                            errback(err);\\n                        }\\n                    } else {\\n                        callback(xhr.responseText);\\n                    }\\n\\n                    if (masterConfig.onXhrComplete) {\\n                        masterConfig.onXhrComplete(xhr, url);\\n                    }\\n                }\\n            };\\n            xhr.send(null);\\n        };\\n    } else if (masterConfig.env === \\'rhino\\' || (!masterConfig.env &&\\n            typeof Packages !== \\'undefined\\' && typeof java !== \\'undefined\\')) {\\n        //Why Java, why is this so awkward?\\n        text.get = function (url, callback) {\\n            var stringBuffer, line,\\n                encoding = \\\"utf-8\\\",\\n                file = new java.io.File(url),\\n                lineSeparator = java.lang.System.getProperty(\\\"line.separator\\\"),\\n                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),\\n                content = \\'\\';\\n            try {\\n                stringBuffer = new java.lang.StringBuffer();\\n                line = input.readLine();\\n\\n                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324\\n                // http://www.unicode.org/faq/utf_bom.html\\n\\n                // Note that when we use utf-8, the BOM should appear as \\\"EF BB BF\\\", but it doesn\\'t due to this bug in the JDK:\\n                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058\\n                if (line && line.length() && line.charAt(0) === 0xfeff) {\\n                    // Eat the BOM, since we\\'ve already found the encoding on this file,\\n                    // and we plan to concatenating this buffer with others; the BOM should\\n                    // only appear at the top of a file.\\n                    line = line.substring(1);\\n                }\\n\\n                if (line !== null) {\\n                    stringBuffer.append(line);\\n                }\\n\\n                while ((line = input.readLine()) !== null) {\\n                    stringBuffer.append(lineSeparator);\\n                    stringBuffer.append(line);\\n                }\\n                //Make sure we return a JavaScript string and not a Java string.\\n                content = String(stringBuffer.toString()); //String\\n            } finally {\\n                input.close();\\n            }\\n            callback(content);\\n        };\\n    } else if (masterConfig.env === \\'xpconnect\\' || (!masterConfig.env &&\\n            typeof Components !== \\'undefined\\' && Components.classes &&\\n            Components.interfaces)) {\\n        //Avert your gaze!\\n        Cc = Components.classes;\\n        Ci = Components.interfaces;\\n        Components.utils[\\'import\\'](\\'resource://gre/modules/FileUtils.jsm\\');\\n        xpcIsWindows = (\\'@mozilla.org/windows-registry-key;1\\' in Cc);\\n\\n        text.get = function (url, callback) {\\n            var inStream, convertStream, fileObj,\\n                readData = {};\\n\\n            if (xpcIsWindows) {\\n                url = url.replace(/\\\\//g, \\'\\\\\\\\\\');\\n            }\\n\\n            fileObj = new FileUtils.File(url);\\n\\n            //XPCOM, you so crazy\\n            try {\\n                inStream = Cc[\\'@mozilla.org/network/file-input-stream;1\\']\\n                           .createInstance(Ci.nsIFileInputStream);\\n                inStream.init(fileObj, 1, 0, false);\\n\\n                convertStream = Cc[\\'@mozilla.org/intl/converter-input-stream;1\\']\\n                                .createInstance(Ci.nsIConverterInputStream);\\n                convertStream.init(inStream, \\\"utf-8\\\", inStream.available(),\\n                Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\\n\\n                convertStream.readString(inStream.available(), readData);\\n                convertStream.close();\\n                inStream.close();\\n                callback(readData.value);\\n            } catch (e) {\\n                throw new Error((fileObj && fileObj.path || \\'\\') + \\': \\' + e);\\n            }\\n        };\\n    }\\n    return text;\\n});\\n//# sourceURL=/vendors/require/text.js\");\n\n",
    "\neval(\"define(\\'text!osgShader/shaderNode/functions.glsl\\',[],function () { return \\'// -*-c-*-\\\\n\\\\n#define DefaultGamma 2.4\\\\n\\\\n// deprecated prefer the version at the beginning of the file\\\\nfloat srgb_to_linearrgb1(const in float c, const in float gamma)\\\\n{\\\\n    float v = 0.0;\\\\n    if ( c < 0.04045 ) {\\\\n        if ( c >= 0.0 )\\\\n            v = c * ( 1.0 / 12.92 );\\\\n    } else {\\\\n        v = pow( ( c + 0.055 ) * ( 1.0 / 1.055 ), gamma );\\\\n    }\\\\n    return v;\\\\n}\\\\nvec4 srgb2linearrgb_vec4(const in vec4 col_from)\\\\n{\\\\n    vec4 col_to;\\\\n    col_to.r = srgb_to_linearrgb1(col_from.r, DefaultGamma);\\\\n    col_to.g = srgb_to_linearrgb1(col_from.g, DefaultGamma);\\\\n    col_to.b = srgb_to_linearrgb1(col_from.b, DefaultGamma);\\\\n    col_to.a = col_from.a;\\\\n    return col_to;\\\\n}\\\\nvec3 srgb2linearrgb_vec3(const in vec3 col_from)\\\\n{\\\\n    vec3 col_to;\\\\n    col_to.r = srgb_to_linearrgb1(col_from.r, DefaultGamma);\\\\n    col_to.g = srgb_to_linearrgb1(col_from.g, DefaultGamma);\\\\n    col_to.b = srgb_to_linearrgb1(col_from.b, DefaultGamma);\\\\n    return col_to;\\\\n}\\\\nfloat linearrgb_to_srgb1(const in float c, const in float gamma)\\\\n{\\\\n    float v = 0.0;\\\\n    if(c < 0.0031308) {\\\\n        if ( c > 0.0)\\\\n            v = c * 12.92;\\\\n    } else {\\\\n        v = 1.055 * pow(c, 1.0/ gamma) - 0.055;\\\\n    }\\\\n    return v;\\\\n}\\\\n\\\\nvec3 linearrgb2srgb_vec3(const in vec3 col_from, const in float gamma)\\\\n{\\\\n    vec3 col_to;\\\\n    col_to.r = linearrgb_to_srgb1(col_from.r, gamma);\\\\n    col_to.g = linearrgb_to_srgb1(col_from.g, gamma);\\\\n    col_to.b = linearrgb_to_srgb1(col_from.b, gamma);\\\\n    return col_to;\\\\n}\\\\n\\\\nvec4 linearrgb2srgb_vec4(const in vec4 col_from, const in float gamma)\\\\n{\\\\n    vec4 col_to;\\\\n    col_to.r = linearrgb_to_srgb1(col_from.r, gamma);\\\\n    col_to.g = linearrgb_to_srgb1(col_from.g, gamma);\\\\n    col_to.b = linearrgb_to_srgb1(col_from.b, gamma);\\\\n    col_to.a = col_from.a;\\\\n    return col_to;\\\\n}\\\\n\\\\n\\\\nvoid mtex_nspace_tangent(const in vec4 tangent, const in vec3 normal, const in vec3 texnormal, out vec3 outnormal)\\\\n{\\\\n    vec3 tang = vec3(0.0,1.0,0.0);\\\\n    if (length(tangent.xyz) != 0.0) {\\\\n        tang = normalize(tangent.xyz);\\\\n    }\\\\n    vec3 B = tangent.w * cross(normal, tang);\\\\n    outnormal = texnormal.x*tang + texnormal.y*B + texnormal.z*normal;\\\\n    outnormal = normalize(outnormal);\\\\n}\\\\n\\\\n\\\\nvec2 normalToSphericalUV( const in vec3 n )\\\\n{\\\\n    float PI = 3.14159265358979323846264;\\\\n    float EPS = 1e-5;\\\\n\\\\n    // acos is defined [ -1: 1 ]\\\\n    // atan( x , y ) require to have |y| > 0\\\\n\\\\n    // when n.y is amlost 1.0 it means that the normal is aligned on axis y\\\\n    // so instead of fixing numerical issue we can directly return the supposed\\\\n    // uv value\\\\n    if ( n.y > (1.0-EPS) ) {\\\\n        return vec2( 0.5, 0.0);\\\\n    } else if ( n.y < -(1.0-EPS) ) {\\\\n        return vec2( 1.0, 1.0);\\\\n    }\\\\n\\\\n    float yaw = acos(n.y) / PI;\\\\n    float pitch;\\\\n    float y = n.z;\\\\n    if ( abs( y ) < EPS )\\\\n        y = EPS;\\\\n    pitch = ( atan(n.x, y) + PI) / (2.0 * PI);\\\\n\\\\n    return vec2( pitch, yaw );\\\\n}\\\\n\\\\nvec3 computeAndRotateReflectionVector(const in mat4 transform, const in vec3 view, const in vec3 normal)\\\\n{\\\\n    vec3 lv = reflect(-view, normal);\\\\n    lv = normalize(lv);\\\\n    vec3 x = vec3(transform[0][0], transform[1][0], transform[2][0]);\\\\n    vec3 y = vec3(transform[0][1], transform[1][1], transform[2][1]);\\\\n    vec3 z = vec3(transform[0][2], transform[1][2], transform[2][2]);\\\\n    mat3 m = mat3(x,y,z);\\\\n    return m*lv;\\\\n}\\\\n\\\\n// coding style should be camel case except for acronyme like SRGB or HDR\\\\nvec4 linearTosRGB(const in vec4 col_from, const in float gamma)\\\\n{\\\\n    vec4 col_to;\\\\n    col_to.r = linearrgb_to_srgb1(col_from.r, gamma);\\\\n    col_to.g = linearrgb_to_srgb1(col_from.g, gamma);\\\\n    col_to.b = linearrgb_to_srgb1(col_from.b, gamma);\\\\n    col_to.a = col_from.a;\\\\n    return col_to;\\\\n}\\\\n\\\\nfloat sRGBToLinear(const in float c, const in float gamma)\\\\n{\\\\n    float v = 0.0;\\\\n    if ( c < 0.04045 ) {\\\\n        if ( c >= 0.0 )\\\\n            v = c * ( 1.0 / 12.92 );\\\\n    } else {\\\\n        v = pow( ( c + 0.055 ) * ( 1.0 / 1.055 ), gamma );\\\\n    }\\\\n    return v;\\\\n}\\\\nvec4 sRGBToLinear(const in vec4 col_from, const in float gamma)\\\\n{\\\\n    vec4 col_to;\\\\n    col_to.r = sRGBToLinear(col_from.r, gamma);\\\\n    col_to.g = sRGBToLinear(col_from.g, gamma);\\\\n    col_to.b = sRGBToLinear(col_from.b, gamma);\\\\n    col_to.a = col_from.a;\\\\n    return col_to;\\\\n}\\\\nvec3 sRGBToLinear(const in vec3 col_from, const in float gamma)\\\\n{\\\\n    vec3 col_to;\\\\n    col_to.r = sRGBToLinear(col_from.r, gamma);\\\\n    col_to.g = sRGBToLinear(col_from.g, gamma);\\\\n    col_to.b = sRGBToLinear(col_from.b, gamma);\\\\n    return col_to;\\\\n}\\\\n\\';});\\n\\n//# sourceURL=/text!osgShader/shaderNode/functions.glsl\");\n\n",
    "\neval(\"define(\\'text!osgShader/shaderNode/lights.glsl\\',[],function () { return \\'// -*-c-*-\\\\n\\\\nfloat invSquareFalloff(const in float lampdist, const in float dist)\\\\n{\\\\n    return lampdist/(lampdist + dist*dist);\\\\n}\\\\nfloat invLinearFalloff(const in float lampdist, const in float dist)\\\\n{\\\\n    return lampdist/(lampdist + dist);\\\\n}\\\\n\\\\nvoid computeLightDirection(const in vec3 lampvec, out vec3 lv )\\\\n{\\\\n    lv = -lampvec;\\\\n}\\\\n\\\\nvoid computeLightPoint(const in vec3 vertexPosition, const in vec3 lampPosition, out vec3 lightVector, out float dist)\\\\n{\\\\n    lightVector = lampPosition-vertexPosition;\\\\n    dist = length(lightVector);\\\\n    lightVector = normalize(lightVector);\\\\n}\\\\n\\\\nfloat specularCookTorrance(const in vec3 n, const in vec3 l, const in vec3 v, const in float hard)\\\\n{\\\\n    vec3 h = normalize(v + l);\\\\n    float nh = dot(n, h);\\\\n    float specfac = 0.0;\\\\n\\\\n    if(nh > 0.0) {\\\\n        float nv = max(dot(n, v), 0.0);\\\\n        float i = pow(nh, hard);\\\\n\\\\n        i = i/(0.1+nv);\\\\n        specfac = i;\\\\n    }\\\\n    return specfac;\\\\n}\\\\n\\';});\\n\\n//# sourceURL=/text!osgShader/shaderNode/lights.glsl\");\n\n",
    "\neval(\"define(\\'text!osgShader/shaderNode/textures.glsl\\',[],function () { return \\'// -*-c-*-\\\\n#pragma include \\\"functions.glsl\\\"\\\\n\\\\nvec4 textureSpheremap(const in sampler2D texture, const in vec3 normal) {\\\\n    vec2 uv = normalToSphericalUV( normal );\\\\n    return texture2D(texture, uv.xy );\\\\n}\\\\n\\\\nvec3 textureCubemapRGB(const in samplerCube texture, const in vec3 uv) {\\\\n    return textureCube(texture, uv).rgb;\\\\n}\\\\n\\\\nvec4 textureHDR(const in sampler2D texture, const in vec2 size, const in vec2 uv) {\\\\n    vec4 rgbe = texture2D(texture, floor(uv * size) / size);\\\\n    float f = pow(2.0, rgbe.w * 255.0 - (128.0 + 8.0));\\\\n    return vec4(rgbe.rgb * 255.0 * f, 1.0);\\\\n}\\\\n\\\\nvec4 textureHDRLinear(const in sampler2D texture, const in vec2 size, const in vec2 uv) {\\\\n    vec2 textureSize = vec2(256.0, 128.0);\\\\n    vec2 t = 1.0 / size;\\\\n    vec4 a = textureHDR(texture, size, uv + vec2(0.0, 0.0)),\\\\n        b = textureHDR(texture, size, uv + vec2(t.x, 0.0)),\\\\n        c = textureHDR(texture, size, uv + vec2(0.0, t.y)),\\\\n        d = textureHDR(texture, size, uv + vec2(t.x, t.y));\\\\n    vec2 f = fract(uv * size);\\\\n    vec4 A = mix(a, b, f.x),\\\\n        B = mix(c, d, f.x);\\\\n    return mix(A, B, f.y);\\\\n}\\\\n\\\\nvec3 textureSpheremapHDR(const in sampler2D texture, const in vec2 size, const in vec3 normal) {\\\\n    vec2 uv = normalToSphericalUV( normal );\\\\n    return textureHDRLinear(texture, size, uv.xy ).rgb;\\\\n}\\\\n\\\\nfloat textureIntensity(const in sampler2D texture, const in vec2 uv) {\\\\n    vec3 rgb = texture2D(texture, uv).rgb;\\\\n    return dot(rgb,vec3(1.0/3.0));\\\\n}\\\\n\\\\nvec3 textureNormal(in sampler2D texture, const in vec2 uv) {\\\\n    vec3 rgb = texture2D(texture, uv).rgb;\\\\n    return normalize((2.0*rgb-vec3(1.0)));\\\\n}\\\\n\\\\nvec2 textureGradient(in sampler2D texture, const in vec2 uv, const in vec2 size) {\\\\n    vec2 step = 1.0 / size;\\\\n    float dx = texture2D(texture, uv - vec2(step.x, 0.0)).r - texture2D(texture, uv + vec2(step.x, 0.0)).r;\\\\n    float dy = texture2D(texture, uv - vec2(0.0, step.y)).r - texture2D(texture, uv + vec2(0.0, step.y)).r;\\\\n    return vec2(dx, dy);\\\\n}\\\\n\\';});\\n\\n//# sourceURL=/text!osgShader/shaderNode/textures.glsl\");\n\n",
    "eval(\"define( \\'osgShader/ShaderLib\\',[\\n    \\'text!osgShader/shaderNode/functions.glsl\\',\\n    \\'text!osgShader/shaderNode/lights.glsl\\',\\n    //\\'text!osgShader/shaderNode/operations.glsl\\',\\n    \\'text!osgShader/shaderNode/textures.glsl\\'\\n], function ( functions, lights, textures ) {\\n\\n    return {\\n        \\'functions.glsl\\': functions,\\n        \\'lights.glsl\\': lights,\\n        //\\'operations.glsl\\': operations,\\n        \\'textures.glsl\\': textures,\\n        \\'prefix\\': \\'osgShader/shaderNode/\\'\\n    };\\n});\\n\\n//# sourceURL=/osgShader/ShaderLib.js\");\n\n",
    "eval(\"/*global define,require */\\n\\ndefine( \\'osgShader/ShaderProcessor\\',[\\n    \\'osg/Notify\\',\\n    \\'osgShader/ShaderLib\\'\\n\\n], function ( Notify, shaderLib ) {\\n\\n    var shaderPrefix = shaderLib.prefix;\\n\\n    //     Manage External Load Shader\\n    //     Or storage as json inside code\\n    //     (like concatened from shader file\\n    //     to json using a build tool like grunt)\\n    //     TODO: tests load/reload shaders for realtime editing.\\n    //\\n    //     Idea is to be able to edit shader in separate files than js, getting readable code, and avoid string/shader duplication in code, resulting in min code.\\n    //     Handle loading shader files using ajax,json,jsonp or  even inline, with a grunt dir2json task that will generate according files.\\n    //     Handle (recursive) include, avoiding code repeat and help code factorization\\n    //     Handle per shader and global define (upon extension supported, hw capabilites (\\\"highp precision\\\") or shader usage (\\\"LAMBERT or BLINN_PHONG\\\").)\\n    //     Possible afterward Todo list:\\n    //     use glsl optimizer on shaders\\n    //     use glsl minimizer on shaders.\\n    /**\\n     * @class ShaderLoader\\n     */\\n\\n    var getParametersURL = function () {\\n        var vars = [], hash;\\n        if ( typeof window !== \\'undefined\\' ){\\n            var hashes = window.location.href.slice( window.location.href.indexOf( \\'?\\' ) + 1 ).split( \\'&\\' );\\n            for( var i = 0; i < hashes.length; i++ )\\n            {\\n                hash = hashes[i].split( \\'=\\' );\\n                var element = hash[0].toLowerCase();\\n                vars.push(element);\\n                var result = hash[1];\\n                if ( result === undefined ) {\\n                    result = \\'1\\';\\n                }\\n                var val = parseFloat( result );\\n                if ( !isNaN( val ) )\\n                    vars[ element ] = val;\\n                else\\n                    vars[ element ] = result.toLowerCase();\\n            }\\n        }\\n        return vars;\\n    };\\n\\n    var ShaderLoader = function ( opt ) {\\n        var options = opt;\\n        if ( !options ) {\\n            options = {\\n                inline: getParametersURL()[ \\'debug\\' ] ? false : true,\\n                callbacksingle: function ( file ) {\\n                    window.dbg.viewer.log( file + \\'is loaded\\' );\\n                },\\n                libs: [ {\\n                    loadprefix:  shaderPrefix,\\n                    shaders: shaderLib\\n                } ]\\n            };\\n        }\\n        this.init( options );\\n    };\\n\\n    /** @lends osg.ShaderLoader.prototype */\\n    ShaderLoader.prototype = {\\n        _shadersText: {},\\n        _shadersList: {},\\n        _shaderLoaded: {},\\n        _loaded: false,\\n        _callbackSingle: false,\\n        _numtoLoad: 0,\\n        _globalDefaultDefines: \\'\\',\\n        _globalDefaultprecision: \\'#ifdef GL_FRAGMENT_PRECISION_HIGH\\\\n precision highp float;\\\\n #else\\\\n precision mediump float;\\\\n#endif\\',\\n        _debugLines: false,\\n        _includeR: /#pragma include \\\"([^\\\"]+)\\\"/g,\\n        _defineR: /#define\\\\s+([a-zA-Z_0-9]+)\\\\s+(.*)/,\\n        _precisionR: /precision\\\\s+(high|low|medium)p\\\\s+float/,\\n\\n\\n        initShaderLib: function ( lib, inline ) {\\n\\n            if ( !lib.loadprefix ) lib.loadprefix = \\'\\';\\n            var i;\\n            for ( i in lib.shaders ) {\\n                if ( lib.shaders.hasOwnProperty( i ) ) {\\n                    this._numtoLoad++;\\n                }\\n            }\\n            if ( !inline ) {\\n                for ( i in lib.shaders ) {\\n                    if ( lib.shaders.hasOwnProperty( i ) ) {\\n                        this._shadersList[ i ] = lib.loadprefix + i;\\n                    }\\n                }\\n                this._loaded = false;\\n\\n            } else {\\n                for ( i in lib.shaders ) {\\n                    if ( lib.shaders.hasOwnProperty( i ) ) {\\n                        this._shadersList[ i ] = i;\\n                        this._shadersText[ i ] = lib.shaders[ i ];\\n                        if ( this._callbackSingle ) this._callbackSingle( i );\\n                        this._numtoLoad--;\\n                    }\\n                }\\n                this._loaded = true;\\n\\n                Notify.assert( this._numtoLoad === 0 );\\n            }\\n\\n        },\\n\\n        init: function(options) {\\n\\n            this._callbackSingle = options.callbackSingle;\\n            this._numtoLoad = 0;\\n\\n            if ( options.libs ) {\\n                options.libs.forEach( function( lib ) {\\n                    this.initShaderLib( lib, options.inline );\\n                }, this );\\n            }\\n\\n            return this;\\n/*\\n            if ( !options.loadprefix ) options.loadprefix = \\'\\';\\n            var i;\\n            for ( i in options.shaders ) {\\n                if ( options.shaders.hasOwnProperty( i ) ) {\\n                    this._numtoLoad++;\\n                }\\n            }\\n            if ( !options.inline ) {\\n                for ( i in options.shaders ) {\\n                    if ( options.shaders.hasOwnProperty( i ) ) {\\n                        this._shadersList[ i ] = options.loadprefix + i;\\n                    }\\n                }\\n                this._loaded = false;\\n\\n            } else {\\n                for ( i in options.shaders ) {\\n                    if ( options.shaders.hasOwnProperty( i ) ) {\\n                        this._shadersList[ i ] = i;\\n                        this._shadersText[ i ] = options.shaders[ i ];\\n                        if ( this._callbackSingle ) this._callbackSingle( i );\\n                        this._numtoLoad--;\\n                    }\\n                }\\n                this._loaded = true;\\n\\n                Notify.assert( this._numtoLoad === 0 );\\n            }\\n            return this;\\n            */\\n        },\\n        load: function( shaderFilename, shaderName, callbackSingle ) {\\n\\n            if ( !this._shadersList[ shaderName ] )\\n                this._shadersList[ shaderName ] = shaderFilename;\\n\\n            // require the shader\\n            require( [ \\'text!\\'+shaderFilename ], function ( content ) {\\n\\n                this._shadersText[ shaderName ] = content;\\n                if ( this._callbackSingle ) this._callbackSingle();\\n                this._numtoLoad--;\\n\\n            }.bind( this ) );\\n\\n            if ( callbackSingle )\\n                this._callbackSingle = callbackSingle;\\n\\n            return this;\\n        },\\n\\n        loadAll: function ( options ) {\\n            if ( this._numtoLoad > 0 ) {\\n\\n                Object.keys( this._shadersList ).forEach( function( shader ) {\\n                    var shaderPath = this._shadersList[ shader ];\\n                    this.load( shaderPath, shader, options && options.callbackSingle );\\n                }, this );\\n\\n            }\\n            return this;\\n        },\\n\\n        reloadAll: function ( options ) {\\n            this._shaderLoaded = {};\\n            this._loaded = false;\\n            this._numtoLoad = 0;\\n\\n            Object.keys( this._shadersList ).forEach( function( shader ) {\\n                // unload from require\\n                require.undef( \\'vendors/require/text!\\'+ shader );\\n                this._numtoLoad++;\\n\\n            }, this );\\n\\n            this.loadAll( options );\\n            return this;\\n        },\\n\\n        reload: function ( options ) {\\n            this._shaderLoaded[ options.shaderName ] = undefined;\\n            this._loaded = false;\\n            this._numtoLoad = 1;\\n\\n            // unload from require\\n            var shaderPath = this._shadersList[ options.shaderName ];\\n            require.undef( \\'vendors/require/text!\\' + shaderPath );\\n\\n            this.load( this._shaders[ options.shaderName ], options && options.shaderName, options && options.callbackSingle );\\n            return this;\\n        },\\n\\n        instrumentShaderlines: function ( content, sourceID ) {\\n            // TODO instrumentShaderlines\\n            // http://immersedcode.org/2012/1/12/random-notes-on-webgl/\\n            // one ID per \\\"file\\\"\\n            // Each file has its line number starting at 0\\n            //   handle include, the do that numbering also in preprocess...\\n            // Then on shader error using sourceID and line you can point the correct line...\\n            // has to attach that info to osg.shader object.\\n            /*\\n              var allLines = content.split(\\'\\\\n\\');\\n              var i = 0;\\n              for (var k = 0; k < allLines.length; k++) {\\n              if (!this._includeR.test(allLines[k])) {\\n              allLines[k] = \\\"#line \\\" + (i++) + \\\" \\\" + sourceID + \\'\\\\n\\' + allLines[k] ;\\n              }\\n              }\\n              content = allLines.join(\\'\\\\n\\');\\n            */\\n\\n            // seems just  prefixing first line seems ok to help renumbering error mesg\\n            return \\'\\\\n#line \\' + 0 + \\' \\' + sourceID + \\'\\\\n\\' + content;\\n        },\\n\\n        getShaderTextPure: function ( shaderName ) {\\n            var preShader;\\n\\n            if ( !( shaderName in this._shadersText ) ) {\\n                // directory include/prefix problems.\\n                for ( var name in this._shadersText ) {\\n                    if ( name.indexOf( shaderName ) !== -1 ) {\\n                        preShader = this._shadersText[ name ];\\n                        break;\\n                    }\\n                }\\n                if ( !preShader ) {\\n                    window.dbg.viewer.error( \\'shader file/text: \\' + shaderName + \\' not loaded\\' );\\n                    return \\'\\';\\n                }\\n            }\\n            else {\\n                preShader = this._shadersText[ shaderName ];\\n            }\\n            return preShader;\\n        },\\n\\n        getShader: function( shaderName ) {\\n            var shader = this.getShaderTextPure( shaderName );\\n            return this.processShader( shader );\\n        },\\n\\n        // recursively  handle #include external glsl\\n        // files (for now in the same folder.)\\n        preprocess: function ( content, sourceID, includeList ) {\\n            return content.replace( this._includeR, function ( _, name ) {\\n                // \\\\#pragma include \\'name\\';\\n                // already included\\n                if ( includeList.indexOf( name ) !== -1 ) return \\'\\';\\n                // avoid endless loop, not calling the impure\\n                var txt = this.getShaderTextPure( name );\\n                // make sure it\\'s not included twice\\n                includeList.push( name );\\n                if ( this._debugLines ) {\\n                    txt = this.instrumentShaderlines( txt, sourceID );\\n                }\\n                sourceID++;\\n                // to the infinite and beyond !\\n                txt = this.preprocess( txt, sourceID, includeList );\\n                return txt;\\n            }.bind( this ) );\\n        },\\n\\n        //  process a shader and define\\n        //  get a full expanded single shader source code\\n        //  resolving include dependencies\\n        //  adding defines\\n        //  adding line instrumenting.\\n        processShader: function ( shader, defines ) {\\n            var includeList = [];\\n            var preShader = shader;\\n            var sourceID = 0;\\n            if ( this._debugLines ) {\\n                preShader = this.instrumentShaderlines( preShader, sourceID );\\n                sourceID++;\\n            }\\n            var postShader = this.preprocess( preShader, sourceID, includeList );\\n\\n            var prePrend = \\'\\';\\n            if ( this._globalDefaultprecision ) {\\n                if ( !this._precisionR.test( postShader ) ) {\\n                    // use the shaderhighprecision flag at shaderloader start\\n                    //var highp = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\\n                    //var highpSupported = highp.precision != 0;\\n                    prePrend += this._globalDefaultprecision + \\'\\\\n\\';\\n                }\\n            }\\n\\n            if ( !defines ) defines = [];\\n            defines.push( this._globalDefaultDefines );\\n\\n            prePrend += defines.join( \\'\\\\n\\' ) + \\'\\\\n\\';\\n            postShader = prePrend + postShader;\\n            return postShader;\\n        }\\n    };\\n    return ShaderLoader;\\n\\n});\\n\\n//# sourceURL=/osgShader/ShaderProcessor.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine( \\'osgShader/shaderGenerator/Compiler\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Map\\',\\n    \\'osgShader/utils/sprintf\\',\\n    \\'osgShader/ShaderNode\\',\\n    \\'osgShader/ShaderProcessor\\'\\n\\n\\n], function ( Notify, Uniform, Texture, Map, sprintf, ShaderNode, ShaderProcessor ) {\\n\\n\\n    var shaderProcessor;\\n\\n    function getOrCreateShaderProcessor() {\\n\\n        if ( shaderProcessor === undefined ) {\\n            shaderProcessor = new ShaderProcessor();\\n        }\\n        return shaderProcessor;\\n\\n    }\\n\\n\\n    var Compiler = function ( state, attributes, textureAttributes, scene ) {\\n        this._state = state;\\n        this._variables = {};\\n        this._vertexShader = [];\\n        this._fragmentShader = [];\\n\\n        // global stuffs\\n        this._scene = scene;\\n        this._shaderProcessor = getOrCreateShaderProcessor();\\n        this._lightNodes = [];\\n        this._texturesByName = {};\\n\\n        // TODO: extract material + light to propoer method callable by inheriting\\n\\n        // separate Material / Light / Texture\\n        // because this shader generator is specific for this\\n        var lights = [];\\n        var material;\\n        for ( var i = 0, l = attributes.length; i < l; i++ ) {\\n            var type = attributes[ i ].className();\\n            // Test one light at a time\\n            if ( type === \\'Light\\' ) { // && lights.length === 0) {\\n                lights.push( attributes[ i ] );\\n            } else if ( type === \\'Material\\' ) {\\n                if ( material !== undefined ) Notify.warn( \\'Multiple Material attributes latest Chosen \\' );\\n                material = attributes[ i ];\\n\\n            } else {\\n                Notify.warn( \\'Compiler, does not know type \\' + type );\\n            }\\n        }\\n\\n        var texturesNum = textureAttributes.length;\\n        var textures = new Array( texturesNum );\\n        for ( var j = 0; j < texturesNum; j++ ) {\\n            var tu = textureAttributes[ j ];\\n            if ( tu !== undefined ) {\\n                for ( var t = 0, tl = tu.length; t < tl; t++ ) {\\n                    var tuTarget = tu[ t ];\\n                    var tType = tuTarget.className();\\n                    var tName  = tuTarget.getName();\\n                    if ( tType === \\'Texture\\' ) {\\n                        if ( tName   === undefined ) {\\n                            tName = tType + t;\\n                            tuTarget.setName( tName );\\n                        }\\n                        textures[ j ] = tuTarget;\\n                        this._texturesByName[ tName ] = {\\n                            \\'variable\\': undefined,\\n                            \\'texture\\': t\\n                        };\\n                    }\\n                }\\n            }\\n        }\\n\\n        this._lights = lights;\\n        this._material = material;\\n        this._textures = textures;\\n        this._state = state;\\n\\n    };\\n\\n    Compiler.prototype = {\\n        getVariable: function ( name ) {\\n            return this._variables[ name ];\\n        },\\n\\n        Variable: function ( type, varname ) {\\n            var name = varname;\\n            if ( name === undefined ) {\\n                var len = Object.keys( this._variables ).length;\\n                name = \\'tmp_\\' + len;\\n            } else if ( this._variables[ name ] ) {\\n                // create a new variable\\n                // if we want to reuse a variable we should NOT\\n                // call this function in the first place and do the\\n                // test before...\\n                // however for uniform, varying and sampler, we return\\n                // the variable if it already exists, because they are\\n                // meant to be read only\\n                name += \\'1\\';\\n            }\\n            var v = new ShaderNode.Variable( type, name );\\n            this._variables[ name ] = v;\\n            return v;\\n        },\\n\\n        Uniform: function ( type, varname ) {\\n            var name = varname;\\n\\n            // accept uniform as parameter to simplify code\\n            if ( type instanceof Uniform ) {\\n                var uniform = type;\\n                type = uniform.getType();\\n                name = uniform.getName();\\n            } else if ( name === undefined ) {\\n                var len = Object.keys( this._variables ).length;\\n                name = \\'tmp_\\' + len;\\n            }\\n\\n            var exist = this._variables[ name ];\\n            if ( exist ) {\\n                // see comment in Variable function\\n                return exist;\\n            }\\n\\n            var v = new ShaderNode.Uniform( type, name );\\n            this._variables[ name ] = v;\\n            return v;\\n        },\\n\\n        Varying: function ( type, varname ) {\\n            var name = varname;\\n            if ( name === undefined ) {\\n                var len = Object.keys( this._variables ).length;\\n                name = \\'tmp_\\' + len;\\n            } else {\\n                var exist = this._variables[ name ];\\n                if ( exist ) {\\n                    // see comment in Variable function\\n                    return exist;\\n                }\\n            }\\n            var v = new ShaderNode.Varying( type, name );\\n            this._variables[ name ] = v;\\n            return v;\\n        },\\n\\n        Sampler: function ( type, varname ) {\\n            var name = varname;\\n            if ( name === undefined ) {\\n                var len = Object.keys( this._variables ).length;\\n                name = \\'sampler_\\' + len;\\n            } else {\\n                var exist = this._variables[ name ];\\n                if ( exist ) {\\n                    // see comment in Variable function\\n                    return exist;\\n                }\\n            }\\n            var v = new ShaderNode.Sampler( type, name );\\n            this._variables[ name ] = v;\\n            return v;\\n        },\\n\\n        declareUniforms: function () {\\n\\n            if ( this._material ) {\\n                var uniformMap = this._material.getOrCreateUniforms();\\n                var uniformMapKeys = uniformMap.getKeys();\\n\\n                for ( var m = 0, ml = uniformMapKeys.length; m < ml; m++ ) {\\n\\n                    var kk = uniformMapKeys[ m ];\\n                    var kkey = uniformMap[ kk ];\\n                    this.Uniform( kkey.type, kkey.name );\\n\\n                }\\n            }\\n        },\\n\\n        createFragmentShaderGraph: function () {\\n            this.declareUniforms();\\n            this.declareTextures();\\n\\n            var finalColor = [ 1.0, 1.0, 1.0, 1.0 ];\\n            var alpha = 1.0;\\n\\n            if ( this._material ) {\\n                // diffuse color\\n                var diffuseColor = this.getTexture();\\n                diffuseColor = this.getVertexColor( diffuseColor );\\n                finalColor = this.getFinalColor( diffuseColor );\\n                finalColor = this.getPremultAlpha( finalColor, diffuseColor.alpha );\\n            }\\n            // get srgb color and apply alpha\\n            var fragColor = new ShaderNode.FragColor();\\n            new ShaderNode.SetAlpha( this.getSrgbColor( finalColor ), alpha, fragColor );\\n\\n            return fragColor;\\n        },\\n\\n        getFinalColor: function () {\\n            var finalColor = this.Variable( \\'vec3\\' );\\n\\n            var opFinalColor = new ShaderNode.AddVector();\\n            opFinalColor.comment( \\'finalColor = ???\\' );\\n            opFinalColor.connectOutput( finalColor );\\n\\n            for ( var i = 0, l = arguments.length; i < l; ++i ) {\\n                if ( arguments[ i ] ) {\\n                    opFinalColor.connectInput( arguments[ i ] );\\n                }\\n            }\\n\\n            if ( opFinalColor.getInputs().length === 0 )\\n                opFinalColor.connectInput( new ShaderNode.InlineConstant( \\'vec3( 0.0, 0.0, 0.0 )\\' ) );\\n\\n\\n            return finalColor;\\n        },\\n\\n\\n\\n        getOrCreateLightNodes: function () {\\n            var lights = this._lights;\\n            var lightNodes = this._lightNodes;\\n            if ( lightNodes.length === lights.length )\\n                return lightNodes;\\n            for ( var i = 0, l = lights.length; i < l; i++ ) {\\n                var nodeLight = new ShaderNode.Light( lights[ i ] );\\n                nodeLight.init( this );\\n                lightNodes.push( nodeLight );\\n            }\\n            return lightNodes;\\n        },\\n\\n        getOrCreateInputNormal: function () {\\n            return this.Varying( \\'vec3\\', \\'FragNormal\\' );\\n        },\\n\\n        getOrCreateFrontNormal: function () {\\n            var inputNormal = this.getOrCreateInputNormal();\\n            var frontNormal = this.Variable( \\'vec3\\', \\'frontNormal\\' );\\n            new ShaderNode.FrontNormal( inputNormal, frontNormal );\\n\\n            return frontNormal;\\n        },\\n\\n        getOrCreateInputPosition: function () {\\n            return this.Varying( \\'vec3\\', \\'FragEyeVector\\' );\\n        },\\n\\n        getOrCreateNormalizedNormal: function () {\\n            var normal = this._variables[ \\'normal\\' ];\\n            if ( normal )\\n                return normal;\\n            this.normalizeNormalAndEyeVector();\\n            return this._variables[ \\'normal\\' ];\\n        },\\n\\n        getOrCreateNormalizedPosition: function () {\\n            var eye = this._variables[ \\'eyeVector\\' ];\\n            if ( eye )\\n                return eye;\\n            this.normalizeNormalAndEyeVector();\\n            return this._variables[ \\'eyeVector\\' ];\\n        },\\n\\n        // It should be called by getOrCreateNormalizedNormal or getOrCreateNormalizedPosition ONLY\\n        normalizeNormalAndEyeVector: function () {\\n            var frontNormal = this.getOrCreateFrontNormal();\\n            var inputPosition = this.getOrCreateInputPosition();\\n            var normalizeNormalAndVector = new ShaderNode.NormalizeNormalAndEyeVector( frontNormal, inputPosition );\\n\\n            // get or create normalized normal\\n            var outputNormal = this._variables[ \\'normal\\' ];\\n            if ( outputNormal === undefined ) outputNormal = this.Variable( \\'vec3\\', \\'normal\\' );\\n\\n            // get or create normalized position\\n            var outputPosition = this._variables[ \\'eyeVector\\' ];\\n            if ( outputPosition === undefined ) outputPosition = this.Variable( \\'vec3\\', \\'eyeVector\\' );\\n\\n            normalizeNormalAndVector.connectOutputNormal( outputNormal );\\n            normalizeNormalAndVector.connectOutputEyeVector( outputPosition );\\n        },\\n\\n        getPremultAlpha: function ( finalColor, alpha ) {\\n            if ( alpha === undefined )\\n                return finalColor;\\n            var tmp = this.Variable( \\'vec4\\' );\\n            new ShaderNode.SetAlpha( finalColor, alpha, tmp );\\n            var premultAlpha = this.Variable( \\'vec3\\' );\\n            new ShaderNode.PreMultAlpha( tmp, premultAlpha );\\n            return premultAlpha;\\n        },\\n\\n        getSrgbColor: function ( finalColor ) {\\n            var gamma = this.Variable( \\'float\\' );\\n            gamma.setValue( ShaderNode.Linear2sRGB.defaultGamma );\\n            var finalSrgbColor = this.Variable( \\'vec3\\' );\\n            new ShaderNode.Linear2sRGB( finalColor, finalSrgbColor, gamma );\\n\\n            return finalSrgbColor;\\n        },\\n\\n\\n        getLambertOutput: function ( diffuseColor, normal ) {\\n\\n            if ( diffuseColor === undefined )\\n                return undefined;\\n\\n            var lightNodes = this.getOrCreateLightNodes();\\n\\n            if ( !lightNodes.length )\\n                return undefined;\\n\\n            var diffuseOutput = this.Variable( \\'vec3\\', \\'diffuseOutput\\' );\\n            var nodeLambert = new ShaderNode.Lambert( diffuseColor, normal, diffuseOutput );\\n            nodeLambert.connectLights( lightNodes );\\n            nodeLambert.createFragmentShaderGraph( this );\\n\\n            return diffuseOutput;\\n        },\\n\\n        getCookTorranceOutput: function ( specularColor, normal, specularHardness ) {\\n\\n            if ( specularColor === undefined || specularHardness === undefined )\\n                return undefined;\\n\\n            var lightNodes = this.getOrCreateLightNodes();\\n\\n            if ( !lightNodes.length )\\n                return undefined;\\n\\n            var specularOutput = this.Variable( \\'vec3\\', \\'specularOutput\\' );\\n            var nodeCookTorrance = new ShaderNode.CookTorrance( specularColor, normal, specularHardness, specularOutput );\\n            nodeCookTorrance.connectLights( lightNodes );\\n            nodeCookTorrance.createFragmentShaderGraph( this );\\n\\n            return specularOutput;\\n        },\\n\\n        getVertexColor: function ( diffuseColor ) {\\n            if ( diffuseColor === undefined )\\n                return undefined;\\n            var vertexColor = this.Varying( \\'vec4\\', \\'VertexColor\\' );\\n            var vertexColorUniform = this.Uniform( \\'float\\', \\'ArrayColorEnabled\\' );\\n            var tmp = this.Variable( \\'vec3\\' );\\n\\n            var str = [ \\'\\',\\n                sprintf( \\'%s = %s;\\', [ tmp.getVariable(), diffuseColor.getVariable() ] ),\\n                sprintf( \\'if ( %s == 1.0) {\\', [ vertexColorUniform.getVariable() ] ),\\n                sprintf( \\'  %s *= %s.rgb;\\', [ tmp.getVariable(), vertexColor.getVariable() ] ),\\n                \\'}\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var operator = new ShaderNode.InlineCode( diffuseColor, vertexColorUniform, vertexColor );\\n            operator.connectOutput( tmp );\\n            operator.setCode( str );\\n            operator.comment( \\'diffuse color = diffuse color * vertex color\\' );\\n            return tmp;\\n        },\\n\\n\\n        getOrCreateUniformSharedOnTextureUnit: function ( unit ) {\\n            var map = this.uniformsSharedOnTextureUnit;\\n\\n            if ( map )\\n                return map;\\n\\n            // handle texture unit uniform here\\n            // Here there is an issue because we need to add the used uniform for\\n            // this channel name\\n            var uniforms = {};\\n\\n            var uniformTextureUnitName = \\'Texture\\' + unit.toString();\\n            if ( !uniforms[ uniformTextureUnitName ] ) {\\n                uniforms[ uniformTextureUnitName ] = Uniform.createInt( 0, uniformTextureUnitName );\\n            }\\n\\n            var uniformName = \\'u\\' + unit + \\'Factor\\';\\n            uniforms[ unit ] = Uniform.createFloat1( uniformName );\\n\\n\\n            this.uniformsSharedOnTextureUnit = new Map( uniforms );\\n\\n            return this.uniformsSharedOnTextureUnit;\\n        },\\n\\n        getOrCreateUniforms: function ( unit ) {\\n            var obj = this.uniforms;\\n\\n            if ( obj[ unit ] ) return obj[ unit ];\\n\\n            var uniformMap = this.getOrCreateUniformSharedOnTextureUnit( unit );\\n            obj[ unit ] = uniformMap;\\n\\n            return obj[ unit ];\\n        },\\n        getTexture: function ( name ) {\\n            var textures = this._textures;\\n            var tex, texUnit = 0;\\n            if ( name === undefined ) {\\n                tex = textures[ texUnit ];\\n                name = \\'Texture\\' + texUnit;\\n            }\\n\\n            tex = this._texturesByName[ name ];\\n            if ( tex === undefined )\\n                return undefined;\\n\\n            var texColor = tex.variable;\\n            return texColor;\\n        },\\n\\n        declareTextures: function () {\\n\\n            var textures = this._textures;\\n            var nbTextures = textures.length;\\n\\n            for ( var t = 0, tl = nbTextures; t < tl; t++ ) {\\n                var texture = textures[ t ];\\n                if ( !texture ) {\\n                    continue;\\n                }\\n                var textureClassName = texture.className();\\n                if ( textureClassName === \\'Texture\\' ) {\\n\\n                    var samplerName = \\'Texture\\' + t.toString();\\n                    var textureSampler = this.getVariable( samplerName );\\n                    if ( textureSampler === undefined ) {\\n                        if ( texture.className() === \\'Texture\\' ) {\\n                            textureSampler = this.Sampler( \\'sampler2D\\', samplerName );\\n                        } else if ( texture.className() === \\'TextureCubeMap\\' ) {\\n                            textureSampler = this.Sampler( \\'samplerCube\\', samplerName );\\n                        }\\n                    }\\n\\n                    //texture.getTexCoordUnit(); // a way for material to specify uv ?\\n                    var texCoordUnit = t;\\n\\n                    var texCoord = this.getVariable( \\'FragTexCoord\\' + texCoordUnit );\\n                    if ( texCoord === undefined ) {\\n                        texCoord = this.Varying( \\'vec2\\', \\'FragTexCoord\\' + texCoordUnit );\\n                    }\\n                    var output;\\n\\n                    output = this.createTexturesDiffuseColor( texture, textureSampler, texCoord );\\n\\n                    // if the texture channel is valid we register it\\n\\n                    if ( output !== undefined ) {\\n                        var textureUnit = t;\\n\\n                        var name = texture.getName();\\n                        if ( name === undefined ) {\\n                            name = \\'Texture\\' + texCoordUnit;\\n                        }\\n\\n                        var textureMaterial = this._texturesByName[ name ];\\n                        if ( textureMaterial === undefined ){\\n                            this._texturesByName[ name ] = {\\n                                \\'variable\\': output,\\n                                \\'texture\\': textureUnit\\n                            };\\n                        }\\n                        else{\\n                            textureMaterial.variable = output;\\n                            textureMaterial.texture = textureUnit;\\n                        }\\n                    }\\n\\n                }\\n            }\\n        },\\n\\n        createTexturesDiffuseColor: function ( texture, textureSampler, texCoord ) {\\n            var output, node, texel, srgb2linearTmp;\\n            texel = this.Variable( \\'vec4\\' );\\n            var premult = this.Variable( \\'vec3\\' );\\n            node = new ShaderNode.TextureRGBA( textureSampler, texCoord, texel );\\n            srgb2linearTmp = this.Variable( \\'vec4\\' );\\n            node = new ShaderNode.sRGB2Linear( texel, srgb2linearTmp );\\n            node = new ShaderNode.PreMultAlpha( srgb2linearTmp, premult );\\n            output = premult;\\n            return output;\\n        },\\n\\n\\n        createTexturesAlphaOpacity: function ( texture, textureSampler, texCoord ) {\\n            var node;\\n            var useTextureIntensity = false;\\n            // TODO it look that this part should be rewritten\\n            // check if we want luminance\\n            if ( texture.getImage() !== undefined &&\\n                texture.getImage().getURL() &&\\n                texture.getImage().getURL().length < 1024 ) { // dont check inline image\\n                var src = texture.getImage().getURL().toLowerCase();\\n                if ( src.indexOf( \\'.jpg\\' ) !== -1 ||\\n                    src.indexOf( \\'.jpeg\\' ) !== -1 ) {\\n                    useTextureIntensity = true;\\n                }\\n            }\\n            if ( texture.getInternalFormat() === Texture.LUMINANCE || useTextureIntensity ) {\\n                node = new ShaderNode.TextureIntensity( textureSampler, texCoord );\\n            } else {\\n                node = new ShaderNode.TextureAlpha( textureSampler, texCoord );\\n            }\\n            var output = this.Variable( \\'float\\' );\\n            node.connectOutput( output );\\n            return output;\\n        },\\n\\n        createTexturesSpecularColor: function ( textureSampler, texCoord ) {\\n            var node = new ShaderNode.TextureRGB( textureSampler, texCoord );\\n            var output = this.Variable( \\'vec3\\' );\\n            node.connectOutput( output );\\n            return output;\\n        },\\n\\n        createTexturesShininess: function ( textureSampler, texCoord ) {\\n            var node = new ShaderNode.TextureIntensity( textureSampler, texCoord );\\n            var output = this.Variable( \\'float\\' );\\n            node.connectOutput( output );\\n            return output;\\n        },\\n\\n        createTexturesEmissionColor: function ( texture, textureSampler, texCoord ) {\\n            var node;\\n            var output = this.Variable( \\'vec3\\' );\\n            var texel, srgb2linearTmp;\\n            if ( texture.getPremultiplyAlpha() ) {\\n                texel = this.Variable( \\'vec4\\' );\\n                node = new ShaderNode.TextureRGBA( textureSampler, texCoord, texel );\\n                var premult = this.Variable( \\'vec3\\' );\\n                if ( texture.getSRGB() ) {\\n                    srgb2linearTmp = this.Variable( \\'vec4\\' );\\n                    node = new ShaderNode.sRGB2Linear( texel, srgb2linearTmp );\\n                    node = new ShaderNode.PreMultAlpha( srgb2linearTmp, premult );\\n                } else {\\n                    node = new ShaderNode.PreMultAlpha( texel, premult );\\n                }\\n                output = premult;\\n            } else {\\n                texel = this.Variable( \\'vec3\\' );\\n                node = new ShaderNode.TextureRGB( textureSampler, texCoord, texel );\\n                if ( texture.getSRGB() ) {\\n                    srgb2linearTmp = this.Variable( \\'vec3\\' );\\n                    node = new ShaderNode.sRGB2Linear( texel, srgb2linearTmp );\\n                    output = srgb2linearTmp;\\n                } else {\\n                    output = texel;\\n                }\\n            }\\n            return output;\\n        },\\n\\n        createTexturesMirror: function ( textureSampler, texCoord ) {\\n            var node = new ShaderNode.TextureIntensity( textureSampler, texCoord );\\n            var output = this.Variable( \\'float\\' );\\n            node.connectOutput( output );\\n            return output;\\n        },\\n\\n        traverse: function ( functor, node ) {\\n            for ( var i = 0, l = node.getInputs().length; i < l; i++ ) {\\n                var child = node.getInputs()[ i ];\\n\\n                if ( child !== undefined &&\\n                    child !== node ) {\\n                    this.traverse( functor, child );\\n                }\\n            }\\n            functor.call( functor, node );\\n        },\\n\\n        evaluateGlobalFunctionDeclaration: function ( node ) {\\n            var func = function ( node ) {\\n                if ( node.globalFunctionDeclaration &&\\n                    this._map[ node.type ] === undefined ) {\\n                    this._map[ node.type ] = true;\\n                    var c = node.globalFunctionDeclaration();\\n                    this._text.push( c );\\n                }\\n            };\\n            func._map = {};\\n            func._text = [];\\n            this.traverse( func, node );\\n            return func._text.join( \\'\\\\n\\' );\\n        },\\n\\n        evaluateGlobalVariableDeclaration: function ( node ) {\\n            var func = function ( node ) {\\n                if ( this._map[ node._id ] === undefined ) {\\n                    this._map[ node._id ] = true;\\n                    if ( node.globalDeclaration !== undefined ) {\\n                        var c = node.globalDeclaration();\\n                        if ( c !== undefined ) {\\n                            this._text.push( c );\\n                        }\\n                    }\\n                }\\n            };\\n            func._map = {};\\n            func._text = [];\\n            this.traverse( func, node );\\n            return func._text.join( \\'\\\\n\\' );\\n        },\\n\\n        evaluate: function ( node ) {\\n            var func = function ( node ) {\\n                if ( this._mapTraverse[ node._id ] !== undefined ) {\\n                    return;\\n                }\\n\\n                var c = node.computeFragment();\\n                if ( c !== undefined ) {\\n                    if ( node.getComment !== undefined ) {\\n                        var comment = node.getComment();\\n                        if ( comment !== undefined ) {\\n                            this._text.push( comment );\\n                        }\\n                    }\\n\\n                    this._text.push( c );\\n                }\\n                this._mapTraverse[ node._id ] = true;\\n            };\\n            func._text = [];\\n            func._mapTraverse = [];\\n            this.traverse( func, node );\\n            this._fragmentShader.push( func._text.join( \\'\\\\n\\' ) );\\n        },\\n\\n        createVertexShaderGraph: function () {\\n            var texCoordMap = {};\\n            var textures = this._textures;\\n            var texturesMaterial = this._texturesByName;\\n\\n            this._vertexShader.push( [ \\'\\',\\n                \\'attribute vec3 Vertex;\\',\\n                \\'attribute vec4 Color;\\',\\n                \\'attribute vec3 Normal;\\',\\n                \\'uniform float ArrayColorEnabled;\\',\\n                \\'uniform mat4 ModelViewMatrix;\\',\\n                \\'uniform mat4 ProjectionMatrix;\\',\\n                \\'uniform mat4 NormalMatrix;\\',\\n                \\'varying vec4 VertexColor;\\',\\n                \\'varying vec3 FragNormal;\\',\\n                \\'varying vec3 FragEyeVector;\\',\\n                \\'\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' ) );\\n\\n            for ( var t = 0, tl = textures.length; t < tl; t++ ) {\\n                var texture = textures[ t ];\\n                if ( texture !== undefined ) {\\n                    // no method to retrieve textureCoordUnit, we maybe dont need any uvs\\n                    var textureMaterial = texturesMaterial[ texture.getName() ];\\n                    if ( !textureMaterial && !textureMaterial.textureUnit )\\n                        continue;\\n\\n                    var texCoordUnit = textureMaterial.textureUnit;\\n                    if ( texCoordUnit === undefined ) {\\n                        texCoordUnit = t;\\n                        textureMaterial.textureUnit = t;\\n                    }\\n                    if ( texCoordMap[ texCoordUnit ] === undefined ) {\\n                        this._vertexShader.push( \\'attribute vec2 TexCoord\\' + texCoordUnit + \\';\\' );\\n                        this._vertexShader.push( \\'varying vec2 FragTexCoord\\' + texCoordUnit + \\';\\' );\\n                        texCoordMap[ texCoordUnit ] = true;\\n                    }\\n                }\\n            }\\n\\n            this._vertexShader.push( [ \\'\\',\\n                \\'void main() {\\',\\n                \\'  FragNormal = vec3(NormalMatrix * vec4(Normal, 0.0));\\',\\n                \\'  FragEyeVector = vec3(ModelViewMatrix * vec4(Vertex,1.0));\\',\\n                \\'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\\',\\n                \\'  if (ArrayColorEnabled == 1.0)\\',\\n                \\'    VertexColor = Color;\\',\\n                \\'  else\\',\\n                \\'    VertexColor = vec4(1.0,1.0,1.0,1.0);\\',\\n                \\'  gl_PointSize = 1.0;\\',\\n                \\'\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' ) );\\n\\n            var self = this;\\n            ( function () {\\n                var texCoordMap = {};\\n                for ( var tt = 0, ttl = textures.length; tt < ttl; tt++ ) {\\n                    if ( textures[ tt ] !== undefined ) {\\n                        var texture = textures[ tt ];\\n                        var textureMaterial = texturesMaterial[ texture.getName() ];\\n                        // no method getTexCoordUnit, maybe we dont need it at all\\n                        if ( !textureMaterial && !textureMaterial.textureUnit )\\n                            continue;\\n\\n                        var texCoordUnit = texture.textureUnit;\\n                        if ( texCoordUnit === undefined ) {\\n                            texCoordUnit = tt;\\n                            textureMaterial.textureUnit = tt;\\n                        }\\n\\n                        if ( texCoordMap[ texCoordUnit ] === undefined ) {\\n                            self._vertexShader.push( \\'FragTexCoord\\' + texCoordUnit + \\' = TexCoord\\' + texCoordUnit + \\';\\' );\\n                            texCoordMap[ texCoordUnit ] = true;\\n                        }\\n                    }\\n                }\\n            } )();\\n            this._vertexShader.push( \\'}\\' );\\n        },\\n\\n        createVertexShader: function () {\\n            // Call to specialised inhenrited shader Compiler\\n            this.createVertexShaderGraph();\\n            var shader = this._vertexShader.join( \\'\\\\n\\' );\\n            //osg.log(\\'Vertex Shader\\');\\n            //osg.log(shader);\\n            shader = this._shaderProcessor.processShader( shader );\\n            return shader;\\n        },\\n\\n        createFragmentShader: function () {\\n            // Call to specialised inhenrited shader Compiler\\n            var root = this.createFragmentShaderGraph();\\n\\n            this._fragmentShader.push( [ \\'\\',\\n                \\'uniform mat4 NormalMatrix;\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' ) );\\n\\n\\n            var vars = Object.keys( this._variables );\\n\\n            this._fragmentShader.push( this.evaluateGlobalVariableDeclaration( root ) );\\n\\n            this._fragmentShader.push( [\\n                \\'\\'\\n            ].join( \\'\\\\n\\' ) );\\n\\n            this._fragmentShader.push( this.evaluateGlobalFunctionDeclaration( root ) );\\n\\n\\n            this._fragmentShader.push( \\'void main() {\\' );\\n\\n            var variables = [];\\n            variables.push( \\'// vars\\\\n\\' );\\n            for ( var j = 0, jl = vars.length; j < jl; j++ ) {\\n                var d = this._variables[ vars[ j ] ].declare();\\n                if ( d !== undefined ) {\\n                    variables.push( this._variables[ vars[ j ] ].declare() );\\n                }\\n            }\\n            variables.push( \\'\\\\n// end vars\\\\n\\' );\\n            // declare variable in main\\n            this._fragmentShader.push( variables.join( \\' \\' ) );\\n\\n            this.evaluate( root );\\n\\n            this._fragmentShader.push( \\'}\\' );\\n            var shader = this._fragmentShader.join( \\'\\\\n\\' );\\n            //osg.log(\\'Fragment Shader\\');\\n\\n            shader = this._shaderProcessor.processShader( shader );\\n\\n            Notify.debug( shader );\\n            return shader;\\n        }\\n    };\\n\\n    return Compiler;\\n\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/Compiler.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/ShaderGenerator\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Map\\',\\n    \\'osg/Light\\',\\n    \\'osgShader/shaderGenerator/Compiler\\'\\n], function ( Notify, Program, Shader, Map, Light, Compiler ) {\\n\\n    require( [ \\'osg/Light\\' ], function ( CircularDependency ) {\\n        Light = CircularDependency;\\n    } );\\n\\n    var ShaderGenerator = function () {\\n        this._cache = {};\\n    };\\n\\n    ShaderGenerator.prototype = {\\n\\n        // scene is needed only for cubemap and environment\\n        // maybe we could refactore this\\n        setSceneContext: function ( scene ) {\\n            this._scene = scene;\\n        },\\n\\n        // filter all attribute that comes from osgShader namespace\\n        getActiveAttributeList: function ( state, list ) {\\n\\n            var hash = \\'\\';\\n            var attributeMap = state.attributeMap;\\n            var attributeMapKeys = attributeMap.getKeys();\\n\\n            for ( var j = 0, k = attributeMapKeys.length; j < k; j++ ) {\\n                var keya = attributeMapKeys[ j ];\\n                var attributeStack = attributeMap[ keya ];\\n                var attr = attributeStack.lastApplied;\\n                if ( attr.libraryName() !== \\'osg\\' ) {\\n                    continue;\\n                }\\n\\n                // if it\\'s a light and it\\'s not enable we filter it\\n                if ( attr.typeID === Light.typeID && !attr.isEnable() ) {\\n                    continue;\\n                }\\n\\n                if ( attr.getHash ) {\\n                    hash += attr.getHash();\\n                } else {\\n                    hash += attr.getType();\\n                }\\n                list.push( attr );\\n            }\\n            return hash;\\n        },\\n\\n        // filter all texture attribute that comes from osgShader namespace\\n        getActiveTextureAttributeList: function ( state, list ) {\\n            var hash = \\'\\';\\n            var attributeMapList = state.textureAttributeMapList;\\n            var i, l;\\n\\n            for ( i = 0, l = attributeMapList.length; i < l; i++ ) {\\n                var attributeMapForUnit = attributeMapList[ i ];\\n                if ( attributeMapForUnit === undefined ) {\\n                    continue;\\n                }\\n                list[ i ] = [];\\n\\n                var attributeMapForUnitKeys = attributeMapForUnit.getKeys();\\n\\n                for ( var j = 0, m = attributeMapForUnitKeys.length; j < m; j++ ) {\\n\\n                    var key = attributeMapForUnitKeys[ j ];\\n                    if ( key !== \\'Texture\\' ) {\\n                        continue;\\n                    }\\n\\n                    var attributeStack = attributeMapForUnit[ key ];\\n                    if ( attributeStack.length === 0 ) {\\n                        continue;\\n                    }\\n\\n                    var attr = attributeStack.lastApplied;\\n                    if ( attr.libraryName() !== \\'osg\\' ) {\\n                        continue;\\n                    }\\n\\n                    if ( attr.getHash ) {\\n                        hash += attr.getHash();\\n                    } else {\\n                        hash += attr.getType();\\n                    }\\n                    list[ i ].push( attr );\\n                }\\n            }\\n            return hash;\\n        },\\n\\n        getActiveUniforms: function ( state, attributeList, textureAttributeList ) {\\n\\n            var uniforms = {};\\n\\n            for ( var i = 0, l = attributeList.length; i < l; i++ ) {\\n\\n                var at = attributeList[ i ];\\n                if ( at.getOrCreateUniforms ){\\n                    var attributeUniformMap = at.getOrCreateUniforms();\\n                    var attributeUniformMapKeys = attributeUniformMap.getKeys();\\n\\n                    for ( var j = 0, m = attributeUniformMapKeys.length; j < m; j++ ) {\\n                        var name = attributeUniformMapKeys[ j ];\\n                        var uniform = attributeUniformMap[ name ];\\n                        uniforms[ uniform.name ] = uniform;\\n                    }\\n                }\\n            }\\n\\n            for ( var a = 0, n = textureAttributeList.length; a < n; a++ ) {\\n                var tat = textureAttributeList[ a ];\\n                if ( tat !== undefined ) {\\n                    for ( var b = 0, o = tat.length; b < o; b++ ) {\\n                        var attr = tat[ b ];\\n\\n                        var texUniformMap = attr.getOrCreateUniforms( a );\\n                        var texUniformMapKeys = texUniformMap.getKeys();\\n\\n                        for ( var t = 0, tl = texUniformMapKeys.length; t < tl; t++ ) {\\n                            var tname = texUniformMapKeys[ t ];\\n                            var tuniform = texUniformMap[ tname ];\\n                            uniforms[ tuniform.name ] = tuniform;\\n                        }\\n                    }\\n                }\\n            }\\n\\n            return new Map( uniforms );\\n        },\\n\\n        getOrCreateProgram: ( function () {\\n            // TODO: double check GC impact of this stack\\n            var textureAttributes = [];\\n            var attributes = [];\\n            return function ( state ) {\\n                // extract valid attributes\\n                var hash = \\'\\';\\n                attributes.length = 0;\\n                textureAttributes.length = 0;\\n                hash += this.getActiveAttributeList( state, attributes );\\n                hash += this.getActiveTextureAttributeList( state, textureAttributes );\\n\\n                if ( this._cache[ hash ] !== undefined ) {\\n                    return this._cache[ hash ];\\n                }\\n                var shaderGen = new Compiler( state, attributes, textureAttributes, this._scene );\\n                var vertexshader = shaderGen.createVertexShader();\\n                var fragmentshader = shaderGen.createFragmentShader();\\n\\n                var program = new Program(\\n                    new Shader( Shader.VERTEX_SHADER, vertexshader ),\\n                    new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\\n\\n                program.hash = hash;\\n                program.activeUniforms = this.getActiveUniforms( state, attributes, textureAttributes );\\n                program.generated = true;\\n\\n                this._cache[ hash ] = program;\\n                return program;\\n            };\\n        } )()\\n    };\\n\\n    return ShaderGenerator;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/ShaderGenerator.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/CompilerMaterial\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderGenerator/Compiler\\',\\n    \\'osgShader/ShaderNode\\'\\n\\n], function ( MACROUTILS, Compiler, shaderNode ) {\\n\\n    var CompilerMaterial = function ( state, attributes, textureAttributes, scene ) {\\n        Compiler.call( this, state, attributes, textureAttributes, scene );\\n\\n    };\\n\\n    CompilerMaterial.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\\n        createFragmentShaderGraph: function () {\\n            this.declareUniforms();\\n            this.declareTextures();\\n\\n            // diffuse color\\n            var diffuseColor = this.getTexture();\\n            diffuseColor = this.getVertexColor( diffuseColor );\\n\\n            var alpha =  new shaderNode.InlineConstant( \\'1.0\\' ); //|| this.getTexture( \\'Opacity\\' );\\n\\n            // get final color\\n            var finalColor = this.getFinalColor( diffuseColor );\\n            finalColor = this.getPremultAlpha( finalColor, alpha );\\n\\n            // get srgb color\\n            var srgbColor = this.getSrgbColor( finalColor );\\n\\n            var fragColor = new shaderNode.FragColor();\\n            new shaderNode.SetAlpha( srgbColor, alpha, fragColor );\\n\\n            return fragColor;\\n        }\\n    } );\\n\\n    return CompilerMaterial;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/CompilerMaterial.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/ShaderGeneratorMaterial\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Map\\',\\n    \\'osg/Light\\',\\n    \\'osgShader/shaderGenerator/ShaderGenerator\\',\\n    \\'osgShader/shaderGenerator/CompilerMaterial\\'\\n], function ( MACROUTILS, Notify, Program, Shader, Map, Light, ShaderGenerator, Compiler ) {\\n\\n\\n    var ShaderGeneratorMaterial = function () {\\n        ShaderGenerator.call( this );\\n    };\\n\\n    ShaderGeneratorMaterial.prototype = MACROUTILS.objectInherit( ShaderGenerator.prototype, {\\n\\n        getOrCreateProgram: ( function () {\\n            // TODO: double check GC impact of this stack\\n            var textureAttributes = [];\\n            var attributes = [];\\n            return function ( state ) {\\n                // extract valid attributes\\n                var hash = \\'\\';\\n                attributes.length = 0;\\n                textureAttributes.length = 0;\\n                hash += this.getActiveAttributeList( state, attributes );\\n                hash += this.getActiveTextureAttributeList( state, textureAttributes );\\n\\n                if ( this._cache[ hash ] !== undefined ) {\\n                    return this._cache[ hash ];\\n                }\\n                var shaderGen = new Compiler( state, attributes, textureAttributes, this._scene );\\n                var vertexshader = shaderGen.createVertexShader();\\n                var fragmentshader = shaderGen.createFragmentShader();\\n\\n                var program = new Program(\\n                    new Shader( Shader.VERTEX_SHADER, vertexshader ),\\n                    new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\\n\\n                program.hash = hash;\\n                program.activeUniforms = this.getActiveUniforms( state, attributes, textureAttributes );\\n                program.generated = true;\\n\\n                this._cache[ hash ] = program;\\n                return program;\\n            };\\n        } )()\\n    } );\\n\\n    return ShaderGeneratorMaterial;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/ShaderGeneratorMaterial.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/CompilerShadeless\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderGenerator/Compiler\\',\\n    \\'osgShader/ShaderNode\\'\\n\\n], function ( MACROUTILS, Compiler, shaderNode ) {\\n\\n    var CompilerShadeless = function ( state, attributes, textureAttributes, scene ) {\\n        Compiler.call( this, state, attributes, textureAttributes, scene );\\n    };\\n\\n    CompilerShadeless.prototype = MACROUTILS.objectInherit( Compiler.prototype, {\\n        createFragmentShaderGraph: function () {\\n            this.declareUniforms();\\n            this.declareTextures();\\n\\n            // diffuse color\\n            var diffuseColor = this.getTexture( \\'DiffuseColor\\' );\\n            diffuseColor = this.getVertexColor( diffuseColor );\\n\\n            var alpha = this.getTexture( \\'Opacity\\' ) || new shaderNode.InlineConstant( \\'1.0\\' );\\n\\n            // get final color\\n            var finalColor = this.getFinalColor( diffuseColor );\\n            finalColor = this.getPremultAlpha( finalColor, alpha );\\n\\n            // get srgb color\\n            var srgbColor = this.getSrgbColor( finalColor );\\n\\n            var fragColor = new shaderNode.FragColor();\\n            new shaderNode.SetAlpha( srgbColor, alpha, fragColor );\\n\\n            return fragColor;\\n        }\\n    } );\\n\\n    return CompilerShadeless;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/CompilerShadeless.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/ShaderGeneratorShadeless\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osgShader/shaderGenerator/ShaderGenerator\\',\\n    \\'osgShader/shaderGenerator/CompilerShadeless\\'\\n\\n], function ( MACROUTILS, Program, Shader, ShaderGenerator, CompilerShadeless ) {\\n\\n    var ShaderGeneratorShadeless = function () {\\n        ShaderGenerator.call( this );\\n    };\\n\\n    ShaderGeneratorShadeless.prototype = MACROUTILS.objectInherit( ShaderGenerator.prototype, {\\n        getOrCreateProgram: function ( state ) {\\n\\n            // extract valid attributes\\n            var hash = \\'\\';\\n            var attributes = [];\\n            var textureAttributes = [];\\n            hash += this.getActiveAttributeList( state, attributes );\\n            hash += this.getActiveTextureAttributeList( state, textureAttributes );\\n\\n            if ( this._cache[ hash ] !== undefined ) {\\n                return this._cache[ hash ];\\n            }\\n\\n            var shaderGen = new CompilerShadeless( state, attributes, textureAttributes, this._scene );\\n            var vertexshader = shaderGen.createVertexShader();\\n            var fragmentshader = shaderGen.createFragmentShader();\\n\\n            var program = new Program(\\n                new Shader( Shader.VERTEX_SHADER, vertexshader ),\\n                new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\\n\\n            program.hash = hash;\\n            program.activeUniforms = this.getActiveUniforms( state, attributes, textureAttributes );\\n            program.generated = true;\\n\\n            this._cache[ hash ] = program;\\n            return program;\\n        }\\n    } );\\n\\n    return ShaderGeneratorShadeless;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/ShaderGeneratorShadeless.js\");\n\n",
    "eval(\"define( \\'osgShader/shaderGenerator/ShaderGeneratorStateSet\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Map\\',\\n    \\'osg/Light\\',\\n    \\'osgShader/shaderGenerator/ShaderGenerator\\',\\n    \\'osgShader/shaderGenerator/CompilerMaterial\\'\\n], function ( MACROUTILS, Notify, Program, Shader, Map, Light, ShaderGenerator ) {\\n\\n    var ShaderGeneratorStateSet = function () {\\n        ShaderGenerator.call( this );\\n    };\\n\\n    ShaderGeneratorStateSet.Type = {\\n        VertexInit: 0,\\n        VertexFunction: 1,\\n        VertexMain: 2,\\n        VertexEnd: 3,\\n        FragmentInit: 5,\\n        FragmentFunction: 6,\\n        FragmentMain: 7,\\n        FragmentEnd: 8\\n    };\\n\\n    ShaderGeneratorStateSet.prototype = {\\n\\n        getActiveTypeMember: function ( state ) {\\n            // we should check attribute is active or not\\n            var types = [];\\n            var attributeMapKeys = state.attributeMap.getKeys();\\n            var attributeMap = state.attributeMap;\\n            for ( var j = 0, k = attributeMapKeys.length; j < k; j++ ) {\\n                var keya = attributeMapKeys[ j ];\\n                var attributeStack = attributeMap[ keya ];\\n                if ( attributeStack.length === 0 && attributeStack.globalDefault.applyPositionedUniform === undefined ) {\\n                    continue;\\n                }\\n                if ( attributeStack.globalDefault.getOrCreateUniforms !== undefined || attributeStack.globalDefault.writeToShader !== undefined ) {\\n                    types.push( keya );\\n                }\\n            }\\n\\n            for ( var i = 0, l = state.textureAttributeMapList.length; i < l; i++ ) {\\n                var attributesForUnit = state.textureAttributeMapList[ i ];\\n                if ( attributesForUnit === undefined ) {\\n                    continue;\\n                }\\n\\n                var textureAttributeMapKeys = attributesForUnit.getKeys();\\n                var textureAttributeMap = attributesForUnit;\\n\\n                for ( var h = 0, m = textureAttributeMapKeys.length; h < m; h++ ) {\\n                    var key = textureAttributeMapKeys[ h ];\\n                    var textureAttributeStack = textureAttributeMap[ key ];\\n                    if ( textureAttributeStack.length === 0 ) {\\n                        continue;\\n                    }\\n                    if ( textureAttributeStack.globalDefault.getOrCreateUniforms !== undefined || textureAttributeStack.globalDefault.writeToShader !== undefined ) {\\n                        types.push( key + i );\\n                    }\\n                }\\n            }\\n            return types;\\n        },\\n\\n        getActiveAttributeMapKeys: function ( state ) {\\n            var keys = [];\\n            var attributeMapKeys = state.attributeMap.getKeys();\\n            var attributeMap = state.attributeMap;\\n\\n            for ( var j = 0, k = attributeMapKeys.length; j < k; j++ ) {\\n                var keya = attributeMapKeys[ j ];\\n                var attributeStack = attributeMap[ keya ];\\n                if ( attributeStack.length === 0 && attributeStack.globalDefault.applyPositionedUniform === undefined ) {\\n                    continue;\\n                }\\n                if ( attributeStack.globalDefault.getOrCreateUniforms !== undefined || attributeStack.globalDefault.writeToShader !== undefined ) {\\n                    keys.push( keya );\\n                }\\n            }\\n            return keys;\\n        },\\n\\n        getActiveTextureAttributeMapKeys: function ( state ) {\\n            var textureAttributeKeys = [];\\n            for ( var i = 0, l = state.textureAttributeMapList.length; i < l; i++ ) {\\n                var attributesForUnit = state.textureAttributeMapList[ i ];\\n                if ( attributesForUnit === undefined ) {\\n                    continue;\\n                }\\n\\n                var textureAttributeMapKeys = attributesForUnit.getKeys();\\n                var textureAttributeMap = attributesForUnit;\\n\\n                textureAttributeKeys[ i ] = [];\\n                for ( var j = 0, m = textureAttributeMapKeys.length; j < m; j++ ) {\\n                    var key = textureAttributeMapKeys[ j ];\\n                    var textureAttributeStack = textureAttributeMap[ key ];\\n                    if ( textureAttributeStack.length === 0 ) {\\n                        continue;\\n                    }\\n                    if ( textureAttributeStack.globalDefault.getOrCreateUniforms !== undefined || textureAttributeStack.globalDefault.writeToShader !== undefined ) {\\n                        textureAttributeKeys[ i ].push( key );\\n                    }\\n                }\\n            }\\n            return textureAttributeKeys;\\n        },\\n\\n        // getActiveUniforms\\n        // return the list of uniforms enabled from the State\\n        // The idea behind this is to generate a shader depending on attributes/uniforms enabled by the user\\n        getActiveUniforms: function ( state, attributeKeys, textureAttributeKeys ) {\\n\\n            var uniformMap = new Map();\\n            var attributeMap = state.attributeMap;\\n\\n            for ( var i = 0, l = attributeKeys.length; i < l; i++ ) {\\n                var key = attributeKeys[ i ];\\n\\n                if ( attributeMap[ key ].globalDefault.getOrCreateUniforms === undefined ) {\\n                    continue;\\n                }\\n                var attributeUniforms = attributeMap[ key ].globalDefault.getOrCreateUniforms();\\n\\n                var attributeUniformKeys = attributeUniforms.getKeys();\\n                for ( var j = 0, m = attributeUniformKeys.length; j < m; j++ ) {\\n                    var name = attributeUniformKeys[ j ];\\n                    var uniform = attributeUniforms[ name ];\\n                    uniformMap[ uniform.name ] = uniform;\\n                }\\n            }\\n\\n            for ( var a = 0, n = textureAttributeKeys.length; a < n; a++ ) {\\n                var unitAttributekeys = textureAttributeKeys[ a ];\\n                if ( unitAttributekeys === undefined ) {\\n                    continue;\\n                }\\n                for ( var b = 0, o = unitAttributekeys.length; b < o; b++ ) {\\n                    var attrName = unitAttributekeys[ b ];\\n                    //if (state.textureAttributeMapList[a][attrName].globalDefault === undefined) {\\n                    //debugger;\\n                    //}\\n                    var textureAttribute = state.textureAttributeMapList[ a ][ attrName ].globalDefault;\\n                    if ( textureAttribute.getOrCreateUniforms === undefined ) {\\n                        continue;\\n                    }\\n                    var texUniformMap = textureAttribute.getOrCreateUniforms( a );\\n                    var texUniformMapKeys = texUniformMap.getKeys();\\n                    for ( var t = 0, tl = texUniformMapKeys.length; t < tl; t++ ) {\\n                        var tname = texUniformMapKeys[ t ];\\n                        var tuniform = texUniformMap[ tname ];\\n                        uniformMap[ tuniform.name ] = tuniform;\\n                    }\\n                }\\n            }\\n\\n            uniformMap.dirty();\\n            return uniformMap;\\n        },\\n\\n        getOrCreateProgram: function ( state ) {\\n\\n            // first get trace of active attribute and texture attributes to check\\n            // if we already have generated a program for this configuration\\n            var flattenKeys = this.getActiveTypeMember( state );\\n            for ( var i = 0, l = this.cache.length; i < l; ++i ) {\\n                if ( this.compareAttributeMap( flattenKeys, this.cache[ i ].flattenKeys ) === 0 ) {\\n                    return this.cache[ i ];\\n                }\\n            }\\n\\n            // extract valid attributes keys with more details\\n            var attributeKeys = this.getActiveAttributeMapKeys( state );\\n            var textureAttributeKeys = this.getActiveTextureAttributeMapKeys( state );\\n\\n\\n            var vertexshader = this.getOrCreateVertexShader( state, attributeKeys, textureAttributeKeys );\\n            var fragmentshader = this.getOrCreateFragmentShader( state, attributeKeys, textureAttributeKeys );\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vertexshader ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fragmentshader ) );\\n\\n            program.flattenKeys = flattenKeys;\\n            program.activeAttributeKeys = attributeKeys;\\n            program.activeTextureAttributeKeys = textureAttributeKeys;\\n            program.activeUniforms = this.getActiveUniforms( state, attributeKeys, textureAttributeKeys );\\n            program.generated = true;\\n\\n            Notify.debug( program.vertex.text );\\n            Notify.debug( program.fragment.text );\\n\\n            this.cache.push( program );\\n            return program;\\n        },\\n\\n        compareAttributeMap: function ( attributeKeys0, attributeKeys1 ) {\\n            var key;\\n            for ( var i = 0, l = attributeKeys0.length; i < l; i++ ) {\\n                key = attributeKeys0[ i ];\\n                if ( attributeKeys1.indexOf( key ) === -1 ) {\\n                    return 1;\\n                }\\n            }\\n            if ( attributeKeys1.length !== attributeKeys0.length ) {\\n                return -1;\\n            }\\n            return 0;\\n        },\\n\\n        fillTextureShader: function ( attributeMapList, validTextureAttributeKeys, mode ) {\\n            var shader = \\'\\';\\n            var commonTypeShader = {};\\n\\n            for ( var i = 0, l = validTextureAttributeKeys.length; i < l; i++ ) {\\n                var attributeKeys = validTextureAttributeKeys[ i ];\\n                if ( attributeKeys === undefined ) {\\n                    continue;\\n                }\\n                var attributeMap = attributeMapList[ i ];\\n                for ( var j = 0, m = attributeKeys.length; j < m; j++ ) {\\n                    var key = attributeKeys[ j ];\\n\\n                    var element = attributeMap[ key ].globalDefault;\\n\\n                    if ( element.generateShaderCommon !== undefined && commonTypeShader[ key ] === undefined ) {\\n                        shader += element.generateShaderCommon( i, mode );\\n                        commonTypeShader[ key ] = true;\\n                    }\\n\\n                    if ( element.generateShader ) {\\n                        shader += element.generateShader( i, mode );\\n                    }\\n                }\\n            }\\n            return shader;\\n        },\\n\\n        fillShader: function ( attributeMap, validAttributeKeys, mode ) {\\n            var shader = \\'\\';\\n            var commonTypeShader = {};\\n\\n            for ( var j = 0, m = validAttributeKeys.length; j < m; j++ ) {\\n                var key = validAttributeKeys[ j ];\\n                var element = attributeMap[ key ].globalDefault;\\n                var type = element.getType();\\n                if ( element.generateShaderCommon !== undefined && commonTypeShader[ type ] === undefined ) {\\n                    shader += element.generateShaderCommon( mode );\\n                    commonTypeShader[ type ] = true;\\n                }\\n\\n                if ( element.generateShader ) {\\n                    shader += element.generateShader( mode );\\n                }\\n            }\\n            return shader;\\n        },\\n\\n        getOrCreateVertexShader: function ( state, validAttributeKeys, validTextureAttributeKeys ) {\\n\\n            var modes = ShaderGeneratorStateSet.Type;\\n            var shader = [\\n                \\'\\',\\n                \\'#ifdef GL_ES\\',\\n                \\'precision highp float;\\',\\n                \\'#endif\\',\\n                \\'attribute vec3 Vertex;\\',\\n                \\'attribute vec4 Color;\\',\\n                \\'attribute vec3 Normal;\\',\\n                \\'uniform float ArrayColorEnabled;\\',\\n                \\'uniform mat4 ModelViewMatrix;\\',\\n                \\'uniform mat4 ProjectionMatrix;\\',\\n                \\'uniform mat4 NormalMatrix;\\',\\n                \\'varying vec4 VertexColor;\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.VertexInit );\\n\\n            var func = [\\n                \\'\\',\\n                \\'vec4 ftransform() {\\',\\n                \\'  return ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\\',\\n                \\'}\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            shader += func;\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.VertexFunction );\\n\\n            var body = [\\n                \\'\\',\\n                \\'void main(void) {\\',\\n                \\'  gl_Position = ftransform();\\',\\n                \\'  if (ArrayColorEnabled == 1.0)\\',\\n                \\'    VertexColor = Color;\\',\\n                \\'  else\\',\\n                \\'    VertexColor = vec4(1.0,1.0,1.0,1.0);\\',\\n                \\'  gl_PointSize = 1.0;\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            shader += body;\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.VertexMain );\\n\\n            shader += [\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            return shader;\\n        },\\n\\n        _writeShaderFromMode: function ( state, validAttributeKeys, validTextureAttributeKeys, mode ) {\\n            var str = \\'\\';\\n            str += this.fillTextureShader( state.textureAttributeMapList, validTextureAttributeKeys, mode );\\n            str += this.fillShader( state.attributeMap, validAttributeKeys, mode );\\n            return str;\\n        },\\n\\n        getOrCreateFragmentShader: function ( state, validAttributeKeys, validTextureAttributeKeys ) {\\n\\n            var shader = [\\n                \\'\\',\\n                \\'#ifdef GL_ES\\',\\n                \\'precision highp float;\\',\\n                \\'#endif\\',\\n                \\'varying vec4 VertexColor;\\',\\n                \\'uniform float ArrayColorEnabled;\\',\\n                \\'vec4 fragColor;\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var modes = ShaderGeneratorStateSet.Type;\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.FragmentInit );\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.FragmentFunction );\\n\\n            shader += [\\n                \\'void main(void) {\\',\\n                \\'  fragColor = VertexColor;\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.FragmentMain );\\n\\n            shader += this._writeShaderFromMode( state, validAttributeKeys, validTextureAttributeKeys, modes.FragmentEnd );\\n\\n            shader += [\\n                \\'\\',\\n                \\'  gl_FragColor = fragColor;\\',\\n                \\'}\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            return shader;\\n        }\\n    };\\n\\n    return ShaderGeneratorStateSet;\\n} );\\n\\n//# sourceURL=/osgShader/shaderGenerator/ShaderGeneratorStateSet.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine( \\'osgShader/ShaderGeneratorProxy\\',[\\n    \\'osgShader/shaderGenerator/ShaderGeneratorMaterial\\',\\n    \\'osgShader/shaderGenerator/ShaderGeneratorShadeless\\',\\n    \\'osgShader/shaderGenerator/ShaderGeneratorStateSet\\'\\n], function ( ShaderGeneratorMaterial, ShaderGeneratorShadeless, ShaderGeneratorStateSet ) {\\n\\n\\n    var ShaderGeneratorProxy = function ( createInstance ) {\\n        if ( !createInstance ) {\\n            if ( ShaderGeneratorProxy.instance ) {\\n                return ShaderGeneratorProxy.instance;\\n            }\\n            ShaderGeneratorProxy.instance = this;\\n        }\\n        // object of shader generators\\n        this._generators = {};\\n        this.addShaderGenerator( new ShaderGeneratorStateSet(), \\'default\\' );\\n        this.addShaderGenerator( new ShaderGeneratorMaterial(), \\'material\\' );\\n        this.addShaderGenerator( new ShaderGeneratorShadeless(), \\'shadeless\\' );\\n        this._current = this._generators[ \\'default\\' ];\\n        return this;\\n    };\\n\\n    ShaderGeneratorProxy.prototype = {\\n        getShaderGenerator: function ( name ) {\\n            return this._generators[ name ];\\n        },\\n        addShaderGenerator: function ( sg, name ) {\\n            this._generators[ name ] = sg;\\n        },\\n        setShaderGenerator: function ( name ) {\\n            var generator = this._generators[ name ];\\n            this._current = generator ? generator : this._generators[ \\'default\\' ];\\n        },\\n        setSceneContext: function ( scene ) {\\n            this._current.setSceneContext( scene );\\n        },\\n        getOrCreateProgram: function ( state ) {\\n            return this._current.getOrCreateProgram( state );\\n        }\\n    };\\n\\n    return ShaderGeneratorProxy;\\n} );\\n\\n//# sourceURL=/osgShader/ShaderGeneratorProxy.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine( \\'osg/Material\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Vec4\\',\\n    \\'osg/Uniform\\',\\n    \\'osgShader/ShaderGeneratorProxy\\',\\n    \\'osg/Map\\'\\n], function ( MACROUTILS, StateAttribute, Vec4, Uniform, ShaderGenerator, Map ) {\\n\\n    // Define a material attribute\\n\\n    var Material = function () {\\n        StateAttribute.call( this );\\n        this.ambient = [ 0.2, 0.2, 0.2, 1.0 ];\\n        this.diffuse = [ 0.8, 0.8, 0.8, 1.0 ];\\n        this.specular = [ 0.0, 0.0, 0.0, 1.0 ];\\n        this.emission = [ 0.0, 0.0, 0.0, 1.0 ];\\n        this.shininess = 12.5;\\n        this._shadeless = false;\\n    };\\n\\n    Material.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( StateAttribute.prototype, {\\n        setEmission: function ( a ) {\\n            Vec4.copy( a, this.emission );\\n            this._dirty = true;\\n        },\\n        setAmbient: function ( a ) {\\n            Vec4.copy( a, this.ambient );\\n            this._dirty = true;\\n        },\\n        setSpecular: function ( a ) {\\n            Vec4.copy( a, this.specular );\\n            this._dirty = true;\\n        },\\n        setDiffuse: function ( a ) {\\n            Vec4.copy( a, this.diffuse );\\n            this._dirty = true;\\n        },\\n        setShininess: function ( a ) {\\n            this.shininess = a;\\n            this._dirty = true;\\n        },\\n\\n        getEmission: function () {\\n            return this.emission;\\n        },\\n        getAmbient: function () {\\n            return this.ambient;\\n        },\\n        getSpecular: function () {\\n            return this.specular;\\n        },\\n        getDiffuse: function () {\\n            return this.diffuse;\\n        },\\n        getShininess: function () {\\n            return this.shininess;\\n        },\\n\\n        attributeType: \\'Material\\',\\n\\n        cloneType: function () {\\n            return new Material();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        getParameterName: function ( name ) {\\n            return this.getType() + \\'_uniform_\\' + name;\\n        },\\n\\n        getOrCreateUniforms: function () {\\n\\n            var obj = Material;\\n            if ( obj.uniforms ) return obj.uniforms;\\n\\n            var uniformList = {\\n                \\'ambient\\': \\'createFloat1\\',\\n                \\'diffuse\\': \\'createFloat1\\',\\n                \\'specular\\': \\'createFloat1\\',\\n                \\'emission\\': \\'createFloat1\\',\\n                \\'shininess\\': \\'createFloat1\\'\\n            };\\n\\n            var uniforms = {};\\n            Object.keys( uniformList ).forEach( function ( key ) {\\n\\n                var type = uniformList[ key ];\\n                var func = Uniform[ type ];\\n                uniforms[ key ] = func( this.getParameterName( key ) );\\n\\n            }.bind( this ) );\\n\\n            obj.uniforms = new Map( uniforms );\\n            return obj.uniforms;\\n        },\\n\\n\\n        apply: function ( /*state*/) {\\n            var uniforms = this.getOrCreateUniforms();\\n\\n            uniforms.ambient.set( this.ambient );\\n            uniforms.diffuse.set( this.diffuse );\\n            uniforms.specular.set( this.specular );\\n            uniforms.emission.set( this.emission );\\n            uniforms.shininess.set( [ this.shininess ] );\\n\\n            this.setDirty( false );\\n        },\\n\\n        getHash: function () {\\n            return this.attributeType + this.ambient.toString() + this.diffuse.toString() + this.specular.toString() + this.emission.toString() + this._shadeless.toString();\\n        }\\n\\n\\n    } ), \\'osg\\', \\'Material\\' );\\n\\n    return Material;\\n} );\\n\\n//# sourceURL=/osg/Material.js\");\n\n",
    "eval(\"define( \\'osg/Math\\',[], function () {\\n\\n    var clamp = function ( x, min, max ) {\\n        // http://jsperf.com/math-clamp\\n        // http://jsperf.com/clamping-methods/2\\n        return Math.min( max, Math.max( min, x ) );\\n    };\\n\\n    var smoothStep = function ( edge0, edge1, x ) {\\n        var t = clamp( ( x - edge0 ) / ( edge1 - edge0 ), 0.0, 1.0 );\\n        return t * t * ( 3.0 - 2.0 * t );\\n    };\\n\\n    return {\\n        clamp: clamp,\\n        smoothStep: smoothStep\\n    };\\n} );\\n\\n//# sourceURL=/osg/Math.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/shaderNode/environment\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n    var TextureSpheremap = function ( sampler, uv, output ) {\\n        Node.call( this, sampler, uv, output );\\n    };\\n\\n    TextureSpheremap.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n\\n        type: \\'TextureSpheremap\\',\\n\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'#pragma include \\\"environment.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n\\n        computeFragment: function() {\\n            return this.getOutput().getVariable() + \\' = TextureSpheremap( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() + \\'.xyz);\\';\\n        }\\n\\n    } );\\n\\n\\n    var TextureSpheremapHdr = function ( sampler, uv, output ) {\\n        Node.call( this, sampler, uv, output );\\n    };\\n\\n    TextureSpheremapHdr.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n\\n        type: \\'TextureSpheremapHdr\\',\\n\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'#pragma include \\\"environment.glsl\\\"\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n\\n        computeFragment: function() {\\n            return this.getOutput().getVariable() + \\' = TextureSpheremapHdr( \\' + this._sampler.getVariable() + \\' , \\' + this._uv.getVariable() +\\'.xyz);\\';\\n        }\\n\\n    } );\\n\\n\\n    return {\\n        \\'TextureSpheremap\\': TextureSpheremap,\\n        \\'TextureSpheremapHdr\\': TextureSpheremapHdr\\n    };\\n});\\n\\n//# sourceURL=/osgShader/shaderNode/environment.js\");\n\n",
    "eval(\"/*global define */\\n\\ndefine ( \\'osgShader/shaderNode/shadows\\',[\\n    \\'osg/Utils\\',\\n    \\'osgShader/shaderNode/Node\\'\\n\\n], function ( MACROUTILS, Node ) {\\n\\n\\n    // TODO : use GLSL libraries shadow.glsl\\n    var ShadowNode = function ( material, shadow ) {\\n        Node.call( this );\\n        this._shadow = shadow;\\n        this._material = material;\\n    };\\n\\n    ShadowNode.prototype = MACROUTILS.objectInherit( Node.prototype, {\\n        type: \\'ShadowNode\\',\\n\\n        _inputMaps: [ \\'texture_size\\', \\'bias\\' ],\\n\\n        // TODO: generate auto matically getters/setter using above map.\\n        connect: function ( name, i ) {\\n            this._inputs[ this._inputMaps.indexOf( name ) ] = i;\\n        },\\n        getConnection: function ( name /*, i */ ) {\\n            return this._inputs[ this._inputMaps.indexOf( name ) ];\\n        },\\n\\n        globalFunctionDeclaration: function () {\\n            return [\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n        },\\n\\n        computeVertex: function () {\\n            var str = [ \\'\\',\\n                        \\'\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        },\\n\\n        computeFragment: function () {\\n            var str = [ \\'\\',\\n                        \\'\\' ].join( \\'\\\\n\\' );\\n            return str;\\n        }\\n    } );\\n\\n    return ShadowNode;\\n} );\\n\\n//# sourceURL=/osgShader/shaderNode/shadows.js\");\n\n",
    "eval(\"define( \\'osg/Shape\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/BufferArray\\',\\n    \\'osg/Geometry\\',\\n    \\'osg/PrimitiveSet\\',\\n    \\'osg/DrawArrays\\',\\n    \\'osg/DrawElements\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Utils\\'\\n], function ( Notify, StateAttribute, Vec3, Uniform, BufferArray, Geometry, PrimitiveSet, DrawArrays, DrawElements, Program, Shader, MACROUTILS ) {\\n\\n    \\'use strict\\';\\n\\n    /**\\n     * Create a Textured Box on the given center with given size\\n     * @name createTexturedBox\\n     */\\n    var createTexturedBoxGeometry = function ( cx, cy, cz,\\n        sx, sy, sz ) {\\n\\n        var centerx = cx !== undefined ? cx : 0.0;\\n        var centery = cy !== undefined ? cy : 0.0;\\n        var centerz = cz !== undefined ? cz : 0.0;\\n\\n        var sizex = sx !== undefined ? sx : 1.0;\\n        var sizey = sy !== undefined ? sy : 1.0;\\n        var sizez = sz !== undefined ? sz : 1.0;\\n\\n        var g = new Geometry();\\n        var dx, dy, dz;\\n        dx = sizex / 2.0;\\n        dy = sizey / 2.0;\\n        dz = sizez / 2.0;\\n\\n        var vertexes = new MACROUTILS.Float32Array( 72 );\\n        var uv = new MACROUTILS.Float32Array( 48 );\\n        var normal = new MACROUTILS.Float32Array( 72 );\\n\\n        // -ve y plane\\n        vertexes[ 0 ] = centerx - dx;\\n        vertexes[ 1 ] = centery - dy;\\n        vertexes[ 2 ] = centerz + dz;\\n        normal[ 0 ] = 0.0;\\n        normal[ 1 ] = -1.0;\\n        normal[ 2 ] = 0.0;\\n        uv[ 0 ] = 0.0;\\n        uv[ 1 ] = 1.0;\\n\\n        vertexes[ 3 ] = centerx - dx;\\n        vertexes[ 4 ] = centery - dy;\\n        vertexes[ 5 ] = centerz - dz;\\n        normal[ 3 ] = 0.0;\\n        normal[ 4 ] = -1.0;\\n        normal[ 5 ] = 0.0;\\n        uv[ 2 ] = 0.0;\\n        uv[ 3 ] = 0.0;\\n\\n        vertexes[ 6 ] = centerx + dx;\\n        vertexes[ 7 ] = centery - dy;\\n        vertexes[ 8 ] = centerz - dz;\\n        normal[ 6 ] = 0.0;\\n        normal[ 7 ] = -1.0;\\n        normal[ 8 ] = 0.0;\\n        uv[ 4 ] = 1.0;\\n        uv[ 5 ] = 0.0;\\n\\n        vertexes[ 9 ] = centerx + dx;\\n        vertexes[ 10 ] = centery - dy;\\n        vertexes[ 11 ] = centerz + dz;\\n        normal[ 9 ] = 0.0;\\n        normal[ 10 ] = -1.0;\\n        normal[ 11 ] = 0.0;\\n        uv[ 6 ] = 1.0;\\n        uv[ 7 ] = 1.0;\\n\\n\\n        // +ve y plane\\n        vertexes[ 12 ] = centerx + dx;\\n        vertexes[ 13 ] = centery + dy;\\n        vertexes[ 14 ] = centerz + dz;\\n        normal[ 12 ] = 0.0;\\n        normal[ 13 ] = 1.0;\\n        normal[ 14 ] = 0.0;\\n        uv[ 8 ] = 0.0;\\n        uv[ 9 ] = 1.0;\\n\\n        vertexes[ 15 ] = centerx + dx;\\n        vertexes[ 16 ] = centery + dy;\\n        vertexes[ 17 ] = centerz - dz;\\n        normal[ 15 ] = 0.0;\\n        normal[ 16 ] = 1.0;\\n        normal[ 17 ] = 0.0;\\n        uv[ 10 ] = 0.0;\\n        uv[ 11 ] = 0.0;\\n\\n        vertexes[ 18 ] = centerx - dx;\\n        vertexes[ 19 ] = centery + dy;\\n        vertexes[ 20 ] = centerz - dz;\\n        normal[ 18 ] = 0.0;\\n        normal[ 19 ] = 1.0;\\n        normal[ 20 ] = 0.0;\\n        uv[ 12 ] = 1.0;\\n        uv[ 13 ] = 0.0;\\n\\n        vertexes[ 21 ] = centerx - dx;\\n        vertexes[ 22 ] = centery + dy;\\n        vertexes[ 23 ] = centerz + dz;\\n        normal[ 21 ] = 0.0;\\n        normal[ 22 ] = 1.0;\\n        normal[ 23 ] = 0.0;\\n        uv[ 14 ] = 1.0;\\n        uv[ 15 ] = 1.0;\\n\\n\\n        // +ve x plane\\n        vertexes[ 24 ] = centerx + dx;\\n        vertexes[ 25 ] = centery - dy;\\n        vertexes[ 26 ] = centerz + dz;\\n        normal[ 24 ] = 1.0;\\n        normal[ 25 ] = 0.0;\\n        normal[ 26 ] = 0.0;\\n        uv[ 16 ] = 0.0;\\n        uv[ 17 ] = 1.0;\\n\\n        vertexes[ 27 ] = centerx + dx;\\n        vertexes[ 28 ] = centery - dy;\\n        vertexes[ 29 ] = centerz - dz;\\n        normal[ 27 ] = 1.0;\\n        normal[ 28 ] = 0.0;\\n        normal[ 29 ] = 0.0;\\n        uv[ 18 ] = 0.0;\\n        uv[ 19 ] = 0.0;\\n\\n        vertexes[ 30 ] = centerx + dx;\\n        vertexes[ 31 ] = centery + dy;\\n        vertexes[ 32 ] = centerz - dz;\\n        normal[ 30 ] = 1.0;\\n        normal[ 31 ] = 0.0;\\n        normal[ 32 ] = 0.0;\\n        uv[ 20 ] = 1.0;\\n        uv[ 21 ] = 0.0;\\n\\n        vertexes[ 33 ] = centerx + dx;\\n        vertexes[ 34 ] = centery + dy;\\n        vertexes[ 35 ] = centerz + dz;\\n        normal[ 33 ] = 1.0;\\n        normal[ 34 ] = 0.0;\\n        normal[ 35 ] = 0.0;\\n        uv[ 22 ] = 1.0;\\n        uv[ 23 ] = 1.0;\\n\\n        // -ve x plane\\n        vertexes[ 36 ] = centerx - dx;\\n        vertexes[ 37 ] = centery + dy;\\n        vertexes[ 38 ] = centerz + dz;\\n        normal[ 36 ] = -1.0;\\n        normal[ 37 ] = 0.0;\\n        normal[ 38 ] = 0.0;\\n        uv[ 24 ] = 0.0;\\n        uv[ 25 ] = 1.0;\\n\\n        vertexes[ 39 ] = centerx - dx;\\n        vertexes[ 40 ] = centery + dy;\\n        vertexes[ 41 ] = centerz - dz;\\n        normal[ 39 ] = -1.0;\\n        normal[ 40 ] = 0.0;\\n        normal[ 41 ] = 0.0;\\n        uv[ 26 ] = 0.0;\\n        uv[ 27 ] = 0.0;\\n\\n        vertexes[ 42 ] = centerx - dx;\\n        vertexes[ 43 ] = centery - dy;\\n        vertexes[ 44 ] = centerz - dz;\\n        normal[ 42 ] = -1.0;\\n        normal[ 43 ] = 0.0;\\n        normal[ 44 ] = 0.0;\\n        uv[ 28 ] = 1.0;\\n        uv[ 29 ] = 0.0;\\n\\n        vertexes[ 45 ] = centerx - dx;\\n        vertexes[ 46 ] = centery - dy;\\n        vertexes[ 47 ] = centerz + dz;\\n        normal[ 45 ] = -1.0;\\n        normal[ 46 ] = 0.0;\\n        normal[ 47 ] = 0.0;\\n        uv[ 30 ] = 1.0;\\n        uv[ 31 ] = 1.0;\\n\\n        // top\\n        // +ve z plane\\n        vertexes[ 48 ] = centerx - dx;\\n        vertexes[ 49 ] = centery + dy;\\n        vertexes[ 50 ] = centerz + dz;\\n        normal[ 48 ] = 0.0;\\n        normal[ 49 ] = 0.0;\\n        normal[ 50 ] = 1.0;\\n        uv[ 32 ] = 0.0;\\n        uv[ 33 ] = 1.0;\\n\\n        vertexes[ 51 ] = centerx - dx;\\n        vertexes[ 52 ] = centery - dy;\\n        vertexes[ 53 ] = centerz + dz;\\n        normal[ 51 ] = 0.0;\\n        normal[ 52 ] = 0.0;\\n        normal[ 53 ] = 1.0;\\n        uv[ 34 ] = 0.0;\\n        uv[ 35 ] = 0.0;\\n\\n        vertexes[ 54 ] = centerx + dx;\\n        vertexes[ 55 ] = centery - dy;\\n        vertexes[ 56 ] = centerz + dz;\\n        normal[ 54 ] = 0.0;\\n        normal[ 55 ] = 0.0;\\n        normal[ 56 ] = 1.0;\\n        uv[ 36 ] = 1.0;\\n        uv[ 37 ] = 0.0;\\n\\n        vertexes[ 57 ] = centerx + dx;\\n        vertexes[ 58 ] = centery + dy;\\n        vertexes[ 59 ] = centerz + dz;\\n        normal[ 57 ] = 0.0;\\n        normal[ 58 ] = 0.0;\\n        normal[ 59 ] = 1.0;\\n        uv[ 38 ] = 1.0;\\n        uv[ 39 ] = 1.0;\\n\\n        // bottom\\n        // -ve z plane\\n        vertexes[ 60 ] = centerx + dx;\\n        vertexes[ 61 ] = centery + dy;\\n        vertexes[ 62 ] = centerz - dz;\\n        normal[ 60 ] = 0.0;\\n        normal[ 61 ] = 0.0;\\n        normal[ 62 ] = -1.0;\\n        uv[ 40 ] = 0.0;\\n        uv[ 41 ] = 1.0;\\n\\n        vertexes[ 63 ] = centerx + dx;\\n        vertexes[ 64 ] = centery - dy;\\n        vertexes[ 65 ] = centerz - dz;\\n        normal[ 63 ] = 0.0;\\n        normal[ 64 ] = 0.0;\\n        normal[ 65 ] = -1.0;\\n        uv[ 42 ] = 0.0;\\n        uv[ 43 ] = 0.0;\\n\\n        vertexes[ 66 ] = centerx - dx;\\n        vertexes[ 67 ] = centery - dy;\\n        vertexes[ 68 ] = centerz - dz;\\n        normal[ 66 ] = 0.0;\\n        normal[ 67 ] = 0.0;\\n        normal[ 68 ] = -1.0;\\n        uv[ 44 ] = 1.0;\\n        uv[ 45 ] = 0.0;\\n\\n        vertexes[ 69 ] = centerx - dx;\\n        vertexes[ 70 ] = centery + dy;\\n        vertexes[ 71 ] = centerz - dz;\\n        normal[ 69 ] = 0.0;\\n        normal[ 70 ] = 0.0;\\n        normal[ 71 ] = -1.0;\\n        uv[ 46 ] = 1.0;\\n        uv[ 47 ] = 1.0;\\n\\n        var indexes = new MACROUTILS.Uint16Array( 36 );\\n        indexes[ 0 ] = 0;\\n        indexes[ 1 ] = 1;\\n        indexes[ 2 ] = 2;\\n        indexes[ 3 ] = 0;\\n        indexes[ 4 ] = 2;\\n        indexes[ 5 ] = 3;\\n\\n        indexes[ 6 ] = 4;\\n        indexes[ 7 ] = 5;\\n        indexes[ 8 ] = 6;\\n        indexes[ 9 ] = 4;\\n        indexes[ 10 ] = 6;\\n        indexes[ 11 ] = 7;\\n\\n        indexes[ 12 ] = 8;\\n        indexes[ 13 ] = 9;\\n        indexes[ 14 ] = 10;\\n        indexes[ 15 ] = 8;\\n        indexes[ 16 ] = 10;\\n        indexes[ 17 ] = 11;\\n\\n        indexes[ 18 ] = 12;\\n        indexes[ 19 ] = 13;\\n        indexes[ 20 ] = 14;\\n        indexes[ 21 ] = 12;\\n        indexes[ 22 ] = 14;\\n        indexes[ 23 ] = 15;\\n\\n        indexes[ 24 ] = 16;\\n        indexes[ 25 ] = 17;\\n        indexes[ 26 ] = 18;\\n        indexes[ 27 ] = 16;\\n        indexes[ 28 ] = 18;\\n        indexes[ 29 ] = 19;\\n\\n        indexes[ 30 ] = 20;\\n        indexes[ 31 ] = 21;\\n        indexes[ 32 ] = 22;\\n        indexes[ 33 ] = 20;\\n        indexes[ 34 ] = 22;\\n        indexes[ 35 ] = 23;\\n\\n        g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\\n        g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );\\n        g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uv, 2 );\\n\\n        var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );\\n        g.getPrimitives().push( primitive );\\n        return g;\\n    };\\n\\n    var createTexturedQuadGeometry = function ( cornerx, cornery, cornerz,\\n        wx, wy, wz,\\n        hx, hy, hz,\\n        l, b, r, t ) {\\n\\n        if ( r === undefined && t === undefined ) {\\n            r = l;\\n            t = b;\\n            l = 0.0;\\n            b = 0.0;\\n        }\\n\\n        var g = new Geometry();\\n\\n        var vertexes = new MACROUTILS.Float32Array( 12 );\\n        vertexes[ 0 ] = cornerx + hx;\\n        vertexes[ 1 ] = cornery + hy;\\n        vertexes[ 2 ] = cornerz + hz;\\n\\n        vertexes[ 3 ] = cornerx;\\n        vertexes[ 4 ] = cornery;\\n        vertexes[ 5 ] = cornerz;\\n\\n        vertexes[ 6 ] = cornerx + wx;\\n        vertexes[ 7 ] = cornery + wy;\\n        vertexes[ 8 ] = cornerz + wz;\\n\\n        vertexes[ 9 ] = cornerx + wx + hx;\\n        vertexes[ 10 ] = cornery + wy + hy;\\n        vertexes[ 11 ] = cornerz + wz + hz;\\n\\n        if ( r === undefined ) {\\n            r = 1.0;\\n        }\\n        if ( t === undefined ) {\\n            t = 1.0;\\n        }\\n\\n        var uvs = new MACROUTILS.Float32Array( 8 );\\n        uvs[ 0 ] = l;\\n        uvs[ 1 ] = t;\\n\\n        uvs[ 2 ] = l;\\n        uvs[ 3 ] = b;\\n\\n        uvs[ 4 ] = r;\\n        uvs[ 5 ] = b;\\n\\n        uvs[ 6 ] = r;\\n        uvs[ 7 ] = t;\\n\\n        var n = Vec3.cross( [ wx, wy, wz ], [ hx, hy, hz ], [ 0.0, 0.0, 0.0 ] );\\n        var normal = new MACROUTILS.Float32Array( 12 );\\n        normal[ 0 ] = n[ 0 ];\\n        normal[ 1 ] = n[ 1 ];\\n        normal[ 2 ] = n[ 2 ];\\n\\n        normal[ 3 ] = n[ 0 ];\\n        normal[ 4 ] = n[ 1 ];\\n        normal[ 5 ] = n[ 2 ];\\n\\n        normal[ 6 ] = n[ 0 ];\\n        normal[ 7 ] = n[ 1 ];\\n        normal[ 8 ] = n[ 2 ];\\n\\n        normal[ 9 ] = n[ 0 ];\\n        normal[ 10 ] = n[ 1 ];\\n        normal[ 11 ] = n[ 2 ];\\n\\n\\n        var indexes = new MACROUTILS.Uint16Array( 6 );\\n        indexes[ 0 ] = 0;\\n        indexes[ 1 ] = 1;\\n        indexes[ 2 ] = 2;\\n        indexes[ 3 ] = 0;\\n        indexes[ 4 ] = 2;\\n        indexes[ 5 ] = 3;\\n\\n        g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\\n        g.getAttributes().Normal = new BufferArray( BufferArray.ARRAY_BUFFER, normal, 3 );\\n        g.getAttributes().TexCoord0 = new BufferArray( BufferArray.ARRAY_BUFFER, uvs, 2 );\\n\\n        var primitive = new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( BufferArray.ELEMENT_ARRAY_BUFFER, indexes, 1 ) );\\n        g.getPrimitives().push( primitive );\\n        return g;\\n    };\\n\\n    var createTexturedBox = function ( centerx, centery, centerz,\\n        sizex, sizey, sizez ) {\\n        Notify.log( \\'createTexturedBox is deprecated use instead createTexturedBoxGeometry\\' );\\n        return createTexturedBoxGeometry( centerx, centery, centerz,\\n            sizex, sizey, sizez );\\n    };\\n\\n    var createTexturedQuad = function ( cornerx, cornery, cornerz,\\n        wx, wy, wz,\\n        hx, hy, hz,\\n        l, b, r, t ) {\\n        Notify.log( \\'createTexturedQuad is deprecated use instead createTexturedQuadGeometry\\' );\\n        return createTexturedQuadGeometry( cornerx, cornery, cornerz,\\n            wx, wy, wz,\\n            hx, hy, hz,\\n            l, b, r, t );\\n    };\\n\\n    var createAxisGeometry = function ( size ) {\\n        if ( size === undefined ) {\\n            size = 5.0;\\n        }\\n        if ( createAxisGeometry.getShader === undefined ) {\\n            createAxisGeometry.getShader = function () {\\n                if ( createAxisGeometry.getShader.program === undefined ) {\\n                    var vertexshader = [\\n                        \\'#ifdef GL_ES\\',\\n                        \\'precision highp float;\\',\\n                        \\'#endif\\',\\n                        \\'attribute vec3 Vertex;\\',\\n                        \\'attribute vec4 Color;\\',\\n                        \\'uniform mat4 ModelViewMatrix;\\',\\n                        \\'uniform mat4 ProjectionMatrix;\\',\\n                        \\'\\',\\n                        \\'varying vec4 FragColor;\\',\\n                        \\'\\',\\n                        \\'vec4 ftransform() {\\',\\n                        \\'return ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\\',\\n                        \\'}\\',\\n                        \\'\\',\\n                        \\'void main(void) {\\',\\n                        \\'gl_Position = ftransform();\\',\\n                        \\'FragColor = Color;\\',\\n                        \\'}\\'\\n                    ].join( \\'\\\\n\\' );\\n\\n                    var fragmentshader = [\\n                        \\'#ifdef GL_ES\\',\\n                        \\'precision highp float;\\',\\n                        \\'#endif\\',\\n                        \\'varying vec4 FragColor;\\',\\n\\n                        \\'void main(void) {\\',\\n                        \\'gl_FragColor = FragColor;\\',\\n                        \\'}\\'\\n                    ].join( \\'\\\\n\\' );\\n\\n                    var program = new Program( new Shader( \\'VERTEX_SHADER\\', vertexshader ),\\n                        new Shader( \\'FRAGMENT_SHADER\\', fragmentshader ) );\\n                    createAxisGeometry.getShader.program = program;\\n                }\\n                return createAxisGeometry.getShader.program;\\n            };\\n        }\\n\\n        var g = new Geometry();\\n\\n        var vertexes = new MACROUTILS.Float32Array( 18 );\\n        vertexes[ 3 ] = size;\\n        vertexes[ 10 ] = size;\\n        vertexes[ 17 ] = size;\\n\\n        var colors = new MACROUTILS.Float32Array( 24 );\\n        //red color\\n        colors[ 0 ] = colors[ 3 ] = 1.0;\\n        colors[ 4 ] = colors[ 4 + 3 ] = 1.0;\\n        //green color\\n        colors[ 4 * 2 + 1 ] = colors[ 4 * 2 + 3 ] = 1.0;\\n        colors[ 4 * 3 + 1 ] = colors[ 4 * 3 + 3 ] = 1.0;\\n        //blue color\\n        colors[ 4 * 4 + 2 ] = colors[ 4 * 4 + 3 ] = 1.0;\\n        colors[ 4 * 5 + 2 ] = colors[ 4 * 5 + 3 ] = 1.0;\\n\\n        g.getAttributes().Vertex = new BufferArray( BufferArray.ARRAY_BUFFER, vertexes, 3 );\\n        g.getAttributes().Color = new BufferArray( BufferArray.ARRAY_BUFFER, colors, 4 );\\n\\n        var primitive = new DrawArrays( PrimitiveSet.LINES, 0, 6 );\\n        g.getPrimitives().push( primitive );\\n        g.getOrCreateStateSet().setAttributeAndMode( createAxisGeometry.getShader() );\\n\\n        return g;\\n    };\\n\\n    /**\\n     * Create a Textured Sphere on the given center with given radius\\n     * @name createTexturedSphere\\n     * @author Darrell Esau\\n     */\\n    var createTexturedSphere = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n        radius = radius || 50.0;\\n\\n        phiStart = phiStart !== undefined ? phiStart : 0.0;\\n        phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\n\\n        thetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\n        thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\n\\n        var segmentsX = Math.max( 3, Math.floor( widthSegments ) || 8 );\\n        var segmentsY = Math.max( 2, Math.floor( heightSegments ) || 6 );\\n\\n        var useDrawArrays = ( ( segmentsX * segmentsY ) / 3 ) >= 65536;\\n        var nbPrim = useDrawArrays ? segmentsX * segmentsY * 6 : segmentsX * segmentsY * 4;\\n        var fullVerticesList = new MACROUTILS.Float32Array( nbPrim * 3 );\\n        var fullNormalsList = new MACROUTILS.Float32Array( nbPrim * 3 );\\n        var fullUVList = new MACROUTILS.Float32Array( nbPrim * 2 );\\n        var indexes = !useDrawArrays ? new MACROUTILS.Uint16Array( segmentsX * segmentsY * 6 ) : undefined;\\n        var vtxCount = 0;\\n        var triCount = 0;\\n\\n        var v1 = new MACROUTILS.Float32Array( 3 );\\n        var v2 = new MACROUTILS.Float32Array( 3 );\\n        var v3 = new MACROUTILS.Float32Array( 3 );\\n        var v4 = new MACROUTILS.Float32Array( 3 );\\n        var n1 = new MACROUTILS.Float32Array( 3 );\\n        var n2 = new MACROUTILS.Float32Array( 3 );\\n        var n3 = new MACROUTILS.Float32Array( 3 );\\n        var n4 = new MACROUTILS.Float32Array( 3 );\\n        var uv1 = new MACROUTILS.Float32Array( 2 );\\n        var uv2 = new MACROUTILS.Float32Array( 2 );\\n        var uv3 = new MACROUTILS.Float32Array( 2 );\\n        var uv4 = new MACROUTILS.Float32Array( 2 );\\n        var getCoordAndUvSphere = function ( u, v, coord, norm, uv ) {\\n            coord[ 0 ] = -radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n            coord[ 1 ] = radius * Math.cos( thetaStart + v * thetaLength );\\n            coord[ 2 ] = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n            Vec3.normalize( coord, norm );\\n            uv[ 0 ] = u;\\n            uv[ 1 ] = 1 - v;\\n        };\\n        for ( var y = 0; y < segmentsY; y++ ) {\\n            for ( var x = 0; x < segmentsX; x++ ) {\\n                getCoordAndUvSphere( ( x + 1 ) / segmentsX, y / segmentsY, v1, n1, uv1 );\\n                getCoordAndUvSphere( x / segmentsX, y / segmentsY, v2, n2, uv2 );\\n                getCoordAndUvSphere( x / segmentsX, ( y + 1 ) / segmentsY, v3, n3, uv3 );\\n                getCoordAndUvSphere( ( x + 1 ) / segmentsX, ( y + 1 ) / segmentsY, v4, n4, uv4 );\\n\\n                var idv = vtxCount * 3;\\n                fullVerticesList[ idv ] = v1[ 0 ];\\n                fullVerticesList[ idv + 1 ] = v1[ 1 ];\\n                fullVerticesList[ idv + 2 ] = v1[ 2 ];\\n                fullVerticesList[ idv + 3 ] = v2[ 0 ];\\n                fullVerticesList[ idv + 4 ] = v2[ 1 ];\\n                fullVerticesList[ idv + 5 ] = v2[ 2 ];\\n                fullVerticesList[ idv + 6 ] = v3[ 0 ];\\n                fullVerticesList[ idv + 7 ] = v3[ 1 ];\\n                fullVerticesList[ idv + 8 ] = v3[ 2 ];\\n\\n                fullNormalsList[ idv ] = n1[ 0 ];\\n                fullNormalsList[ idv + 1 ] = n1[ 1 ];\\n                fullNormalsList[ idv + 2 ] = n1[ 2 ];\\n                fullNormalsList[ idv + 3 ] = n2[ 0 ];\\n                fullNormalsList[ idv + 4 ] = n2[ 1 ];\\n                fullNormalsList[ idv + 5 ] = n2[ 2 ];\\n                fullNormalsList[ idv + 6 ] = n3[ 0 ];\\n                fullNormalsList[ idv + 7 ] = n3[ 1 ];\\n                fullNormalsList[ idv + 8 ] = n3[ 2 ];\\n\\n                var idu = vtxCount * 2;\\n                fullUVList[ idu ] = uv1[ 0 ];\\n                fullUVList[ idu + 1 ] = uv1[ 1 ];\\n                fullUVList[ idu + 2 ] = uv2[ 0 ];\\n                fullUVList[ idu + 3 ] = uv2[ 1 ];\\n                fullUVList[ idu + 4 ] = uv3[ 0 ];\\n                fullUVList[ idu + 5 ] = uv3[ 1 ];\\n\\n                vtxCount += 3;\\n                if ( useDrawArrays ) {\\n                    idv = vtxCount * 3;\\n                    fullVerticesList[ idv ] = v1[ 0 ];\\n                    fullVerticesList[ idv + 1 ] = v1[ 1 ];\\n                    fullVerticesList[ idv + 2 ] = v1[ 2 ];\\n                    fullVerticesList[ idv + 3 ] = v3[ 0 ];\\n                    fullVerticesList[ idv + 4 ] = v3[ 1 ];\\n                    fullVerticesList[ idv + 5 ] = v3[ 2 ];\\n                    fullVerticesList[ idv + 6 ] = v4[ 0 ];\\n                    fullVerticesList[ idv + 7 ] = v4[ 1 ];\\n                    fullVerticesList[ idv + 8 ] = v4[ 2 ];\\n\\n                    fullNormalsList[ idv ] = n1[ 0 ];\\n                    fullNormalsList[ idv + 1 ] = n1[ 1 ];\\n                    fullNormalsList[ idv + 2 ] = n1[ 2 ];\\n                    fullNormalsList[ idv + 3 ] = n3[ 0 ];\\n                    fullNormalsList[ idv + 4 ] = n3[ 1 ];\\n                    fullNormalsList[ idv + 5 ] = n3[ 2 ];\\n                    fullNormalsList[ idv + 6 ] = n4[ 0 ];\\n                    fullNormalsList[ idv + 7 ] = n4[ 1 ];\\n                    fullNormalsList[ idv + 8 ] = n4[ 2 ];\\n\\n                    idu = vtxCount * 2;\\n                    fullUVList[ idu ] = uv1[ 0 ];\\n                    fullUVList[ idu + 1 ] = uv1[ 1 ];\\n                    fullUVList[ idu + 2 ] = uv3[ 0 ];\\n                    fullUVList[ idu + 3 ] = uv3[ 1 ];\\n                    fullUVList[ idu + 4 ] = uv4[ 0 ];\\n                    fullUVList[ idu + 5 ] = uv4[ 1 ];\\n                    vtxCount += 3;\\n                } else {\\n                    idv = vtxCount * 3;\\n                    fullVerticesList[ idv ] = v4[ 0 ];\\n                    fullVerticesList[ idv + 1 ] = v4[ 1 ];\\n                    fullVerticesList[ idv + 2 ] = v4[ 2 ];\\n\\n                    fullNormalsList[ idv ] = n4[ 0 ];\\n                    fullNormalsList[ idv + 1 ] = n4[ 1 ];\\n                    fullNormalsList[ idv + 2 ] = n4[ 2 ];\\n\\n                    idu = vtxCount * 2;\\n                    fullUVList[ idu ] = uv4[ 0 ];\\n                    fullUVList[ idu + 1 ] = uv4[ 1 ];\\n\\n                    var iStart = triCount * 3;\\n                    var tristart = vtxCount - 3;\\n                    indexes[ iStart ] = tristart;\\n                    indexes[ iStart + 1 ] = tristart + 1;\\n                    indexes[ iStart + 2 ] = tristart + 2;\\n                    indexes[ iStart + 3 ] = tristart;\\n                    indexes[ iStart + 4 ] = tristart + 2;\\n                    indexes[ iStart + 5 ] = tristart + 3;\\n                    triCount += 2;\\n                    vtxCount += 1;\\n                }\\n            }\\n        }\\n\\n        var g = new Geometry();\\n        g.getAttributes().Vertex = new BufferArray( \\'ARRAY_BUFFER\\', fullVerticesList, 3 );\\n        g.getAttributes().Normal = new BufferArray( \\'ARRAY_BUFFER\\', fullNormalsList, 3 );\\n        g.getAttributes().TexCoord0 = new BufferArray( \\'ARRAY_BUFFER\\', fullUVList, 2 );\\n\\n        if ( useDrawArrays )\\n            g.getPrimitives().push( new DrawArrays( PrimitiveSet.TRIANGLES, 0, fullVerticesList.length / 3 ) );\\n        else\\n            g.getPrimitives().push( new DrawElements( PrimitiveSet.TRIANGLES, new BufferArray( \\'ELEMENT_ARRAY_BUFFER\\', indexes, 1 ) ) );\\n        return g;\\n    };\\n\\n    return {\\n        createTexturedBoxGeometry: createTexturedBoxGeometry,\\n        createTexturedQuadGeometry: createTexturedQuadGeometry,\\n        createTexturedBox: createTexturedBox,\\n        createTexturedQuad: createTexturedQuad,\\n        createAxisGeometry: createAxisGeometry,\\n        createTexturedSphere: createTexturedSphere\\n    };\\n} );\\n\\n//# sourceURL=/osg/Shape.js\");\n\n",
    "eval(\"define( \\'osg/Stack\\',[], function () {\\n\\n    var Stack = function () {};\\n    Stack.create = function () {\\n        var a = [];\\n        a.globalDefault = undefined;\\n        a.lastApplied = undefined;\\n        a.back = function () {\\n            return this[ this.length - 1 ];\\n        };\\n        return a;\\n    };\\n\\n    return Stack;\\n} );\\n\\n//# sourceURL=/osg/Stack.js\");\n\n",
    "eval(\"define( \\'osg/State\\',[\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Stack\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Matrix\\',\\n    \\'osgShader/ShaderGeneratorProxy\\',\\n    \\'osg/Map\\'\\n], function ( StateAttribute, Stack, Uniform, Matrix, ShaderGeneratorProxy, Map ) {\\n\\n    var State = function () {\\n        this._graphicContext = undefined;\\n\\n        this.currentVBO = null;\\n        this.vertexAttribList = [];\\n        this.programs = Stack.create();\\n        this.stateSets = Stack.create();\\n        this.uniforms = new Map();\\n\\n        this.textureAttributeMapList = [];\\n\\n        this.attributeMap = new Map();\\n\\n        this.shaderGenerator = new ShaderGeneratorProxy();\\n\\n        this.modelViewMatrix = Uniform.createMatrix4( Matrix.create(), \\'ModelViewMatrix\\' );\\n        this.projectionMatrix = Uniform.createMatrix4( Matrix.create(), \\'ProjectionMatrix\\' );\\n        this.normalMatrix = Uniform.createMatrix4( Matrix.create(), \\'NormalMatrix\\' );\\n\\n        // track uniform for color array enabled\\n\\n        // Stoped HERE color array does not work\\n        // check point cloud example\\n        var arrayColorEnable = Stack.create();\\n        arrayColorEnable.globalDefault = Uniform.createFloat1( 0.0, \\'ArrayColorEnabled\\' );\\n\\n        this.uniforms.setMap( {\\n            ArrayColorEnabled: arrayColorEnable\\n        } );\\n\\n\\n        this.vertexAttribMap = {};\\n        this.vertexAttribMap._disable = [];\\n        this.vertexAttribMap._keys = [];\\n    };\\n\\n    State.prototype = {\\n\\n        setGraphicContext: function ( graphicContext ) {\\n            this._graphicContext = graphicContext;\\n        },\\n        getGraphicContext: function () {\\n            return this._graphicContext;\\n        },\\n\\n        pushStateSet: function ( stateset ) {\\n            this.stateSets.push( stateset );\\n\\n            if ( stateset.attributeMap ) {\\n                this.pushAttributeMap( this.attributeMap, stateset.attributeMap );\\n            }\\n            if ( stateset.textureAttributeMapList ) {\\n                var list = stateset.textureAttributeMapList;\\n                for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {\\n                    if ( list[ textureUnit ] === undefined ) {\\n                        continue;\\n                    }\\n                    if ( !this.textureAttributeMapList[ textureUnit ] ) {\\n                        this.textureAttributeMapList[ textureUnit ] = new Map();\\n                    }\\n                    this.pushAttributeMap( this.textureAttributeMapList[ textureUnit ], list[ textureUnit ] );\\n                }\\n            }\\n\\n            if ( stateset.uniforms ) {\\n                this.pushUniformsList( this.uniforms, stateset.uniforms );\\n            }\\n        },\\n\\n        applyStateSet: function ( stateset ) {\\n            this.pushStateSet( stateset );\\n            this.apply();\\n            this.popStateSet();\\n        },\\n\\n        popAllStateSets: function () {\\n            while ( this.stateSets.length ) {\\n                this.popStateSet();\\n            }\\n        },\\n        popStateSet: function () {\\n            var stateset = this.stateSets.pop();\\n            if ( stateset.program ) {\\n                this.programs.pop();\\n            }\\n            if ( stateset.attributeMap ) {\\n                this.popAttributeMap( this.attributeMap, stateset.attributeMap );\\n            }\\n            if ( stateset.textureAttributeMapList ) {\\n                var list = stateset.textureAttributeMapList;\\n                for ( var textureUnit = 0, l = list.length; textureUnit < l; textureUnit++ ) {\\n                    if ( list[ textureUnit ] === undefined ) {\\n                        continue;\\n                    }\\n                    this.popAttributeMap( this.textureAttributeMapList[ textureUnit ], list[ textureUnit ] );\\n                }\\n            }\\n\\n            if ( stateset.uniforms ) {\\n                this.popUniformsList( this.uniforms, stateset.uniforms );\\n            }\\n        },\\n\\n        haveAppliedAttribute: function ( attribute ) {\\n            var key = attribute.getTypeMember();\\n            var attributeStack = this.attributeMap[ key ];\\n            attributeStack.lastApplied = attribute;\\n            attributeStack.asChanged = true;\\n        },\\n\\n        applyAttribute: function ( attribute ) {\\n            var key = attribute.getTypeMember();\\n\\n            var attributeMap = this.attributeMap;\\n            var attributeStack = attributeMap[ key ];\\n\\n            if ( attributeStack === undefined ) {\\n                attributeStack = Stack.create();\\n                attributeMap[ key ] = attributeStack;\\n                attributeMap[ key ].globalDefault = attribute.cloneType();\\n                this.attributeMap.dirty();\\n            }\\n\\n            if ( attributeStack.lastApplied !== attribute ) {\\n                //        if (attributeStack.lastApplied !== attribute || attribute.isDirty()) {\\n                if ( attribute.apply ) {\\n                    attribute.apply( this );\\n                }\\n                attributeStack.lastApplied = attribute;\\n                attributeStack.asChanged = true;\\n            }\\n        },\\n        applyTextureAttribute: function ( unit, attribute ) {\\n            var gl = this.getGraphicContext();\\n            gl.activeTexture( gl.TEXTURE0 + unit );\\n            var key = attribute.getTypeMember();\\n\\n            if ( !this.textureAttributeMapList[ unit ] ) {\\n                this.textureAttributeMapList[ unit ] = new Map();\\n            }\\n\\n            var textureUnitAttributeMap = this.textureAttributeMapList[ unit ];\\n            var attributeStack = textureUnitAttributeMap[ key ];\\n\\n            if ( attributeStack === undefined ) {\\n\\n                attributeStack = Stack.create();\\n                textureUnitAttributeMap[ key ] = attributeStack;\\n                textureUnitAttributeMap.dirty();\\n                attributeStack.globalDefault = attribute.cloneType();\\n\\n            }\\n\\n            if ( attributeStack.lastApplied !== attribute ) {\\n\\n                if ( attribute.apply ) {\\n                    attribute.apply( this );\\n                }\\n                attributeStack.lastApplied = attribute;\\n                attributeStack.asChanged = true;\\n            }\\n        },\\n\\n        getLastProgramApplied: function () {\\n            return this.programs.lastApplied;\\n        },\\n\\n        pushGeneratedProgram: function () {\\n            var program;\\n\\n            var attributeMap = this.attributeMap;\\n\\n            if ( attributeMap.Program !== undefined && attributeMap.Program.length !== 0 ) {\\n                program = attributeMap.Program.back().object;\\n                var value = attributeMap.Program.back().value;\\n                if ( program !== undefined && value !== StateAttribute.OFF ) {\\n                    this.programs.push( this.getObjectPair( program, value ) );\\n                    return program;\\n                }\\n            }\\n\\n            //var attributes = {\\n            //    \\'textureAttributeMapList\\': this.textureAttributeMapList,\\n            //     \\'attributeMap\\': this.attributeMap\\n            // };\\n\\n            var generator = this.stateSets.back().getShaderGenerator();\\n            if ( generator === undefined ) {\\n                generator = this.shaderGenerator;\\n                if ( this.attributeMap.Material ) {\\n                    // not the default shadergenerator\\n                    this.shaderGenerator.setShaderGenerator( \\'material\\' );\\n                }\\n                // could check if no light in whole viewport and go shadeless.\\n            }\\n            //program = generator.getOrCreateProgram( attributes );\\n            program = generator.getOrCreateProgram( this );\\n            this.programs.push( this.getObjectPair( program, StateAttribute.ON ) );\\n            return program;\\n        },\\n\\n        popGeneratedProgram: function () {\\n            this.programs.pop();\\n        },\\n\\n        applyWithoutProgram: function () {\\n            this.applyAttributeMap( this.attributeMap );\\n            this.applyTextureAttributeMapList( this.textureAttributeMapList );\\n        },\\n\\n        computeForeignUniforms: function ( programUniformMap, activeUniformMap ) {\\n            var uniformMapKeys = programUniformMap.getKeys();\\n            var uniformMap = programUniformMap;\\n\\n            var foreignUniforms = [];\\n            for ( var i = 0, l = uniformMapKeys.length; i < l; i++ ) {\\n                var name = uniformMapKeys[ i ];\\n                var location = uniformMap[ name ];\\n                if ( location !== undefined && activeUniformMap[ name ] === undefined ) {\\n                    // filter \\'standard\\' uniform matrix that will be applied for all shader\\n                    if ( name !== this.modelViewMatrix.name &&\\n                        name !== this.projectionMatrix.name &&\\n                        name !== this.normalMatrix.name &&\\n                        name !== \\'ArrayColorEnabled\\' ) {\\n                        foreignUniforms.push( name );\\n                    }\\n                }\\n            }\\n            return foreignUniforms;\\n        },\\n\\n        removeUniformsNotRequiredByProgram: function ( activeUniformMap, programUniformMap ) {\\n\\n            var activeUniformMapKeys = activeUniformMap.getKeys();\\n\\n            for ( var i = 0, l = activeUniformMapKeys.length; i < l; i++ ) {\\n                var name = activeUniformMapKeys[ i ];\\n                var location = programUniformMap[ name ];\\n                if ( location === undefined || location === null ) {\\n                    delete activeUniformMap[ name ];\\n                    activeUniformMap.dirty();\\n                }\\n            }\\n        },\\n\\n\\n\\n        cacheUniformsForGeneratedProgram: function ( program ) {\\n\\n            var foreignUniforms = this.computeForeignUniforms( program.uniformsCache, program.activeUniforms );\\n            program.foreignUniforms = foreignUniforms;\\n\\n\\n            // remove uniforms listed by attributes (getActiveUniforms) but not required by the program\\n            this.removeUniformsNotRequiredByProgram( program.activeUniforms, program.uniformsCache );\\n\\n        },\\n\\n        applyGeneratedProgram: function ( program ) {\\n\\n            // note that about TextureAttribute that need uniform on unit we would need to improve\\n            // the current uniformList ...\\n\\n            // when we apply the shader for the first time, we want to compute the active uniforms for this shader and the list of uniforms not extracted from attributes called foreignUniforms\\n\\n            // typically the following code will be executed once on the first execution of generated program\\n\\n            var foreignUniformKeys = program.foreignUniforms;\\n            if ( !foreignUniformKeys ) {\\n                this.cacheUniformsForGeneratedProgram( program );\\n                foreignUniformKeys = program.foreignUniforms;\\n            }\\n\\n\\n            var programUniformMap = program.uniformsCache;\\n            var activeUniformMap = program.activeUniforms;\\n\\n\\n            // apply active uniforms\\n            // caching uniforms from attribtues make it impossible to overwrite uniform with a custom uniform instance not used in the attributes\\n            var i, l, name, location;\\n            var activeUniformKeys = activeUniformMap.getKeys();\\n\\n            for ( i = 0, l = activeUniformKeys.length; i < l; i++ ) {\\n\\n                name = activeUniformKeys[ i ];\\n                location = programUniformMap[ name ];\\n                activeUniformMap[ name ].apply( this._graphicContext, location );\\n\\n            }\\n\\n            var uniformMapStack = this.uniforms;\\n\\n            // apply now foreign uniforms, it\\'s uniforms needed by the program but not contains in attributes used to generate this program\\n            for ( i = 0, l = foreignUniformKeys.length; i < l; i++ ) {\\n\\n                name = foreignUniformKeys[ i ];\\n                var uniformStack = uniformMapStack[ name ];\\n                location = programUniformMap[ name ];\\n                var uniform;\\n\\n                if ( uniformStack !== undefined ) {\\n\\n                    if ( uniformStack.length === 0 ) {\\n                        uniform = uniformStack.globalDefault;\\n                    } else {\\n                        uniform = uniformStack.back().object;\\n                    }\\n\\n                    uniform.apply( this._graphicContext, location );\\n                }\\n\\n            }\\n        },\\n\\n        apply: function () {\\n            this.applyAttributeMap( this.attributeMap );\\n            this.applyTextureAttributeMapList( this.textureAttributeMapList );\\n\\n            this.pushGeneratedProgram();\\n            var program = this.programs.back().object;\\n            if ( this.programs.lastApplied !== program ) {\\n                program.apply( this );\\n                this.programs.lastApplied = program;\\n            }\\n\\n            if ( program.generated === true ) {\\n\\n                // will cache uniform and apply them with the program\\n\\n                this.applyGeneratedProgram( program );\\n\\n            } else {\\n\\n                // custom program so we will iterate on uniform from the program and apply them\\n                // but in order to be able to use Attribute in the state graph we will check if\\n                // our program want them. It must be defined by the user\\n                this.applyCustomProgram( program );\\n\\n            }\\n        },\\n\\n\\n\\n        getActiveUniformsFromProgramAttributes: function ( program, activeUniformsList ) {\\n\\n            var attributeMapStack = this.attributeMap;\\n\\n            var attributeKeys = program.trackAttributes.attributeKeys;\\n\\n            if ( attributeKeys.length > 0 ) {\\n\\n                for ( var i = 0, l = attributeKeys.length; i < l; i++ ) {\\n\\n                    var key = attributeKeys[ i ];\\n                    var attributeStack = attributeMapStack[ key ];\\n                    if ( attributeStack === undefined ) {\\n                        continue;\\n                    }\\n\\n                    // we just need the uniform list and not the attribute itself\\n                    var attribute = attributeStack.globalDefault;\\n                    if ( attribute.getOrCreateUniforms === undefined ) {\\n                        continue;\\n                    }\\n\\n                    var uniformMap = attribute.getOrCreateUniforms();\\n                    var uniformKeys = uniformMap.getKeys();\\n\\n                    for ( var a = 0, b = uniformKeys.length; a < b; a++ ) {\\n                        activeUniformsList.push( uniformMap[ uniformKeys[ a ] ] );\\n                    }\\n                }\\n\\n            }\\n        },\\n\\n        getActiveUniformsFromProgramTextureAttributes: function ( program, activeUniformsList ) {\\n\\n            var textureAttributeKeysList = program.trackAttributes.textureAttributeKeys;\\n            if ( textureAttributeKeysList === undefined ) return;\\n\\n            for ( var unit = 0, nbUnit = textureAttributeKeysList.length; unit < nbUnit; unit++ ) {\\n\\n                var textureAttributeKeys = textureAttributeKeysList[ unit ];\\n                if ( textureAttributeKeys === undefined ) continue;\\n\\n                var unitTextureAttributeList = this.textureAttributeMapList[ unit ];\\n                if ( unitTextureAttributeList === undefined ) continue;\\n\\n                for ( var i = 0, l = textureAttributeKeys.length; i < l; i++ ) {\\n                    var key = textureAttributeKeys[ i ];\\n\\n                    var attributeStack = unitTextureAttributeList[ key ];\\n                    if ( attributeStack === undefined ) {\\n                        continue;\\n                    }\\n                    // we just need the uniform list and not the attribute itself\\n                    var attribute = attributeStack.globalDefault;\\n                    if ( attribute.getOrCreateUniforms === undefined ) {\\n                        continue;\\n                    }\\n                    var uniformMap = attribute.getOrCreateUniforms();\\n                    var uniformMapKeys = uniformMap.getKeys();\\n\\n                    for ( var a = 0, b = uniformMapKeys.length; a < b; a++ ) {\\n                        activeUniformsList.push( uniformMap[ uniformMapKeys[ a ] ] );\\n                    }\\n                }\\n            }\\n        },\\n\\n        cacheUniformsForCustomProgram: function ( program, activeUniformsList ) {\\n\\n            this.getActiveUniformsFromProgramAttributes( program, activeUniformsList );\\n\\n            this.getActiveUniformsFromProgramTextureAttributes( program, activeUniformsList );\\n\\n            var gl = this._graphicContext;\\n\\n            // now we have a list on uniforms we want to track but we will filter them to use only what is needed by our program\\n            // not that if you create a uniforms whith the same name of a tracked attribute, and it will override it\\n            var uniformsFinal = new Map();\\n\\n            for ( var i = 0, l = activeUniformsList.length; i < l; i++ ) {\\n                var u = activeUniformsList[ i ];\\n                var loc = gl.getUniformLocation( program.program, u.name );\\n                if ( loc !== undefined && loc !== null ) {\\n                    uniformsFinal[ u.name ] = u;\\n                }\\n            }\\n            uniformsFinal.dirty();\\n            program.trackUniforms = uniformsFinal;\\n\\n        },\\n\\n        applyCustomProgram: ( function () {\\n\\n            var activeUniformsList = [];\\n\\n            return function ( program ) {\\n\\n                // custom program so we will iterate on uniform from the program and apply them\\n                // but in order to be able to use Attribute in the state graph we will check if\\n                // our program want them. It must be defined by the user\\n\\n                // first time we see attributes key, so we will keep a list of uniforms from attributes\\n                activeUniformsList.length = 0;\\n\\n                // fill the program with cached active uniforms map from attributes and texture attributes\\n                if ( program.trackAttributes !== undefined && program.trackUniforms === undefined ) {\\n                    this.cacheUniformsForCustomProgram( program, activeUniformsList );\\n                }\\n\\n                var programUniformMap = program.uniformsCache;\\n                var programUniformKeys = programUniformMap.getKeys();\\n                var uniformMapStackContent = this.uniforms;\\n\\n                var programTrackUniformMap;\\n                if ( program.trackUniforms )\\n                    programTrackUniformMap = program.trackUniforms;\\n\\n                var uniform;\\n                for ( var i = 0, l = programUniformKeys.length; i < l; i++ ) {\\n                    var uniformKey = programUniformKeys[ i ];\\n                    var location = programUniformMap[ uniformKey ];\\n                    var uniformStack = uniformMapStackContent[ uniformKey ];\\n\\n                    if ( uniformStack === undefined ) {\\n\\n                        if ( programTrackUniformMap !== undefined ) {\\n                            uniform = programTrackUniformMap[ uniformKey ];\\n                            if ( uniform !== undefined ) {\\n                                uniform.apply( this._graphicContext, location );\\n                            }\\n                        }\\n\\n                    } else {\\n\\n                        if ( uniformStack.length === 0 ) {\\n                            uniform = uniformStack.globalDefault;\\n                        } else {\\n                            uniform = uniformStack.back().object;\\n                        }\\n                        uniform.apply( this._graphicContext, location );\\n\\n                    }\\n                }\\n            };\\n        } )(),\\n\\n        applyAttributeMap: function ( attributeMap ) {\\n            var attributeStack;\\n\\n            var attributeMapKeys = attributeMap.getKeys();\\n\\n            for ( var i = 0, l = attributeMapKeys.length; i < l; i++ ) {\\n                var key = attributeMapKeys[ i ];\\n\\n                attributeStack = attributeMap[ key ];\\n                if ( attributeStack === undefined ) {\\n                    continue;\\n                }\\n                var attribute;\\n                if ( attributeStack.length === 0 ) {\\n                    attribute = attributeStack.globalDefault;\\n                } else {\\n                    attribute = attributeStack.back().object;\\n                }\\n\\n                if ( attributeStack.asChanged ) {\\n                    //            if (attributeStack.lastApplied !== attribute || attribute.isDirty()) {\\n                    if ( attributeStack.lastApplied !== attribute ) {\\n                        if ( attribute.apply ) {\\n                            attribute.apply( this );\\n                        }\\n                        attributeStack.lastApplied = attribute;\\n                    }\\n                    attributeStack.asChanged = false;\\n                }\\n            }\\n        },\\n\\n        getObjectPair: function ( uniform, value ) {\\n            return {\\n                object: uniform,\\n                value: value\\n            };\\n        },\\n\\n        pushUniformsList: function ( uniformMap, stateSetUniformMap ) {\\n            /*jshint bitwise: false */\\n            var name;\\n            var uniform;\\n\\n            var stateSetUniformMapKeys = stateSetUniformMap.getKeys();\\n\\n            for ( var i = 0, l = stateSetUniformMapKeys.length; i < l; i++ ) {\\n                var key = stateSetUniformMapKeys[ i ];\\n                var uniformPair = stateSetUniformMap[ key ];\\n                uniform = uniformPair.getUniform();\\n                name = uniform.name;\\n                if ( uniformMap[ name ] === undefined ) {\\n                    uniformMap[ name ] = Stack.create();\\n                    uniformMap[ name ].globalDefault = uniform;\\n                    uniformMap.dirty();\\n                }\\n                var value = uniformPair.getValue();\\n                var stack = uniformMap[ name ];\\n                if ( stack.length === 0 ) {\\n                    stack.push( this.getObjectPair( uniform, value ) );\\n                } else if ( ( stack[ stack.length - 1 ].value & StateAttribute.OVERRIDE ) && !( value & StateAttribute.PROTECTED ) ) {\\n                    stack.push( stack[ stack.length - 1 ] );\\n                } else {\\n                    stack.push( this.getObjectPair( uniform, value ) );\\n                }\\n            }\\n            /*jshint bitwise: true */\\n        },\\n\\n        popUniformsList: function ( uniformMap, stateSetUniformMap ) {\\n\\n            var stateSetUniformMapKeys = stateSetUniformMap.getKeys();\\n\\n            for ( var i = 0, l = stateSetUniformMapKeys.length; i < l; i++ ) {\\n                var key = stateSetUniformMapKeys[ i ];\\n                uniformMap[ key ].pop();\\n            }\\n        },\\n\\n        applyTextureAttributeMapList: function ( textureAttributesMapList ) {\\n            var gl = this._graphicContext;\\n            var textureAttributeMap;\\n\\n            for ( var textureUnit = 0, l = textureAttributesMapList.length; textureUnit < l; textureUnit++ ) {\\n                textureAttributeMap = textureAttributesMapList[ textureUnit ];\\n                if ( textureAttributeMap === undefined ) {\\n                    continue;\\n                }\\n\\n\\n                var textureAttributeMapKeys = textureAttributeMap.getKeys();\\n\\n                for ( var i = 0, lt = textureAttributeMapKeys.length; i < lt; i++ ) {\\n                    var key = textureAttributeMapKeys[ i ];\\n\\n                    var attributeStack = textureAttributeMap[ key ];\\n                    if ( attributeStack === undefined ) {\\n                        continue;\\n                    }\\n\\n                    var attribute;\\n                    if ( attributeStack.length === 0 ) {\\n                        attribute = attributeStack.globalDefault;\\n                    } else {\\n                        attribute = attributeStack.back().object;\\n                    }\\n                    if ( attributeStack.asChanged ) {\\n\\n                        gl.activeTexture( gl.TEXTURE0 + textureUnit );\\n                        attribute.apply( this, textureUnit );\\n                        attributeStack.lastApplied = attribute;\\n                        attributeStack.asChanged = false;\\n\\n                    }\\n                }\\n            }\\n        },\\n        setGlobalDefaultValue: function ( attribute ) {\\n\\n            var key = attribute.getTypeMember();\\n            var attributeMap = this.attributeMap;\\n\\n            if ( attributeMap[ key ] ) {\\n                attributeMap[ key ].globalDefault = attribute;\\n\\n            } else {\\n                attributeMap[ key ] = Stack.create();\\n                attributeMap[ key ].globalDefault = attribute;\\n\\n                this.attributeMap.dirty();\\n            }\\n        },\\n\\n        pushAttributeMap: function ( attributeMap, stateSetAttributeMap ) {\\n            /*jshint bitwise: false */\\n            var attributeStack;\\n            var stateSetAttributeMapKeys = stateSetAttributeMap.getKeys();\\n\\n            for ( var i = 0, l = stateSetAttributeMapKeys.length; i < l; i++ ) {\\n\\n                var type = stateSetAttributeMapKeys[ i ];\\n                var attributePair = stateSetAttributeMap[ type ];\\n                var attribute = attributePair.getAttribute();\\n\\n                if ( attributeMap[ type ] === undefined ) {\\n                    attributeMap[ type ] = Stack.create();\\n                    attributeMap[ type ].globalDefault = attribute.cloneType();\\n\\n                    attributeMap.dirty();\\n                }\\n\\n                var value = attributePair.getValue();\\n\\n                attributeStack = attributeMap[ type ];\\n                if ( attributeStack.length === 0 ) {\\n                    attributeStack.push( this.getObjectPair( attribute, value ) );\\n                } else if ( ( attributeStack[ attributeStack.length - 1 ].value & StateAttribute.OVERRIDE ) && !( value & StateAttribute.PROTECTED ) ) {\\n                    attributeStack.push( attributeStack[ attributeStack.length - 1 ] );\\n                } else {\\n                    attributeStack.push( this.getObjectPair( attribute, value ) );\\n                }\\n\\n                attributeStack.asChanged = true;\\n            }\\n            /*jshint bitwise: true */\\n        },\\n\\n        popAttributeMap: function ( attributeMap, stateSetAttributeMap ) {\\n\\n            var attributeStack;\\n            var stateSetAttributeMapKeys = stateSetAttributeMap.getKeys();\\n\\n            for ( var i = 0, l = stateSetAttributeMapKeys.length; i < l; i++ ) {\\n\\n                var type = stateSetAttributeMapKeys[ i ];\\n                attributeStack = attributeMap[ type ];\\n                attributeStack.pop();\\n                attributeStack.asChanged = true;\\n\\n            }\\n        },\\n\\n        setIndexArray: function ( array ) {\\n            var gl = this._graphicContext;\\n            if ( this.currentIndexVBO !== array ) {\\n                array.bind( gl );\\n                this.currentIndexVBO = array;\\n            }\\n            if ( array.isDirty() ) {\\n                array.compile( gl );\\n            }\\n        },\\n\\n        lazyDisablingOfVertexAttributes: function () {\\n            var keys = this.vertexAttribMap._keys;\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                var attr = keys[ i ];\\n                if ( this.vertexAttribMap[ attr ] ) {\\n                    this.vertexAttribMap._disable[ attr ] = true;\\n                }\\n            }\\n        },\\n\\n        applyDisablingOfVertexAttributes: function () {\\n            var keys = this.vertexAttribMap._keys;\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                if ( this.vertexAttribMap._disable[ keys[ i ] ] === true ) {\\n                    var attr = keys[ i ];\\n                    this._graphicContext.disableVertexAttribArray( attr );\\n                    this.vertexAttribMap._disable[ attr ] = false;\\n                    this.vertexAttribMap[ attr ] = false;\\n                }\\n            }\\n\\n            // it takes 4.26% of global cpu\\n            // there would be a way to cache it and track state if the program has not changed ...\\n            var program = this.programs.lastApplied;\\n\\n            if ( program !== undefined ) {\\n                var gl = this.getGraphicContext();\\n                var color = program.attributesCache.Color;\\n                var updateColorUniform = false;\\n                var hasColorAttrib = false;\\n                if ( color !== undefined ) {\\n                    hasColorAttrib = this.vertexAttribMap[ color ];\\n                }\\n\\n                var uniform = this.uniforms.ArrayColorEnabled.globalDefault;\\n                if ( this.previousHasColorAttrib !== hasColorAttrib ) {\\n                    updateColorUniform = true;\\n                }\\n\\n                this.previousHasColorAttrib = hasColorAttrib;\\n\\n                if ( updateColorUniform ) {\\n                    if ( hasColorAttrib ) {\\n                        uniform.get()[ 0 ] = 1.0;\\n                    } else {\\n                        uniform.get()[ 0 ] = 0.0;\\n                    }\\n                    uniform.dirty();\\n                }\\n\\n                uniform.apply( gl, program.uniformsCache.ArrayColorEnabled );\\n            }\\n        },\\n        setVertexAttribArray: function ( attrib, array, normalize ) {\\n            var vertexAttribMap = this.vertexAttribMap;\\n            vertexAttribMap._disable[ attrib ] = false;\\n            var gl = this._graphicContext;\\n            var binded = false;\\n            if ( array.isDirty() ) {\\n                array.bind( gl );\\n                array.compile( gl );\\n                binded = true;\\n            }\\n\\n            if ( vertexAttribMap[ attrib ] !== array ) {\\n\\n                if ( !binded ) {\\n                    array.bind( gl );\\n                }\\n\\n                if ( !vertexAttribMap[ attrib ] ) {\\n                    gl.enableVertexAttribArray( attrib );\\n\\n                    if ( vertexAttribMap[ attrib ] === undefined ) {\\n                        vertexAttribMap._keys.push( attrib );\\n                    }\\n                }\\n\\n                vertexAttribMap[ attrib ] = array;\\n                gl.vertexAttribPointer( attrib, array._itemSize, gl.FLOAT, normalize, 0, 0 );\\n            }\\n        }\\n\\n    };\\n\\n    return State;\\n} );\\n\\n//# sourceURL=/osg/State.js\");\n\n",
    "eval(\"define( \\'osg/TextureCubeMap\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Image\\',\\n    \\'osg/Utils\\'\\n\\n], function ( MACROUTILS, Texture, Image ) {\\n    /**\\n     * TextureCubeMap\\n     * @class TextureCubeMap\\n     * @inherits Texture\\n     */\\n    var TextureCubeMap = function () {\\n        Texture.call( this );\\n        this._images = {};\\n    };\\n\\n    /** @lends TextureCubeMap.prototype */\\n    TextureCubeMap.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( Texture.prototype, {\\n        setDefaultParameters: function () {\\n            Texture.prototype.setDefaultParameters.call( this );\\n            this._textureTarget = Texture.TEXTURE_CUBE_MAP;\\n        },\\n        cloneType: function () {\\n            var t = new TextureCubeMap();\\n            t.defaultType = true;\\n            return t;\\n        },\\n        setImage: function ( face, img, imageFormat ) {\\n\\n            if ( typeof ( face ) === \\'string\\' ) {\\n                face = Texture[ face ];\\n            }\\n\\n            if ( this._images[ face ] === undefined ) {\\n                this._images[ face ] = {};\\n            }\\n\\n            if ( typeof ( imageFormat ) === \\'string\\' ) {\\n                imageFormat = Texture[ imageFormat ];\\n            }\\n            if ( imageFormat === undefined ) {\\n                imageFormat = Texture.RGBA;\\n            }\\n\\n            var image = img;\\n            if ( image instanceof( Image ) === false ) {\\n                image = new Image( img );\\n            }\\n\\n            this._images[ face ].image = image;\\n            this._images[ face ].format = imageFormat;\\n            this._images[ face ].dirty = true;\\n            this.dirty();\\n        },\\n        getImage: function ( face ) {\\n            return this._images[ face ].image;\\n        },\\n\\n        applyTexImage2DLoad: function ( gl, target, level, internalFormat, format, type, image ) {\\n            if ( !image ) {\\n                return false;\\n            }\\n\\n            if ( !image.isReady() ) {\\n                return false;\\n            }\\n\\n\\n            this.setTextureSize( image.getWidth(), image.getHeight() );\\n\\n            MACROUTILS.timeStamp( \\'osgjs.metrics:texImage2d\\' );\\n            gl.texImage2D( target, 0, internalFormat, internalFormat, type, image.getImage() );\\n            return true;\\n        },\\n\\n        _applyImageTarget: function ( gl, internalFormat, target ) {\\n            var imgObject = this._images[ target ];\\n            if ( !imgObject ) {\\n                return 0;\\n            }\\n\\n            if ( !imgObject.dirty ) {\\n                return 1;\\n            }\\n\\n            if ( this.applyTexImage2DLoad( gl,\\n                target,\\n                0,\\n                internalFormat,\\n                internalFormat,\\n                gl.UNSIGNED_BYTE,\\n                imgObject.image ) ) {\\n                imgObject.dirty = false;\\n                if ( this._unrefImageDataAfterApply ) {\\n                    delete this._images[ target ];\\n                }\\n                return 1;\\n            }\\n            return 0;\\n        },\\n\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n\\n            if ( this._textureObject !== undefined && !this.isDirty() ) {\\n                this._textureObject.bind( gl );\\n\\n            } else if ( this.defaultType ) {\\n                gl.bindTexture( this._textureTarget, null );\\n\\n            } else {\\n                if ( !this._textureObject ) {\\n\\n                    // must be called before init\\n                    this.computeTextureFormat();\\n\\n                    this.init( gl );\\n                }\\n                this._textureObject.bind( gl );\\n\\n                var internalFormat = this._internalFormat;\\n\\n                var valid = 0;\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_X );\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_X );\\n\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Y );\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Y );\\n\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_POSITIVE_Z );\\n                valid += this._applyImageTarget( gl, internalFormat, gl.TEXTURE_CUBE_MAP_NEGATIVE_Z );\\n                if ( valid === 6 ) {\\n                    this.setDirty( false );\\n                    this.applyFilterParameter( gl, this._textureTarget );\\n                    this.generateMipmap( gl, this._textureTarget );\\n                }\\n            } // render to cubemap not yet implemented\\n        }\\n    } ), \\'osg\\', \\'TextureCubeMap\\' );\\n\\n    return TextureCubeMap;\\n} );\\n\\n//# sourceURL=/osg/TextureCubeMap.js\");\n\n",
    "eval(\"define( \\'osg/UpdateVisitor\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/NodeVisitor\\',\\n], function ( MACROUTILS, NodeVisitor ) {\\n\\n    \\'use strict\\';\\n\\n    var UpdateVisitor = function () {\\n        NodeVisitor.call( this );\\n        this.visitorType = NodeVisitor.UPDATE_VISITOR;\\n    };\\n\\n    UpdateVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n\\n        apply: function ( node ) {\\n\\n            // a way to avoid extra call is to implement getNumChildrenRequiringUpdateTraversal\\n            // and stateset.requiresUpdateTraversal()\\n\\n\\n            // handle callback in stateset\\n            var stateSet = node.getStateSet();\\n            if ( stateSet ) {\\n                var updateCallbackList = stateSet.getUpdateCallbackList();\\n\\n                if ( updateCallbackList.length )\\n                    for ( var i = 0, l = updateCallbackList.length; i < l; i++ )\\n                        updateCallbackList[ i ].update( stateSet, this );\\n            }\\n\\n            // handle callback in nodes\\n            var ncs = node.getUpdateCallbackList();\\n            if ( ncs.length )\\n                for ( var j = 0, m = ncs.length; j < m; j++ ) {\\n                    if ( !ncs[ j ].update( node, this ) ) {\\n                        return;\\n                    }\\n                }\\n\\n            this.traverse( node );\\n        }\\n    } );\\n\\n    return UpdateVisitor;\\n} );\\n\\n//# sourceURL=/osg/UpdateVisitor.js\");\n\n",
    "eval(\"define( \\'osg/Vec2\\',[], function () {\\n\\n    /** @class Vec2 Operations */\\n    var Vec2 = {\\n        copy: function ( a, r ) {\\n            r[ 0 ] = a[ 0 ];\\n            r[ 1 ] = a[ 1 ];\\n            return r;\\n        },\\n\\n        valid: function ( a ) {\\n            if ( isNaN( a[ 0 ] ) ) {\\n                return false;\\n            }\\n            if ( isNaN( a[ 1 ] ) ) {\\n                return false;\\n            }\\n            return true;\\n        },\\n\\n        mult: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] * b;\\n            r[ 1 ] = a[ 1 ] * b;\\n            return r;\\n        },\\n\\n        length2: function ( a ) {\\n            return a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ];\\n        },\\n\\n        length: function ( a ) {\\n            return Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] );\\n        },\\n\\n        distance2: function ( a, b ) {\\n            var x = a[ 0 ] - b[ 0 ];\\n            var y = a[ 1 ] - b[ 1 ];\\n            return x * x + y * y;\\n        },\\n\\n        distance: function ( a, b ) {\\n            var x = a[ 0 ] - b[ 0 ];\\n            var y = a[ 1 ] - b[ 1 ];\\n            return Math.sqrt( x * x + y * y );\\n        },\\n\\n        /**\\n        normalize an Array of 2 elements and write it in r\\n     */\\n        normalize: function ( a, r ) {\\n            var norm = this.length2( a );\\n            if ( norm > 0.0 ) {\\n                var inv = 1.0 / Math.sqrt( norm );\\n                r[ 0 ] = a[ 0 ] * inv;\\n                r[ 1 ] = a[ 1 ] * inv;\\n            } else {\\n                r[ 0 ] = a[ 0 ];\\n                r[ 1 ] = a[ 1 ];\\n            }\\n            return r;\\n        },\\n\\n        /**\\n        Compute the dot product\\n    */\\n        dot: function ( a, b ) {\\n            return a[ 0 ] * b[ 0 ] + a[ 1 ] * b[ 1 ];\\n        },\\n\\n        /**\\n       Compute a - b and put the result in r\\n     */\\n        sub: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] - b[ 0 ];\\n            r[ 1 ] = a[ 1 ] - b[ 1 ];\\n            return r;\\n        },\\n\\n        add: function ( a, b, r ) {\\n            r[ 0 ] = a[ 0 ] + b[ 0 ];\\n            r[ 1 ] = a[ 1 ] + b[ 1 ];\\n            return r;\\n        },\\n\\n        neg: function ( a, r ) {\\n            r[ 0 ] = -a[ 0 ];\\n            r[ 1 ] = -a[ 1 ];\\n            return r;\\n        },\\n\\n        lerp: function ( t, a, b, r ) {\\n            var tmp = 1.0 - t;\\n            r[ 0 ] = a[ 0 ] * tmp + t * b[ 0 ];\\n            r[ 1 ] = a[ 1 ] * tmp + t * b[ 1 ];\\n            return r;\\n        }\\n\\n    };\\n\\n    return Vec2;\\n} );\\n\\n//# sourceURL=/osg/Vec2.js\");\n\n",
    "eval(\"define( \\'osg/Viewport\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/Matrix\\'\\n], function ( MACROUTILS, StateAttribute, Matrix ) {\\n\\n    var Viewport = function ( x, y, w, h ) {\\n        StateAttribute.call( this );\\n\\n        if ( x === undefined ) {\\n            x = 0;\\n        }\\n        if ( y === undefined ) {\\n            y = 0;\\n        }\\n        if ( w === undefined ) {\\n            w = 800;\\n        }\\n        if ( h === undefined ) {\\n            h = 600;\\n        }\\n\\n        this._x = x;\\n        this._y = y;\\n        this._width = w;\\n        this._height = h;\\n        this._dirty = true;\\n    };\\n\\n    Viewport.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInehrit( StateAttribute.prototype, {\\n        attributeType: \\'Viewport\\',\\n        cloneType: function () {\\n            return new Viewport();\\n        },\\n        getType: function () {\\n            return this.attributeType;\\n        },\\n        getTypeMember: function () {\\n            return this.attributeType;\\n        },\\n        apply: function ( state ) {\\n            var gl = state.getGraphicContext();\\n            gl.viewport( this._x, this._y, this._width, this._height );\\n            this._dirty = false;\\n        },\\n        setViewport: function ( x, y, width, height ) {\\n            this._x = x;\\n            this._y = y;\\n            this._width = width;\\n            this._height = height;\\n            this.dirty();\\n        },\\n        x: function () {\\n            return this._x;\\n        },\\n        y: function () {\\n            return this._y;\\n        },\\n        width: function () {\\n            return this._width;\\n        },\\n        height: function () {\\n            return this._height;\\n        },\\n        computeWindowMatrix: ( function () {\\n            var translate = Matrix.create();\\n            var scale = Matrix.create();\\n            return function () {\\n                // res = Matrix offset * Matrix scale * Matrix translate\\n                Matrix.makeTranslate( 1.0, 1.0, 1.0, translate );\\n                Matrix.makeScale( 0.5 * this._width, 0.5 * this._height, 0.5, scale );\\n                var offset = Matrix.makeTranslate( this._x, this._y, 0.0, Matrix.create() );\\n                //return Matrix.mult(Matrix.mult(translate, scale, translate), offset, offset);\\n                return Matrix.preMult( offset, Matrix.preMult( scale, translate ) );\\n            };\\n        } )()\\n    } ), \\'osg\\', \\'Viewport\\' );\\n\\n    return Viewport;\\n} );\\n\\n//# sourceURL=/osg/Viewport.js\");\n\n",
    "eval(\"define( \\'osg/WebGLCaps\\',[\\n], function () {\\n\\n    var WebGLCaps = function() {\\n        this._webGLExtensions = {};\\n        this._webGLParameters = {};\\n        this._webGLShaderMaxInt = \\'NONE\\';\\n        this._webGLShaderMaxFloat = \\'NONE\\';\\n    };\\n\\n    WebGLCaps.prototype = {\\n\\n        init: function( gl ) {\\n            this.initWebGLParameters( gl );\\n            this.initWebGLExtensions( gl );\\n        },\\n\\n        getWebGLParameter: function ( str ) {\\n            return this._webGLParameters[ str ];\\n        },\\n        getWebGLParameters: function () {\\n            return this._webGLParameters;\\n        },\\n        getShaderMaxPrecisionFloat: function () {\\n            return this._webGLParameters.MAX_SHADER_PRECISION_FLOAT;\\n        },\\n        getShaderMaxPrecisionInt: function () {\\n            return this._webGLParameters.MAX_SHADER_PRECISION_INT;\\n        },\\n        initWebGLParameters: function ( gl ) {\\n            if ( gl === undefined )\\n                return;\\n\\n            var limits = [\\n                \\'MAX_COMBINED_TEXTURE_IMAGE_UNITS\\',\\n                \\'MAX_CUBE_MAP_TEXTURE_SIZE\\',\\n                \\'MAX_FRAGMENT_UNIFORM_VECTORS\\',\\n                \\'MAX_RENDERBUFFER_SIZE\\',\\n                \\'MAX_TEXTURE_IMAGE_UNITS\\',\\n                \\'MAX_TEXTURE_SIZE\\',\\n                \\'MAX_VARYING_VECTORS\\',\\n                \\'MAX_VERTEX_ATTRIBS\\',\\n                \\'MAX_VERTEX_TEXTURE_IMAGE_UNITS\\',\\n                \\'MAX_VERTEX_UNIFORM_VECTORS\\',\\n                \\'MAX_VIEWPORT_DIMS\\',\\n                \\'SHADING_LANGUAGE_VERSION\\',\\n                \\'VERSION\\',\\n                \\'VENDOR\\',\\n                \\'RENDERER\\',\\n                \\'ALIASED_LINE_WIDTH_RANGE\\',\\n                \\'ALIASED_POINT_SIZE_RANGE\\',\\n                \\'RED_BITS\\',\\n                \\'GREEN_BITS\\',\\n                \\'BLUE_BITS\\',\\n                \\'ALPHA_BITS\\',\\n                \\'DEPTH_BITS\\',\\n                \\'STENCIL_BITS\\'\\n            ];\\n            var params = this._webGLParameters;\\n            for ( var i = 0, len = limits.length; i < len; ++i ) {\\n                var par = limits[ i ];\\n                params[ par ] = gl.getParameter( gl[ par ] );\\n            }\\n\\n            //shader precisions for float\\n            if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_FLOAT = \\'high\\';\\n            }\\n            else if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_FLOAT = \\'medium\\';\\n            }\\n            else if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_FLOAT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_FLOAT = \\'low\\';\\n            }\\n            else {\\n                params.MAX_SHADER_PRECISION_FLOAT = \\'none\\';\\n            }\\n\\n            //shader precisions for float\\n            if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_INT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_INT = \\'high\\';\\n            }\\n            else if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_INT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_INT = \\'medium\\';\\n            }\\n            else if ( gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.LOW_INT ).precision !== 0 ) {\\n                params.MAX_SHADER_PRECISION_INT = \\'low\\';\\n            }\\n            else {\\n                params.MAX_SHADER_PRECISION_INT = \\'none\\';\\n            }\\n\\n            // TODO ?\\n            // try to compile a small shader to test the spec is respected\\n        },\\n        getWebGLExtension: function ( str ) {\\n            return this._webGLExtensions[ str ];\\n        },\\n        getWebGLExtensions: function () {\\n            return this._webGLExtensions;\\n        },\\n        initWebGLExtensions: function ( gl ) {\\n            if ( gl === undefined )\\n                return;\\n            var supported = gl.getSupportedExtensions();\\n            var ext = this._webGLExtensions;\\n            // we load all the extensions\\n            for ( var i = 0, len = supported.length; i < len; ++i ) {\\n                var sup = supported[ i ];\\n                ext[ sup ] = gl.getExtension( sup );\\n            }\\n            // TODO ?\\n            // check if the extensions are REALLY supported ?\\n            // cf http://codeflow.org/entries/2013/feb/22/how-to-write-portable-webgl/#how-can-i-detect-if-i-can-render-to-floating-point-textures\\n        }\\n    };\\n\\n\\n    return WebGLCaps;\\n});\\n\\n//# sourceURL=/osg/WebGLCaps.js\");\n\n",
    "eval(\"define( \\'osg/osg\\',[\\n    \\'osg/BlendColor\\',\\n    \\'osg/BlendFunc\\',\\n    \\'osg/BoundingBox\\',\\n    \\'osg/BoundingSphere\\',\\n    \\'osg/BufferArray\\',\\n    \\'osg/Camera\\',\\n    \\'osg/ComputeMatrixFromNodePath\\',\\n    \\'osg/CullFace\\',\\n    \\'osg/CullSettings\\',\\n    \\'osg/CullStack\\',\\n    \\'osg/CullVisitor\\',\\n    \\'osg/Depth\\',\\n    \\'osg/DrawArrayLengths\\',\\n    \\'osg/DrawArrays\\',\\n    \\'osg/DrawElements\\',\\n    \\'osg/EllipsoidModel\\',\\n    \\'osg/FrameBufferObject\\',\\n    \\'osg/FrameStamp\\',\\n    \\'osg/Geometry\\',\\n    \\'osg/Image\\',\\n    \\'osg/KdTree\\',\\n    \\'osg/KdTreeBuilder\\',\\n    \\'osg/Light\\',\\n    \\'osg/LightSource\\',\\n    \\'osg/LineWidth\\',\\n    \\'osg/Lod\\',\\n    \\'osg/Map\\',\\n    \\'osg/Material\\',\\n    \\'osg/Math\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/MatrixTransform\\',\\n    \\'osg/Node\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Object\\',\\n    \\'osg/PagedLOD\\',\\n    \\'osg/PrimitiveSet\\',\\n    \\'osg/Program\\',\\n    \\'osg/Projection\\',\\n    \\'osg/Quat\\',\\n    \\'osg/RenderBin\\',\\n    \\'osg/RenderStage\\',\\n    \\'osg/Shader\\',\\n    \\'osgShader/ShaderGeneratorProxy\\',\\n    \\'osgShader/shaderGenerator/ShaderGenerator\\',\\n    \\'osgShader/shaderGenerator/Compiler\\',\\n    \\'osgShader/shaderGenerator/ShaderGeneratorStateSet\\',\\n    \\'osgShader/shaderGenerator/ShaderGeneratorMaterial\\',\\n    \\'osgShader/shaderGenerator/CompilerMaterial\\',\\n    \\'osgShader/shaderGenerator/ShaderGeneratorShadeless\\',\\n    \\'osgShader/shaderGenerator/CompilerShadeless\\',\\n    \\'osgShader/ShaderProcessor\\',\\n    \\'osgShader/ShaderLib\\',\\n    \\'osgShader/ShaderNode\\',\\n    \\'osgShader/shaderNode/data\\',\\n    \\'osgShader/shaderNode/environment\\',\\n    \\'osgShader/shaderNode/functions\\',\\n    \\'osgShader/shaderNode/lights\\',\\n    \\'osgShader/shaderNode/operations\\',\\n    \\'osgShader/shaderNode/shadows\\',\\n    \\'osgShader/shaderNode/textures\\',\\n    \\'osgShader/utils/sprintf\\',\\n    \\'osg/Shape\\',\\n    \\'osg/Stack\\',\\n    \\'osg/State\\',\\n    \\'osg/StateAttribute\\',\\n    \\'osg/StateGraph\\',\\n    \\'osg/StateSet\\',\\n    \\'osg/Texture\\',\\n    \\'osg/TextureCubeMap\\',\\n    \\'osg/Transform\\',\\n    \\'osg/TriangleIndexFunctor\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/UpdateVisitor\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Vec2\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Vec4\\',\\n    \\'osg/Viewport\\',\\n    \\'osgUtil/osgPool\\',\\n    \\'osg/TransformEnums\\',\\n    \\'osg/WebGLCaps\\'\\n\\n], function( BlendColor,\\n             BlendFunc,\\n             BoundingBox,\\n             BoundingSphere,\\n             BufferArray,\\n             Camera,\\n             ComputeMatrixFromNodePath,\\n             CullFace,\\n             CullSettings,\\n             CullStack,\\n             CullVisitor,\\n             Depth,\\n             DrawArrayLengths,\\n             DrawArrays,\\n             DrawElements,\\n             EllipsoidModel,\\n             FrameBufferObject,\\n             FrameStamp,\\n             Geometry,\\n             Image,\\n             KdTree,\\n             KdTreeBuilder,\\n             Light,\\n             LightSource,\\n             LineWidth,\\n             Lod,\\n             Map,\\n             Material,\\n             Math,\\n             Matrix,\\n             MatrixTransform,\\n             Node,\\n             NodeVisitor,\\n             Notify,\\n             Object,\\n\\t\\t\\t PagedLOD,\\n             PrimitiveSet,\\n             Program,\\n             Projection,\\n             Quat,\\n             RenderBin,\\n             RenderStage,\\n             Shader,\\n             ShaderGeneratorProxy,\\n             ShaderGenerator,\\n             Compiler,\\n             ShaderGeneratorStateSet,\\n             ShaderGeneratorMaterial,\\n             CompilerMaterial,\\n             ShaderGeneratorShadeless,\\n             CompilerShadeless,\\n             ShaderProcessor,\\n             ShaderLib,\\n             ShaderNode,\\n             data,\\n             environment,\\n             functions,\\n             lights,\\n             operations,\\n             shadows,\\n             textures,\\n             sprintf,\\n             Shape,\\n             Stack,\\n             State,\\n             StateAttribute,\\n             StateGraph,\\n             StateSet,\\n             Texture,\\n             TextureCubeMap,\\n             Transform,\\n             TriangleIndexFunctor,\\n             Uniform,\\n             UpdateVisitor,\\n             MACROUTILS,\\n             Vec2,\\n             Vec3,\\n             Vec4,\\n             Viewport,\\n             osgPool,\\n             TransformEnums,\\n             WebGLCaps ) {\\n\\n\\tvar osg = {};\\n\\t\\n\\t osg.BlendColor = BlendColor;\\n\\t osg.BlendFunc = BlendFunc;\\n\\t osg.BoundingBox = BoundingBox;\\n\\t osg.BoundingSphere = BoundingSphere;\\n\\t osg.BufferArray = BufferArray;\\n\\t osg.Camera = Camera;\\n\\t MACROUTILS.objectMix( osg, ComputeMatrixFromNodePath );\\n\\t osg.CullFace = CullFace;\\n\\t osg.CullSettings = CullSettings;\\n\\t osg.CullStack = CullStack;\\n\\t osg.CullVisitor = CullVisitor;\\n\\t osg.Depth = Depth;\\n\\t osg.DrawArrayLengths = DrawArrayLengths;\\n\\t osg.DrawArrays = DrawArrays;\\n\\t osg.DrawElements = DrawElements;\\n\\t osg.EllipsoidModel = EllipsoidModel;\\n\\t osg.WGS_84_RADIUS_EQUATOR = EllipsoidModel.WGS_84_RADIUS_EQUATOR;\\n\\t osg.WGS_84_RADIUS_POLAR = EllipsoidModel.WGS_84_RADIUS_POLAR;\\n\\t osg.FrameBufferObject = FrameBufferObject;\\n\\t osg.FrameStamp = FrameStamp;\\n\\t osg.Geometry = Geometry;\\n\\t osg.Image = Image;\\n\\t osg.KdTree = KdTree;\\n\\t osg.KdTreeBuilder = KdTreeBuilder;\\n\\t osg.Light = Light;\\n\\t osg.LightSource = LightSource;\\n\\t osg.LineWidth = LineWidth;\\n\\t osg.Lod = Lod;\\n\\t osg.Map = Map;\\n\\t osg.Material = Material;\\n\\t MACROUTILS.objectMix( osg, Math );\\n\\t osg.Matrix = Matrix;\\n\\t osg.MatrixTransform = MatrixTransform;\\n\\t osg.Node = Node;\\n\\t osg.NodeVisitor = NodeVisitor;\\n\\t MACROUTILS.objectMix( osg, Notify );\\n\\t osg.Object = Object;\\n     osg.PagedLOD = PagedLOD;\\n\\t osg.PrimitiveSet = PrimitiveSet;\\n\\t osg.Program = Program;\\n\\t osg.Projection = Projection;\\n\\t osg.Quat = Quat;\\n\\t osg.RenderBin = RenderBin;\\n\\t osg.RenderStage = RenderStage;\\n\\t osg.Shader = Shader;\\n\\t osg.ShaderGenerator = ShaderGenerator;\\n\\t osg.ShaderGeneratorType = ShaderGenerator.Type;\\n\\t osg.ShaderGeneratorProxy = ShaderGeneratorProxy;\\n\\t osg.ShaderLib = ShaderLib;\\n\\t osg.ShaderProcessor = ShaderProcessor;\\n\\t MACROUTILS.objectMix( osg, Shape );\\n\\t osg.Stack = Stack;\\n\\t osg.State = State;\\n\\t osg.StateAttribute = StateAttribute;\\n\\t osg.StateGraph = StateGraph;\\n\\t osg.StateSet = StateSet;\\n\\t osg.Texture = Texture;\\n\\t osg.TextureCubeMap = TextureCubeMap;\\n\\t osg.Transform = Transform;\\n\\t osg.TriangleIndexFunctor = TriangleIndexFunctor;\\n\\t osg.Uniform = Uniform;\\n\\t osg.UpdateVisitor = UpdateVisitor;\\n\\t MACROUTILS.objectMix( osg, MACROUTILS );\\n\\t osg.Vec2 = Vec2;\\n\\t osg.Vec3 = Vec3;\\n\\t osg.Vec4 = Vec4;\\n\\t osg.Viewport = Viewport;\\n\\n\\t osg.memoryPools = osgPool.memoryPools;\\n\\n\\t osg.Transform.RELATIVE_RF = TransformEnums.RELATIVE_RF;\\n\\t osg.Transform.ABSOLUTE_RF = TransformEnums.ABSOLUTE_RF;\\n\\n\\t osg.WebGLCaps = WebGLCaps;\\n\\n\\t return osg;\\n } );\\n\\n//# sourceURL=/osg/osg.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Animation\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( MACROUTILS, Object ) {\\n\\n    /**\\n     *  Animation\\n     *  @class Animation\\n     */\\n    var Animation = function () {\\n        Object.call( this );\\n        this._channels = [];\\n    };\\n\\n    /** @lends Animation.prototype */\\n    Animation.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        getChannels: function () {\\n            return this._channels;\\n        },\\n        getDuration: function () {\\n            var tmin = 1e5;\\n            var tmax = -1e5;\\n            for ( var i = 0, l = this._channels.length; i < l; i++ ) {\\n                var channel = this._channels[ i ];\\n                tmin = Math.min( tmin, channel.getStartTime() );\\n                tmax = Math.max( tmax, channel.getEndTime() );\\n            }\\n            return tmax - tmin;\\n        }\\n\\n    } );\\n\\n    return Animation;\\n} );\\n\\n//# sourceURL=/osgAnimation/Animation.js\");\n\n",
    "eval(\"define( \\'osgAnimation/AnimationUpdateCallback\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( Notify, MACROUTILS, Object ) {\\n\\n    /**\\n     *  AnimationUpdateCallback\\n     *  @class AnimationUpdateCallback\\n     */\\n    var AnimationUpdateCallback = function () {};\\n\\n    /** @lends AnimationUpdateCallback.prototype */\\n    AnimationUpdateCallback.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n\\n        linkChannel: function () {},\\n        linkAnimation: function ( anim ) {\\n            var name = this.getName();\\n            if ( name.length === 0 ) {\\n                Notify.log( \\'no name on an update callback, discard\\' );\\n                return 0;\\n            }\\n            var nbLinks = 0;\\n            var channels = anim.getChannels();\\n            for ( var i = 0, l = channels.length; i < l; i++ ) {\\n                var channel = channels[ i ];\\n                if ( channel.getTargetName() === name ) {\\n                    this.linkChannel( channel );\\n                    nbLinks++;\\n                }\\n            }\\n            return nbLinks;\\n        }\\n    } );\\n\\n    return AnimationUpdateCallback;\\n} );\\n\\n//# sourceURL=/osgAnimation/AnimationUpdateCallback.js\");\n\n",
    "eval(\"define( \\'osgAnimation/BasicAnimationManager\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( Notify, MACROUTILS, Object ) {\\n\\n    /**\\n     *  BasicAnimationManager\\n     *  @class BasicAnimationManager\\n     */\\n    var BasicAnimationManager = function () {\\n        Object.call( this );\\n        this._animations = {};\\n\\n        this._actives = {};\\n        this._actives._keys = [];\\n\\n        this._lastUpdate = undefined;\\n        this._targets = [];\\n    };\\n\\n    /** @lends BasicAnimationManager.prototype */\\n    BasicAnimationManager.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        _updateAnimation: function ( animationParameter, t, priority ) {\\n            var duration = animationParameter.duration;\\n            var weight = animationParameter.weight;\\n            var animation = animationParameter.anim;\\n            var start = animationParameter.start;\\n            var loop = animationParameter.loop;\\n\\n            if ( loop > 0 ) {\\n                var playedTimes = t - start;\\n                if ( playedTimes >= loop * duration ) {\\n                    return true;\\n                }\\n            }\\n\\n            t = ( t - start ) % duration;\\n            var callback = animationParameter.callback;\\n            if ( callback ) {\\n                callback( t );\\n            }\\n\\n            var channels = animation.getChannels();\\n            for ( var i = 0, l = channels.length; i < l; i++ ) {\\n                var channel = channels[ i ];\\n                channel.update( t, weight, priority );\\n            }\\n            return false;\\n        },\\n        update: function ( node, nv ) {\\n            var t = nv.getFrameStamp().getSimulationTime();\\n            this.updateManager( t );\\n            return true;\\n        },\\n        updateManager: function ( t ) {\\n\\n            var targets = this._targets;\\n            for ( var i = 0, l = targets.length; i < l; i++ ) {\\n                targets[ i ].reset();\\n            }\\n            if ( this._actives._keys.length > 0 ) {\\n                var pri = this._actives._keys.length - 1;\\n                while ( pri >= 0 ) {\\n                    var layer = this._actives[ pri ];\\n                    var keys = this._actives[ pri ]._keys;\\n                    var removes = [];\\n                    for ( var ai = 0, al = keys.length; ai < al; ai++ ) {\\n                        var key = keys[ ai ];\\n                        var anim = layer[ key ];\\n                        if ( anim.start === undefined ) {\\n                            anim.start = t;\\n                        }\\n                        var remove = this._updateAnimation( anim, t, pri );\\n                        if ( remove ) {\\n                            removes.push( ai );\\n                        }\\n                    }\\n\\n                    // remove finished animation\\n                    for ( var j = removes.length - 1; j >= 0; j-- ) {\\n                        var k = keys[ j ];\\n                        keys.splice( j, 1 );\\n                        delete layer[ k ];\\n                    }\\n\\n                    pri--;\\n                }\\n            }\\n        },\\n\\n        stopAll: function () {},\\n        isPlaying: function ( name ) {\\n            if ( this._actives._keys.length > 0 ) {\\n                var pri = this._actives._keys.length - 1;\\n                while ( pri >= 0 ) {\\n                    if ( this._actives[ pri ][ name ] ) {\\n                        return true;\\n                    }\\n                    pri--;\\n                }\\n            }\\n            return false;\\n        },\\n        stopAnimation: function ( name ) {\\n            if ( this._actives._keys.length > 0 ) {\\n                var pri = this._actives._keys.length - 1;\\n                var filterFunction = function ( element /*, index , array */ ) {\\n                    return element !== \\'_keys\\';\\n                };\\n                while ( pri >= 0 ) {\\n                    if ( this._actives[ pri ][ name ] ) {\\n                        delete this._actives[ pri ][ name ];\\n                        this._actives[ pri ]._keys = window.Object.keys( this._actives[ pri ] ).filter( filterFunction );\\n                        return;\\n                    }\\n                    pri--;\\n                }\\n            }\\n        },\\n        playAnimationObject: function ( obj ) {\\n            if ( obj.name === undefined ) {\\n                return;\\n            }\\n\\n            var anim = this._animations[ obj.name ];\\n            if ( anim === undefined ) {\\n                Notify.info( \\'no animation \\' + obj.name + \\' found\\' );\\n                return;\\n            }\\n\\n            if ( this.isPlaying( obj.name ) ) {\\n                return;\\n            }\\n\\n            if ( obj.priority === undefined ) {\\n                obj.priority = 0;\\n            }\\n\\n            if ( obj.weight === undefined ) {\\n                obj.weight = 1.0;\\n            }\\n\\n            if ( obj.timeFactor === undefined ) {\\n                obj.timeFactor = 1.0;\\n            }\\n\\n            if ( obj.loop === undefined ) {\\n                obj.loop = 0;\\n            }\\n\\n            if ( this._actives[ obj.priority ] === undefined ) {\\n                this._actives[ obj.priority ] = {};\\n                this._actives[ obj.priority ]._keys = [];\\n                this._actives._keys.push( obj.priority ); // = window.Object.keys(this._actives);\\n            }\\n\\n            obj.start = undefined;\\n            obj.duration = anim.getDuration();\\n            obj.anim = anim;\\n            this._actives[ obj.priority ][ obj.name ] = obj;\\n            this._actives[ obj.priority ]._keys.push( obj.name );\\n        },\\n\\n        playAnimation: function ( name, priority, weight ) {\\n            var animName = name;\\n            if ( typeof name === \\'object\\' ) {\\n                if ( name.getName === undefined ) {\\n                    return this.playAnimationObject( name );\\n                } else {\\n                    animName = name.getName();\\n                }\\n            }\\n            var obj = {\\n                \\'name\\': animName,\\n                \\'priority\\': priority,\\n                \\'weight\\': weight\\n            };\\n\\n            return this.playAnimationObject( obj );\\n        },\\n\\n        registerAnimation: function ( anim ) {\\n            this._animations[ anim.getName() ] = anim;\\n            this.buildTargetList();\\n        },\\n        getAnimationMap: function () {\\n            return this._animations;\\n        },\\n        buildTargetList: function () {\\n            this._targets.length = 0;\\n            var keys = window.Object.keys( this._animations );\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                var a = this._animations[ keys[ i ] ];\\n                var channels = a.getChannels();\\n                for ( var c = 0, lc = channels.length; c < lc; c++ ) {\\n                    var channel = channels[ c ];\\n                    this._targets.push( channel.getTarget() );\\n                }\\n            }\\n        }\\n\\n    } );\\n\\n    return BasicAnimationManager;\\n} );\\n\\n//# sourceURL=/osgAnimation/BasicAnimationManager.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Channel\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\'\\n], function ( MACROUTILS, Object ) {\\n\\n    /**\\n     *  Channel is responsible to interpolate keys\\n     *  @class Channel\\n     */\\n    var Channel = function ( sampler, target ) {\\n        Object.call( this );\\n        this._sampler = sampler;\\n        this._target = target;\\n        this._targetName = undefined;\\n        this._data = {\\n            \\'value\\': undefined,\\n            \\'key\\': 0\\n        };\\n    };\\n\\n    /** @lends Channel.prototype */\\n    Channel.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        getKeyframes: function () {\\n            return this._sampler.getKeyframes();\\n        },\\n        setKeyframes: function ( keys ) {\\n            this._sampler.setKeyframes( keys );\\n        },\\n        getStartTime: function () {\\n            return this._sampler.getStartTime();\\n        },\\n        getEndTime: function () {\\n            return this._sampler.getEndTime();\\n        },\\n        getSampler: function () {\\n            return this._sampler;\\n        },\\n        setSampler: function ( sampler ) {\\n            this._sampler = sampler;\\n        },\\n        getTarget: function () {\\n            return this._target;\\n        },\\n        setTarget: function ( target ) {\\n            this._target = target;\\n        },\\n        setTargetName: function ( name ) {\\n            this._targetName = name;\\n        },\\n        getTargetName: function () {\\n            return this._targetName;\\n        },\\n        update: function ( t, weight, priority ) {\\n            weight = weight || 1.0;\\n            priority = priority || 0.0;\\n\\n            // skip if weight == 0\\n            if ( weight < 1e-4 )\\n                return;\\n            var data = this._data;\\n            this._sampler.getValueAt( t, data );\\n            this._target.update.call( this._target, weight, data.value, priority );\\n        },\\n        reset: function () {\\n            this._target.reset();\\n        }\\n    } );\\n\\n    return Channel;\\n} );\\n\\n//# sourceURL=/osgAnimation/Channel.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Easing\\',[], function () {\\n\\n\\tvar easeOutQuad = function ( t ) {\\n\\t\\treturn -( t * ( t - 2.0 ) );\\n\\t};\\n\\tvar easeInQuad = function ( t ) {\\n\\t\\treturn ( t * t );\\n\\t};\\n\\tvar easeOutCubic = function ( t ) {\\n\\t\\tt = t - 1.0;\\n\\t\\treturn ( t * t * t + 1 );\\n\\t};\\n\\tvar easeInCubic = function ( t ) {\\n\\t\\treturn ( t * t * t );\\n\\t};\\n\\tvar easeOutQuart = function ( t ) {\\n\\t\\tt = t - 1;\\n\\t\\treturn -( t * t * t * t - 1 );\\n\\t};\\n\\tvar easeInQuart = function ( t ) {\\n\\t\\treturn ( t * t * t * t );\\n\\t};\\n\\tvar easeOutElastic = function ( t ) {\\n\\t\\treturn Math.pow( 2.0, -10.0 * t ) * Math.sin( ( t - 0.3 / 4.0 ) * ( 2.0 * Math.PI ) / 0.3 ) + 1.0;\\n\\t};\\n\\t//osgAnimation.EaseInElastic = function(t) { return ; };\\n\\tvar easeOutBounce = function ( t ) {\\n\\t\\tif ( t < ( 1 / 2.75 ) ) {\\n\\t\\t\\treturn ( 7.5625 * t * t );\\n\\t\\t} else if ( t < ( 2 / 2.75 ) ) {\\n\\t\\t\\treturn ( 7.5625 * ( t -= ( 1.5 / 2.75 ) ) * t + 0.75 );\\n\\t\\t} else if ( t < ( 2.5 / 2.75 ) ) {\\n\\t\\t\\treturn ( 7.5625 * ( t -= ( 2.25 / 2.75 ) ) * t + 0.9375 );\\n\\t\\t} else {\\n\\t\\t\\treturn ( 7.5625 * ( t -= ( 2.625 / 2.75 ) ) * t + 0.984375 );\\n\\t\\t}\\n\\t};\\n\\n\\treturn {\\n\\t\\teaseOutQuad: easeOutQuad,\\n\\t\\teaseInQuad: easeInQuad,\\n\\t\\teaseOutCubic: easeOutCubic,\\n\\t\\teaseInCubic: easeInCubic,\\n\\t\\teaseOutQuart: easeOutQuart,\\n\\t\\teaseInQuart: easeInQuart,\\n\\t\\teaseOutElastic: easeOutElastic,\\n\\t\\teaseOutBounce: easeOutBounce,\\n\\t\\tEaseOutQuad: easeOutQuad,\\n\\t\\tEaseInQuad: easeInQuad,\\n\\t\\tEaseOutCubic: easeOutCubic,\\n\\t\\tEaseInCubic: easeInCubic,\\n\\t\\tEaseOutQuart: easeOutQuart,\\n\\t\\tEaseInQuart: easeInQuart,\\n\\t\\tEaseOutElastic: easeOutElastic,\\n\\t\\tEaseOutBounce: easeOutBounce\\n\\t};\\n} );\\n\\n//# sourceURL=/osgAnimation/Easing.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Sampler\\',[], function () {\\n\\n    /**\\n     *  Sampler is responsible to interpolate keys\\n     *  @class Sampler\\n     */\\n    var Sampler = function ( keys, interpolator ) {\\n        if ( !keys ) {\\n            keys = [];\\n        }\\n        this._keys = keys;\\n        this._interpolator = interpolator;\\n    };\\n\\n    /** @lends Sampler.prototype */\\n    Sampler.prototype = {\\n\\n        getKeyframes: function () {\\n            return this._keys;\\n        },\\n        setKeyframes: function ( keys ) {\\n            this._keys = keys;\\n        },\\n        setInterpolator: function ( interpolator ) {\\n            this._interpolator = interpolator;\\n        },\\n        getInterpolator: function () {\\n            return this._interpolator;\\n        },\\n        getStartTime: function () {\\n            if ( this._keys.length === 0 ) {\\n                return undefined;\\n            }\\n            return this._keys[ 0 ].t;\\n        },\\n        getEndTime: function () {\\n            if ( this._keys.length === 0 ) {\\n                return undefined;\\n            }\\n            return this._keys[ this._keys.length - 1 ].t;\\n        },\\n\\n        // result contains the keyIndex where to start, this key\\n        // will be updated when calling the Interpolator\\n        // result.value will contain the interpolation result\\n        // { \\'value\\': undefined, \\'keyIndex\\': 0 };\\n        getValueAt: function ( t, result ) {\\n            // reset the key if invalid\\n            if ( this._keys[ result.key ].t > t ) {\\n                result.key = 0;\\n            }\\n            this._interpolator( this._keys, t, result );\\n        }\\n    };\\n\\n    return Sampler;\\n} );\\n\\n//# sourceURL=/osgAnimation/Sampler.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Interpolator\\',[\\n    \\'osg/Quat\\'\\n], function ( Quat ) {\\n\\n    /**\\n     *  Interpolator provide interpolation function to sampler\\n     */\\n    var Vec3LerpInterpolator = function ( keys, t, result ) {\\n        var keyStart;\\n        var startTime;\\n        var keyEnd = keys[ keys.length - 1 ];\\n        var endTime = keyEnd.t;\\n        if ( t >= endTime ) {\\n            result.key = 0;\\n            result.value[ 0 ] = keyEnd[ 0 ];\\n            result.value[ 1 ] = keyEnd[ 1 ];\\n            result.value[ 2 ] = keyEnd[ 2 ];\\n            return;\\n        } else {\\n            keyStart = keys[ 0 ];\\n            startTime = keyStart.t;\\n\\n            if ( t <= startTime ) {\\n                result.key = 0;\\n                result.value[ 0 ] = keyStart[ 0 ];\\n                result.value[ 1 ] = keyStart[ 1 ];\\n                result.value[ 2 ] = keyStart[ 2 ];\\n                return;\\n            }\\n        }\\n\\n        var i1 = result.key;\\n        while ( keys[ i1 + 1 ].t < t ) {\\n            i1++;\\n        }\\n        var i2 = i1 + 1;\\n\\n        var t1 = keys[ i1 ].t;\\n        var x1 = keys[ i1 ][ 0 ];\\n        var y1 = keys[ i1 ][ 1 ];\\n        var z1 = keys[ i1 ][ 2 ];\\n\\n        var t2 = keys[ i2 ].t;\\n        var x2 = keys[ i2 ][ 0 ];\\n        var y2 = keys[ i2 ][ 1 ];\\n        var z2 = keys[ i2 ][ 2 ];\\n\\n        var r = ( t - t1 ) / ( t2 - t1 );\\n\\n        result.value[ 0 ] = x1 + ( x2 - x1 ) * r;\\n        result.value[ 1 ] = y1 + ( y2 - y1 ) * r;\\n        result.value[ 2 ] = z1 + ( z2 - z1 ) * r;\\n        result.key = i1;\\n    };\\n\\n    var QuatLerpInterpolator = function ( keys, t, result ) {\\n        var keyStart;\\n        var startTime;\\n        var keyEnd = keys[ keys.length - 1 ];\\n        var endTime = keyEnd.t;\\n        if ( t >= endTime ) {\\n            result.key = 0;\\n            result.value[ 0 ] = keyEnd[ 0 ];\\n            result.value[ 1 ] = keyEnd[ 1 ];\\n            result.value[ 2 ] = keyEnd[ 2 ];\\n            result.value[ 3 ] = keyEnd[ 3 ];\\n            return;\\n        } else {\\n            keyStart = keys[ 0 ];\\n            startTime = keyStart.t;\\n\\n            if ( t <= startTime ) {\\n                result.key = 0;\\n                result.value[ 0 ] = keyStart[ 0 ];\\n                result.value[ 1 ] = keyStart[ 1 ];\\n                result.value[ 2 ] = keyStart[ 2 ];\\n                result.value[ 3 ] = keyStart[ 3 ];\\n                return;\\n            }\\n        }\\n\\n        var i1 = result.key;\\n        while ( keys[ i1 + 1 ].t < t ) {\\n            i1++;\\n        }\\n        var i2 = i1 + 1;\\n\\n        var t1 = keys[ i1 ].t;\\n        var x1 = keys[ i1 ][ 0 ];\\n        var y1 = keys[ i1 ][ 1 ];\\n        var z1 = keys[ i1 ][ 2 ];\\n        var w1 = keys[ i1 ][ 3 ];\\n\\n        var t2 = keys[ i2 ].t;\\n        var x2 = keys[ i2 ][ 0 ];\\n        var y2 = keys[ i2 ][ 1 ];\\n        var z2 = keys[ i2 ][ 2 ];\\n        var w2 = keys[ i2 ][ 3 ];\\n\\n        var r = ( t - t1 ) / ( t2 - t1 );\\n\\n        result.value[ 0 ] = x1 + ( x2 - x1 ) * r;\\n        result.value[ 1 ] = y1 + ( y2 - y1 ) * r;\\n        result.value[ 2 ] = z1 + ( z2 - z1 ) * r;\\n        result.value[ 3 ] = w1 + ( w2 - w1 ) * r;\\n        result.key = i1;\\n    };\\n\\n    var QuatSlerpInterpolator = function ( keys, t, result ) {\\n        var keyStart;\\n        var startTime;\\n        var keyEnd = keys[ keys.length - 1 ];\\n        var endTime = keyEnd.t;\\n        if ( t >= endTime ) {\\n            result.key = 0;\\n            result.value[ 0 ] = keyEnd[ 0 ];\\n            result.value[ 1 ] = keyEnd[ 1 ];\\n            result.value[ 2 ] = keyEnd[ 2 ];\\n            result.value[ 3 ] = keyEnd[ 3 ];\\n            return;\\n        } else {\\n            keyStart = keys[ 0 ];\\n            startTime = keyStart.t;\\n\\n            if ( t <= startTime ) {\\n                result.key = 0;\\n                result.value[ 0 ] = keyStart[ 0 ];\\n                result.value[ 1 ] = keyStart[ 1 ];\\n                result.value[ 2 ] = keyStart[ 2 ];\\n                result.value[ 3 ] = keyStart[ 3 ];\\n                return;\\n            }\\n        }\\n\\n        var i1 = result.key;\\n        while ( keys[ i1 + 1 ].t < t ) {\\n            i1++;\\n        }\\n        var i2 = i1 + 1;\\n\\n        var t1 = keys[ i1 ].t;\\n        var t2 = keys[ i2 ].t;\\n        var r = ( t - t1 ) / ( t2 - t1 );\\n\\n        Quat.slerp( r, keys[ i1 ], keys[ i2 ], result.value );\\n        result.key = i1;\\n    };\\n\\n    /**\\n     *  Interpolator provide interpolation function to sampler\\n     */\\n    var FloatLerpInterpolator = function ( keys, t, result ) {\\n        var keyStart;\\n        var startTime;\\n        var keyEnd = keys[ keys.length - 1 ];\\n        var endTime = keyEnd.t;\\n        if ( t >= endTime ) {\\n            result.key = 0;\\n            result.value = keyEnd[ 0 ];\\n            return;\\n        } else {\\n            keyStart = keys[ 0 ];\\n            startTime = keyStart.t;\\n\\n            if ( t <= startTime ) {\\n                result.key = 0;\\n                result.value = keyStart[ 0 ];\\n                return;\\n            }\\n        }\\n\\n        var i1 = result.key;\\n        while ( keys[ i1 + 1 ].t < t ) {\\n            i1++;\\n        }\\n        var i2 = i1 + 1;\\n\\n        var t1 = keys[ i1 ].t;\\n        var x1 = keys[ i1 ][ 0 ];\\n\\n        var t2 = keys[ i2 ].t;\\n        var x2 = keys[ i2 ][ 0 ];\\n\\n        var r = ( t - t1 ) / ( t2 - t1 );\\n        result.value = x1 + ( x2 - x1 ) * r;\\n        result.key = i1;\\n    };\\n\\n    /**\\n     *  Interpolator provide interpolation function to sampler\\n     */\\n    var FloatStepInterpolator = function ( keys, t, result ) {\\n        var keyStart;\\n        var startTime;\\n        var keyEnd = keys[ keys.length - 1 ];\\n        var endTime = keyEnd.t;\\n        if ( t >= endTime ) {\\n            result.key = 0;\\n            result.value = keyEnd[ 0 ];\\n            return;\\n        } else {\\n            keyStart = keys[ 0 ];\\n            startTime = keyStart.t;\\n\\n            if ( t <= startTime ) {\\n                result.key = 0;\\n                result.value = keyStart[ 0 ];\\n                return;\\n            }\\n        }\\n\\n        var i1 = result.key;\\n        while ( keys[ i1 + 1 ].t < t ) {\\n            i1++;\\n        }\\n        //var i2 = i1 + 1;\\n\\n        //var t1 = keys[ i1 ].t;\\n        var x1 = keys[ i1 ][ 0 ];\\n        result.value = x1;\\n        result.key = i1;\\n    };\\n\\n    return {\\n        Vec3LerpInterpolator: Vec3LerpInterpolator,\\n        QuatLerpInterpolator: QuatLerpInterpolator,\\n        QuatSlerpInterpolator: QuatSlerpInterpolator,\\n        FloatLerpInterpolator: FloatLerpInterpolator,\\n        FloatStepInterpolator: FloatStepInterpolator\\n    };\\n} );\\n\\n//# sourceURL=/osgAnimation/Interpolator.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Target\\',[], function ( ) {\\n\\n    /**\\n     *  Target keep internal data of element to animate, and some function to merge them\\n     *  @class Target\\n     */\\n    var Target = function () {\\n        this._weight = 0;\\n        this._priorityWeight = 0;\\n        this._count = 0;\\n        this._lastPriority = 0;\\n        this._target = undefined;\\n    };\\n\\n    Target.prototype = {\\n        reset: function () {\\n            this._weight = 0;\\n            this._priorityWeight = 0;\\n        },\\n        getValue: function () {\\n            return this._target;\\n        }\\n    };\\n\\n    return Target;\\n} );\\n\\n//# sourceURL=/osgAnimation/Target.js\");\n\n",
    "eval(\"define( \\'osgAnimation/FloatTarget\\',[\\n    \\'osg/Utils\\',\\n    \\'osgAnimation/Target\\'\\n], function ( MACROUTILS, Target ) {\\n\\n    var FloatTarget = function ( value ) {\\n        Target.call( this );\\n        this._target = [ value ];\\n    };\\n\\n    FloatTarget.prototype = MACROUTILS.objectInehrit( Target.prototype, {\\n        update: function ( weight, val, priority ) {\\n            if ( this._weight || this._priorityWeight ) {\\n\\n                if ( this._lastPriority !== priority ) {\\n                    // change in priority\\n                    // add to weight with the same previous priority cumulated weight\\n                    this._weight += this._priorityWeight * ( 1.0 - this._weight );\\n                    this._priorityWeight = 0;\\n                    this._lastPriority = priority;\\n                }\\n\\n                this._priorityWeight += weight;\\n                var t = ( 1.0 - this._weight ) * weight / this._priorityWeight;\\n                this._target += ( val - this._target ) * t;\\n            } else {\\n\\n                this._priorityWeight = weight;\\n                this._lastPriority = priority;\\n                this._target = val;\\n            }\\n        }\\n    } );\\n\\n    return FloatTarget;\\n} );\\n\\n//# sourceURL=/osgAnimation/FloatTarget.js\");\n\n",
    "eval(\"define( \\'osgAnimation/FloatLerpChannel\\',[\\n    \\'osgAnimation/Channel\\',\\n    \\'osgAnimation/Sampler\\',\\n    \\'osgAnimation/Interpolator\\',\\n    \\'osgAnimation/FloatTarget\\'\\n], function ( Channel, Sampler, Interpolator, FloatTarget ) {\\n\\n    var FloatLerpChannel = function ( keys, target ) {\\n        var sampler = new Sampler();\\n        if ( !keys ) {\\n            keys = [];\\n        }\\n        if ( !target ) {\\n            target = new FloatTarget();\\n        }\\n        Channel.call( this, sampler, target );\\n        sampler.setInterpolator( Interpolator.FloatLerpInterpolator );\\n        this.setKeyframes( keys );\\n        this._data.value = target.getValue();\\n    };\\n\\n    FloatLerpChannel.prototype = Channel.prototype;\\n\\n    return FloatLerpChannel;\\n} );\\n\\n//# sourceURL=/osgAnimation/FloatLerpChannel.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Keyframe\\',[], function () {\\n\\n    var createVec3Keyframe = function ( t, array ) {\\n        var k = array.slice( 0 );\\n        k.t = t;\\n        return k;\\n    };\\n\\n    var createQuatKeyframe = function ( t, array ) {\\n        var k = array.slice( 0 );\\n        k.t = t;\\n        return k;\\n    };\\n\\n    var createFloatKeyframe = function ( t, value ) {\\n        var k = [ value ];\\n        k.t = t;\\n        return k;\\n    };\\n\\n    return {\\n        createVec3Keyframe: createVec3Keyframe,\\n        createQuatKeyframe: createQuatKeyframe,\\n        createFloatKeyframe: createFloatKeyframe\\n    };\\n} );\\n\\n//# sourceURL=/osgAnimation/Keyframe.js\");\n\n",
    "eval(\"define( \\'osgAnimation/LinkVisitor\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Object\\',\\n    \\'osgAnimation/AnimationUpdateCallback\\'\\n], function ( Notify, MACROUTILS, NodeVisitor, Object, AnimationUpdateCallback ) {\\n\\n\\n    /**\\n     *  LinkVisitor search for animationUpdateCallback and link animation data\\n     *  @class LinkVisitor\\n     */\\n    var LinkVisitor = function () {\\n        NodeVisitor.call( this );\\n        this._animations = undefined;\\n        this._nbLinkTarget = 0;\\n    };\\n\\n    /** @lends LinkVisitor.prototype */\\n    LinkVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n        setAnimationMap: function ( anims ) {\\n            this._animations = anims;\\n            this._animationKeys = window.Object.keys( anims );\\n        },\\n\\n        apply: function ( node ) {\\n            var cbs = node.getUpdateCallbackList();\\n            for ( var i = 0, l = cbs.length; i < l; i++ ) {\\n                var cb = cbs[ i ];\\n                if ( cb instanceof AnimationUpdateCallback ) {\\n                    this.link( cb );\\n                }\\n            }\\n            this.traverse( node );\\n        },\\n\\n        link: function ( animCallback ) {\\n            var result = 0;\\n            var anims = this._animations;\\n            var animKeys = this._animationKeys;\\n            for ( var i = 0, l = animKeys.length; i < l; i++ ) {\\n                var key = animKeys[ i ];\\n                var anim = anims[ key ];\\n                result += animCallback.linkAnimation( anim );\\n            }\\n            this._nbLinkedTarget += result;\\n            Notify.info( \\'linked \\' + result + \\' for \\\"\\' + animCallback.getName() + \\'\\\"\\' );\\n        }\\n\\n    } );\\n\\n    return LinkVisitor;\\n} );\\n\\n//# sourceURL=/osgAnimation/LinkVisitor.js\");\n\n",
    "eval(\"define( \\'osgAnimation/QuatTarget\\',[\\n    \\'osg/Utils\\',\\n    \\'osgAnimation/Target\\',\\n    \\'osg/Quat\\'\\n], function ( MACROUTILS, Target, Quat ) {\\n\\n\\n    var QuatTarget = function () {\\n        Target.call( this );\\n        this._target = Quat.create();\\n    };\\n    QuatTarget.prototype = MACROUTILS.objectInehrit( Target.prototype, {\\n        update: function ( weight, val, priority ) {\\n            if ( this._weight || this._priorityWeight ) {\\n\\n                if ( this._lastPriority !== priority ) {\\n                    // change in priority\\n                    // add to weight with the same previous priority cumulated weight\\n                    this._weight += this._priorityWeight * ( 1.0 - this._weight );\\n                    this._priorityWeight = 0;\\n                    this._lastPriority = priority;\\n                }\\n\\n                this._priorityWeight += weight;\\n                var t = ( 1.0 - this._weight ) * weight / this._priorityWeight;\\n                Quat.lerp( t, this._target, val, this._target );\\n                Quat.normalize( this._target, this._target );\\n\\n            } else {\\n\\n                this._priorityWeight = weight;\\n                this._lastPriority = priority;\\n                Quat.copy( val, this._target );\\n            }\\n        }\\n    } );\\n\\n    return QuatTarget;\\n} );\\n\\n//# sourceURL=/osgAnimation/QuatTarget.js\");\n\n",
    "eval(\"define( \\'osgAnimation/QuatLerpChannel\\',[\\n    \\'osgAnimation/Channel\\',\\n    \\'osgAnimation/Sampler\\',\\n    \\'osgAnimation/Interpolator\\',\\n    \\'osgAnimation/QuatTarget\\',\\n    \\'osg/Quat\\'\\n], function ( Channel, Sampler, Interpolator, QuatTarget, Quat ) {\\n\\n    var QuatLerpChannel = function ( keys, target ) {\\n        var sampler = new Sampler();\\n        if ( !keys ) {\\n            keys = [];\\n        }\\n        if ( !target ) {\\n            target = new QuatTarget();\\n        }\\n        Channel.call( this, sampler, target );\\n        sampler.setInterpolator( Interpolator.QuatLerpInterpolator );\\n        this.setKeyframes( keys );\\n        this._data.value = Quat.copy( target.getValue(), Quat.create() );\\n    };\\n\\n    QuatLerpChannel.prototype = Channel.prototype;\\n\\n    return QuatLerpChannel;\\n} );\\n\\n//# sourceURL=/osgAnimation/QuatLerpChannel.js\");\n\n",
    "eval(\"define( \\'osgAnimation/QuatSlerpChannel\\',[\\n    \\'osgAnimation/Channel\\',\\n    \\'osgAnimation/QuatLerpChannel\\',\\n    \\'osgAnimation/Interpolator\\'\\n], function ( Channel, QuatLerpChannel, Interpolator ) {\\n\\n\\n    var QuatSlerpChannel = function ( keys, target ) {\\n        QuatLerpChannel.call( this, keys, target );\\n        this.getSampler().setInterpolator( Interpolator.QuatSlerpInterpolator );\\n    };\\n\\n    QuatSlerpChannel.prototype = Channel.prototype;\\n\\n    return QuatSlerpChannel;\\n} );\\n\\n//# sourceURL=/osgAnimation/QuatSlerpChannel.js\");\n\n",
    "eval(\"define( \\'osgAnimation/StackedQuaternion\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\',\\n    \\'osg/Matrix\\',\\n    \\'osgAnimation/QuatTarget\\',\\n    \\'osg/Quat\\'\\n], function ( MACROUTILS, Object, Matrix, QuatTarget, Quat ) {\\n\\n    /**\\n     *  StackedQuaternion\\n     *  @class StackedQuaternion\\n     */\\n    var StackedQuaternion = function ( name, quat ) {\\n        Object.call( this );\\n        if ( !quat ) {\\n            quat = Quat.create();\\n        }\\n        this._quaternion = quat;\\n        this._target = undefined;\\n        this._matrixTmp = Matrix.create();\\n        this.setName( name );\\n    };\\n\\n    /** @lends StackedQuaternion.prototype */\\n    StackedQuaternion.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        setQuaternion: function ( q ) {\\n            Quat.copy( q, this._quaternion );\\n        },\\n        setTarget: function ( target ) {\\n            this._target = target;\\n        },\\n        getTarget: function () {\\n            return this._target;\\n        },\\n        update: function () {\\n            if ( this._target !== undefined ) {\\n                Quat.copy( this._target.getValue(), this._quaternion );\\n            }\\n        },\\n        getOrCreateTarget: function () {\\n            if ( !this._target ) {\\n                this._target = new QuatTarget( this._quaternion );\\n            }\\n            return this._target;\\n        },\\n        applyToMatrix: function ( m ) {\\n            var mtmp = this._matrixTmp;\\n            Matrix.setRotateFromQuat( mtmp, this._quaternion );\\n            Matrix.preMult( m, mtmp );\\n        }\\n    } );\\n\\n    return StackedQuaternion;\\n} );\\n\\n//# sourceURL=/osgAnimation/StackedQuaternion.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Vec3Target\\',[\\n    \\'osg/Utils\\',\\n    \\'osgAnimation/Target\\',\\n    \\'osg/Vec3\\'\\n], function ( MACROUTILS, Target, Vec3 ) {\\n\\n    var Vec3Target = function () {\\n        Target.call( this );\\n        this._target = [ 0, 0, 0 ];\\n    };\\n    Vec3Target.prototype = MACROUTILS.objectInehrit( Target.prototype, {\\n        update: function ( weight, val, priority ) {\\n            if ( this._weight || this._priorityWeight ) {\\n\\n                if ( this._lastPriority !== priority ) {\\n                    // change in priority\\n                    // add to weight with the same previous priority cumulated weight\\n                    this._weight += this._priorityWeight * ( 1.0 - this._weight );\\n                    this._priorityWeight = 0;\\n                    this._lastPriority = priority;\\n                }\\n\\n                this._priorityWeight += weight;\\n                var t = ( 1.0 - this._weight ) * weight / this._priorityWeight;\\n                Vec3.lerp( t, this._target, val, this._target );\\n            } else {\\n\\n                this._priorityWeight = weight;\\n                this._lastPriority = priority;\\n                Vec3.copy( val, this._target );\\n            }\\n        }\\n    } );\\n\\n    return Vec3Target;\\n} );\\n\\n//# sourceURL=/osgAnimation/Vec3Target.js\");\n\n",
    "eval(\"define( \\'osgAnimation/StackedRotateAxis\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\',\\n    \\'osg/Matrix\\',\\n    \\'osgAnimation/Vec3Target\\',\\n    \\'osgAnimation/FloatTarget\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Quat\\'\\n], function ( MACROUTILS, Object, Matrix, Vec3Target, FloatTarget, Vec3, Quat ) {\\n\\n\\n    /**\\n     *  StackedRotateAxis\\n     *  @class StackedRotateAxis\\n     */\\n    var StackedRotateAxis = function ( name, axis, angle ) {\\n        Object.call( this );\\n        if ( !axis ) {\\n            axis = [ 1.0, 0.0, 0.0 ];\\n        }\\n        if ( !angle ) {\\n            angle = 0.0;\\n        }\\n        this._axis = axis;\\n        this._angle = angle;\\n        this._target = undefined;\\n        this.setName( name );\\n\\n        this._matrixTmp = Matrix.create();\\n        this._quatTmp = Matrix.create();\\n    };\\n\\n    /** @lends StackedRotateAxis.prototype */\\n    StackedRotateAxis.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        setAxis: function ( axis ) {\\n            Vec3.copy( axis, this._axis );\\n        },\\n        setAngle: function ( angle ) {\\n            this._angle = angle;\\n        },\\n        setTarget: function ( target ) {\\n            this._target = target;\\n        },\\n        getTarget: function () {\\n            return this._target;\\n        },\\n        update: function () {\\n            if ( this._target !== undefined ) {\\n                this._angle = this._target.getValue();\\n            }\\n        },\\n        getOrCreateTarget: function () {\\n            if ( !this._target ) {\\n                this._target = new FloatTarget( this._angle );\\n            }\\n            return this._target;\\n        },\\n        applyToMatrix: function ( m ) {\\n            var axis = this._axis;\\n            var qtmp = this._quatTmp;\\n            var mtmp = this._matrixTmp;\\n\\n            Quat.makeRotate( this._angle, axis[ 0 ], axis[ 1 ], axis[ 2 ], qtmp );\\n            Matrix.setRotateFromQuat( mtmp, qtmp );\\n            Matrix.preMult( m, mtmp );\\n        }\\n\\n    } );\\n\\n    return StackedRotateAxis;\\n} );\\n\\n//# sourceURL=/osgAnimation/StackedRotateAxis.js\");\n\n",
    "eval(\"define( \\'osgAnimation/StackedTranslate\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Object\\',\\n    \\'osg/Matrix\\',\\n    \\'osgAnimation/Vec3Target\\',\\n    \\'osg/Vec3\\'\\n], function ( MACROUTILS, Object, Matrix, Vec3Target, Vec3 ) {\\n\\n\\n    /**\\n     *  StackedTranslate\\n     *  @class StackedTranslate\\n     */\\n    var StackedTranslate = function ( name, translate ) {\\n        Object.call( this );\\n        if ( !translate ) {\\n            translate = [ 0, 0, 0 ];\\n        }\\n        this._translate = translate;\\n        this._target = undefined;\\n        this.setName( name );\\n    };\\n\\n    /** @lends StackedTranslate.prototype */\\n    StackedTranslate.prototype = MACROUTILS.objectInehrit( Object.prototype, {\\n        setTranslate: function ( translate ) {\\n            Vec3.copy( translate, this._translate );\\n        },\\n        setTarget: function ( target ) {\\n            this._target = target;\\n        },\\n        getTarget: function () {\\n            return this._target;\\n        },\\n        update: function () {\\n            if ( this._target !== undefined ) {\\n                Vec3.copy( this._target.getValue(), this._translate );\\n            }\\n        },\\n        getOrCreateTarget: function () {\\n            if ( !this._target ) {\\n                this._target = new Vec3Target( this._translate );\\n            }\\n            return this._target;\\n        },\\n        applyToMatrix: function ( m ) {\\n            Matrix.preMultTranslate( m, this._translate );\\n        }\\n    } );\\n\\n    return StackedTranslate;\\n} );\\n\\n//# sourceURL=/osgAnimation/StackedTranslate.js\");\n\n",
    "eval(\"define( \\'osgAnimation/UpdateMatrixTransform\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Matrix\\',\\n    \\'osgAnimation/AnimationUpdateCallback\\'\\n], function ( MACROUTILS, Notify, Matrix, AnimationUpdateCallback ) {\\n\\n    /**\\n     *  UpdateMatrixTransform\\n     *  @class UpdateMatrixTransform\\n     */\\n    var UpdateMatrixTransform = function () {\\n        AnimationUpdateCallback.call( this );\\n        this._stackedTransforms = [];\\n    };\\n\\n    /** @lends AnimationUpdateCallback.prototype */\\n    UpdateMatrixTransform.prototype = MACROUTILS.objectInehrit( AnimationUpdateCallback.prototype, {\\n        getStackedTransforms: function () {\\n            return this._stackedTransforms;\\n        },\\n        update: function ( node /*, nv */ ) {\\n\\n            // not optimized, we could avoid operation the animation did not change\\n            // the content of the transform element\\n            var matrix = node.getMatrix();\\n            Matrix.makeIdentity( matrix );\\n            var transforms = this._stackedTransforms;\\n            for ( var i = 0, l = transforms.length; i < l; i++ ) {\\n                var transform = transforms[ i ];\\n                transform.update();\\n                transform.applyToMatrix( matrix );\\n            }\\n            return true;\\n        },\\n        linkChannel: function ( channel ) {\\n            var channelName = channel.getName();\\n            var transforms = this._stackedTransforms;\\n            for ( var i = 0, l = transforms.length; i < l; i++ ) {\\n                var transform = transforms[ i ];\\n                var elementName = transform.getName();\\n                if ( channelName.length > 0 && elementName === channelName ) {\\n                    var target = transform.getOrCreateTarget();\\n                    if ( target ) {\\n                        channel.setTarget( target );\\n                        return true;\\n                    }\\n                }\\n            }\\n            Notify.log( \\'can\\\\\\'t link channel \\' + channelName + \\', does not contain a symbolic name that can be linked to TransformElements\\' );\\n            return false;\\n        }\\n\\n    } );\\n\\n    return UpdateMatrixTransform;\\n} );\\n\\n//# sourceURL=/osgAnimation/UpdateMatrixTransform.js\");\n\n",
    "eval(\"define( \\'osgAnimation/Vec3LerpChannel\\',[\\n    \\'osgAnimation/Channel\\',\\n    \\'osgAnimation/Sampler\\',\\n    \\'osgAnimation/Interpolator\\',\\n    \\'osgAnimation/Vec3Target\\',\\n    \\'osg/Vec3\\'\\n], function ( Channel, Sampler, Interpolator, Vec3Target, Vec3 ) {\\n\\n    var Vec3LerpChannel = function ( keys, target ) {\\n        var sampler = new Sampler();\\n        if ( !keys ) {\\n            keys = [];\\n        }\\n        if ( !target ) {\\n            target = new Vec3Target();\\n        }\\n        Channel.call( this, sampler, target );\\n        sampler.setInterpolator( Interpolator.Vec3LerpInterpolator );\\n        this.setKeyframes( keys );\\n        this._data.value = Vec3.copy( target.getValue(), [ 0.0, 0.0, 0.0 ] );\\n    };\\n\\n    Vec3LerpChannel.prototype = Channel.prototype;\\n\\n    return Vec3LerpChannel;\\n} );\\n\\n//# sourceURL=/osgAnimation/Vec3LerpChannel.js\");\n\n",
    "eval(\"define( \\'osgAnimation/osgAnimation\\',[\\n\\t\\'osg/Utils\\',\\n\\t\\'osgAnimation/Animation\\',\\n\\t\\'osgAnimation/AnimationUpdateCallback\\',\\n\\t\\'osgAnimation/BasicAnimationManager\\',\\n\\t\\'osgAnimation/Channel\\',\\n\\t\\'osgAnimation/Easing\\',\\n\\t\\'osgAnimation/FloatLerpChannel\\',\\n\\t\\'osgAnimation/FloatTarget\\',\\n\\t\\'osgAnimation/Interpolator\\',\\n\\t\\'osgAnimation/Keyframe\\',\\n\\t\\'osgAnimation/LinkVisitor\\',\\n\\t\\'osgAnimation/QuatLerpChannel\\',\\n\\t\\'osgAnimation/QuatSlerpChannel\\',\\n\\t\\'osgAnimation/QuatTarget\\',\\n\\t\\'osgAnimation/Sampler\\',\\n\\t\\'osgAnimation/StackedQuaternion\\',\\n\\t\\'osgAnimation/StackedRotateAxis\\',\\n\\t\\'osgAnimation/StackedTranslate\\',\\n\\t\\'osgAnimation/Target\\',\\n\\t\\'osgAnimation/UpdateMatrixTransform\\',\\n\\t\\'osgAnimation/Vec3LerpChannel\\',\\n\\t\\'osgAnimation/Vec3Target\\'\\n], function ( MACROUTILS, Animation, AnimationUpdateCallback, BasicAnimationManager, Channel, Easing, FloatLerpChannel, FloatTarget, Interpolator, Keyframe, LinkVisitor, QuatLerpChannel, QuatSlerpChannel, QuatTarget, Sampler, StackedQuaternion, StackedRotateAxis, StackedTranslate, Target, UpdateMatrixTransform, Vec3LerpChannel, Vec3Target ) {\\n\\n\\tvar osgAnimation = {};\\n\\n\\tosgAnimation.Animation = Animation;\\n\\tosgAnimation.AnimationUpdateCallback = AnimationUpdateCallback;\\n\\tosgAnimation.BasicAnimationManager = BasicAnimationManager;\\n\\tosgAnimation.Channel = Channel;\\n\\tMACROUTILS.objectMix( osgAnimation, Easing );\\n\\tosgAnimation.FloatLerpChannel = FloatLerpChannel;\\n\\tosgAnimation.FloatTarget = FloatTarget;\\n\\tMACROUTILS.objectMix( osgAnimation, Interpolator );\\n\\tMACROUTILS.objectMix( osgAnimation, Keyframe );\\n\\tosgAnimation.LinkVisitor = LinkVisitor;\\n\\tosgAnimation.QuatLerpChannel = QuatLerpChannel;\\n\\tosgAnimation.QuatSlerpChannel = QuatSlerpChannel;\\n\\tosgAnimation.QuatTarget = QuatTarget;\\n\\tosgAnimation.Sampler = Sampler;\\n\\tosgAnimation.StackedQuaternion = StackedQuaternion;\\n\\tosgAnimation.StackedRotateAxis = StackedRotateAxis;\\n\\tosgAnimation.StackedTranslate = StackedTranslate;\\n\\tosgAnimation.Target = Target;\\n\\tosgAnimation.UpdateMatrixTransform = UpdateMatrixTransform;\\n\\tosgAnimation.Vec3LerpChannel = Vec3LerpChannel;\\n\\tosgAnimation.Vec3Target = Vec3Target;\\n\\n\\treturn osgAnimation;\\n} );\\n\\n//# sourceURL=/osgAnimation/osgAnimation.js\");\n\n",
    "eval(\"define( \\'osgWrappers/serializers/osg\\',[\\n    \\'Q\\'\\n], function ( Q ) {\\n\\n    var osgWrapper = {};\\n\\n    osgWrapper.Object = function ( input, obj ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( /*o*/) {\\n            return true;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        if ( jsonObj.Name ) {\\n            obj.setName( jsonObj.Name );\\n        }\\n\\n        if ( jsonObj.UserDataContainer ) {\\n            var userdata = input.setJSON( jsonObj.UserDataContainer ).readUserDataContainer();\\n            if ( userdata !== undefined ) {\\n                obj.setUserData( userdata );\\n            }\\n        }\\n\\n        return obj;\\n    };\\n    /* jshint newcap: false */\\n    osgWrapper.Node = function ( input, node ) {\\n        var jsonObj = input.getJSON();\\n\\n        var check = function ( /*o*/) {\\n            return true;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        osgWrapper.Object( input, node );\\n\\n        var promiseArray = [];\\n\\n        var createCallback = function ( jsonCallback ) {\\n            var promise = input.setJSON( jsonCallback ).readObject();\\n            var df = Q.defer();\\n            promiseArray.push( df.promise );\\n            Q.when( promise ).then( function ( cb ) {\\n                if ( cb ) {\\n                    node.addUpdateCallback( cb );\\n                }\\n                df.resolve();\\n            } );\\n        };\\n\\n        if ( jsonObj.UpdateCallbacks ) {\\n            for ( var j = 0, l = jsonObj.UpdateCallbacks.length; j < l; j++ ) {\\n                createCallback( jsonObj.UpdateCallbacks[ j ] );\\n            }\\n        }\\n\\n        if ( jsonObj.StateSet ) {\\n            var pp = input.setJSON( jsonObj.StateSet ).readObject();\\n            var df = Q.defer();\\n            promiseArray.push( df.promise );\\n            Q.when( pp ).then( function ( stateset ) {\\n                node.setStateSet( stateset );\\n                df.resolve();\\n            } );\\n        }\\n\\n        var createChildren = function ( jsonChildren ) {\\n            var promise = input.setJSON( jsonChildren ).readObject();\\n            var df = Q.defer();\\n            Q.when( promise ).then( function ( obj ) {\\n                df.resolve( obj );\\n            } );\\n            return df.promise;\\n        };\\n\\n        var queue = [];\\n        // For each url, create a function call and add it to the queue\\n        if ( jsonObj.Children ) {\\n            for ( var i = 0, k = jsonObj.Children.length; i < k; i++ )\\n            {\\n                queue.push( createChildren( jsonObj.Children[ i ] ) );\\n            }\\n        }\\n        // Resolve first updateCallbacks and stateset.\\n        var deferred = Q.defer();\\n        Q.all( promiseArray ).then( function( ) {\\n            deferred.resolve( );\\n        } );\\n        \\n        var defer = Q.defer();\\n        // Need to wait until the stateset and the all the callbacks are resolved\\n        Q( deferred.promise ).then( function( ){\\n            Q.all( queue ).then( function( ) {\\n                // All the results from Q.all are on the argument as an array\\n                // Now insert children in the right order\\n                for ( var i = 0; i < queue.length; i++ )\\n                    node.addChild( queue[ i ] );\\n                defer.resolve( node );\\n            } );\\n        });\\n        return defer.promise;\\n    };\\n\\n    osgWrapper.StateSet = function ( input, stateSet ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( /*o*/) {\\n            return true;\\n        };\\n\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        osgWrapper.Object( input, stateSet );\\n\\n        if ( jsonObj.RenderingHint !== undefined ) {\\n            stateSet.setRenderingHint( jsonObj.RenderingHint );\\n        }\\n\\n        var createAttribute = function ( jsonAttribute ) {\\n            var promise = input.setJSON( jsonAttribute ).readObject();\\n            var df = Q.defer();\\n            promiseArray.push( df.promise );\\n            Q.when( promise ).then( function ( attribute ) {\\n                if ( attribute !== undefined ) {\\n                    stateSet.setAttributeAndMode( attribute );\\n                }\\n                df.resolve();\\n            } );\\n        };\\n\\n        var promiseArray = [];\\n\\n        if ( jsonObj.AttributeList !== undefined ) {\\n            for ( var i = 0, l = jsonObj.AttributeList.length; i < l; i++ ) {\\n                createAttribute( jsonObj.AttributeList[ i ] );\\n            }\\n        }\\n\\n        var createTextureAttribute = function ( unit, textureAttribute ) {\\n            var promise = input.setJSON( textureAttribute ).readObject();\\n            var df = Q.defer();\\n            promiseArray.push( df.promise );\\n            Q.when( promise ).then( function ( attribute ) {\\n                if ( attribute )\\n                    stateSet.setTextureAttributeAndMode( unit, attribute );\\n                df.resolve();\\n            } );\\n        };\\n\\n        if ( jsonObj.TextureAttributeList ) {\\n            var textures = jsonObj.TextureAttributeList;\\n            for ( var t = 0, lt = textures.length; t < lt; t++ ) {\\n                var textureAttributes = textures[ t ];\\n                for ( var a = 0, al = textureAttributes.length; a < al; a++ ) {\\n                    createTextureAttribute( t, textureAttributes[ a ] );\\n                }\\n            }\\n        }\\n\\n        var defer = Q.defer();\\n        Q.all( promiseArray ).then( function () {\\n            defer.resolve( stateSet );\\n        } );\\n\\n        return defer.promise;\\n    };\\n\\n    osgWrapper.Material = function ( input, material ) {\\n        var jsonObj = input.getJSON();\\n\\n        var check = function ( o ) {\\n            if ( o.Diffuse !== undefined &&\\n                o.Emission !== undefined &&\\n                o.Specular !== undefined &&\\n                o.Shininess !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        osgWrapper.Object( input, material );\\n\\n        material.setAmbient( jsonObj.Ambient );\\n        material.setDiffuse( jsonObj.Diffuse );\\n        material.setEmission( jsonObj.Emission );\\n        material.setSpecular( jsonObj.Specular );\\n        material.setShininess( jsonObj.Shininess );\\n        return material;\\n    };\\n\\n\\n    osgWrapper.BlendFunc = function ( input, blend ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.SourceRGB && o.SourceAlpha && o.DestinationRGB && o.DestinationAlpha ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        osgWrapper.Object( input, blend );\\n\\n        blend.setSourceRGB( jsonObj.SourceRGB );\\n        blend.setSourceAlpha( jsonObj.SourceAlpha );\\n        blend.setDestinationRGB( jsonObj.DestinationRGB );\\n        blend.setDestinationAlpha( jsonObj.DestinationAlpha );\\n        return blend;\\n    };\\n\\n    osgWrapper.CullFace = function ( input, attr ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.Mode !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        osgWrapper.Object( input, attr );\\n        attr.setMode( jsonObj.Mode );\\n        return attr;\\n    };\\n\\n    osgWrapper.BlendColor = function ( input, attr ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.ConstantColor !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        osgWrapper.Object( input, attr );\\n        attr.setConstantColor( jsonObj.ConstantColor );\\n        return attr;\\n    };\\n\\n    osgWrapper.Light = function ( input, light ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.LightNum !== undefined &&\\n                o.Ambient !== undefined &&\\n                o.Diffuse !== undefined &&\\n                o.Direction !== undefined &&\\n                o.Position !== undefined &&\\n                o.Specular !== undefined &&\\n                o.SpotCutoff !== undefined &&\\n                o.LinearAttenuation !== undefined &&\\n                o.ConstantAttenuation !== undefined &&\\n                o.QuadraticAttenuation !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        osgWrapper.Object( input, light );\\n        light.setAmbient( jsonObj.Ambient );\\n        light.setConstantAttenuation( jsonObj.ConstantAttenuation );\\n        light.setDiffuse( jsonObj.Diffuse );\\n        light.setDirection( jsonObj.Direction );\\n        light.setLightNumber( jsonObj.LightNum );\\n        light.setLinearAttenuation( jsonObj.LinearAttenuation );\\n        light.setPosition( jsonObj.Position );\\n        light.setQuadraticAttenuation( jsonObj.QuadraticAttenuation );\\n        light.setSpecular( jsonObj.Specular );\\n        light.setSpotCutoff( jsonObj.SpotCutoff );\\n        light.setSpotBlend( 0.01 );\\n        if ( jsonObj.SpotExponent !== undefined ) {\\n            light.setSpotBlend( jsonObj.SpotExponent / 128.0 );\\n        }\\n        return light;\\n    };\\n\\n    osgWrapper.Texture = function ( input, texture ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( /*o*/) {\\n            return true;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        osgWrapper.Object( input, texture );\\n\\n        if ( jsonObj.MinFilter !== undefined ) {\\n            texture.setMinFilter( jsonObj.MinFilter );\\n        }\\n        if ( jsonObj.MagFilter !== undefined ) {\\n            texture.setMagFilter( jsonObj.MagFilter );\\n        }\\n\\n        if ( jsonObj.WrapT !== undefined ) {\\n            texture.setWrapT( jsonObj.WrapT );\\n        }\\n        if ( jsonObj.WrapS !== undefined ) {\\n            texture.setWrapS( jsonObj.WrapS );\\n        }\\n\\n        // no file return dummy texture\\n        var file = jsonObj.File;\\n        if ( file === undefined ) {\\n            file = \\'no-image-provided\\';\\n        }\\n\\n        var defer = Q.defer();\\n        Q.when( input.readImageURL( file ) ).then(\\n            function ( img ) {\\n                texture.setImage( img );\\n                defer.resolve( texture );\\n            } );\\n        return defer.promise;\\n    };\\n\\n    osgWrapper.Projection = function ( input, node ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.Matrix !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        var promise = osgWrapper.Node( input, node );\\n\\n        if ( jsonObj.Matrix !== undefined ) {\\n            node.setMatrix( jsonObj.Matrix );\\n        }\\n        return promise;\\n    };\\n\\n    osgWrapper.MatrixTransform = function ( input, node ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.Matrix ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        var promise = osgWrapper.Node( input, node );\\n\\n        if ( jsonObj.Matrix !== undefined ) {\\n            node.setMatrix( jsonObj.Matrix );\\n        }\\n        return promise;\\n    };\\n\\n    osgWrapper.LightSource = function ( input, node ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.Light !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        var defer = Q.defer();\\n        var promise = osgWrapper.Node( input, node );\\n        Q.all( [ input.setJSON( jsonObj.Light ).readObject(), promise ] ).then( function ( args ) {\\n            var light = args[ 0 ];\\n            //var lightsource = args[ 1 ];\\n            node.setLight( light );\\n            defer.resolve( node );\\n        } );\\n        return defer.promise;\\n    };\\n\\n    osgWrapper.Geometry = function ( input, node ) {\\n        var jsonObj = input.getJSON();\\n        var check = function ( o ) {\\n            if ( o.PrimitiveSetList !== undefined && o.VertexAttributeList !== undefined ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        var arraysPromise = [];\\n        arraysPromise.push( osgWrapper.Node( input, node ) );\\n\\n        var createPrimitive = function ( jsonPrimitive ) {\\n            var defer = Q.defer();\\n            arraysPromise.push( defer.promise );\\n            var promise = input.setJSON( jsonPrimitive ).readPrimitiveSet();\\n            Q.when( promise ).then( function ( primitiveSet ) {\\n                if ( primitiveSet !== undefined ) {\\n                    node.getPrimitives().push( primitiveSet );\\n                }\\n                defer.resolve( primitiveSet );\\n            } );\\n        };\\n\\n        for ( var i = 0, l = jsonObj.PrimitiveSetList.length; i < l; i++ ) {\\n            var entry = jsonObj.PrimitiveSetList[ i ];\\n            createPrimitive( entry );\\n        }\\n\\n        var createVertexAttribute = function ( name, jsonAttribute ) {\\n            var defer = Q.defer();\\n            arraysPromise.push( defer.promise );\\n            var promise = input.setJSON( jsonAttribute ).readBufferArray();\\n            Q.when( promise ).then( function ( buffer ) {\\n                if ( buffer !== undefined ) {\\n                    node.getVertexAttributeList()[ name ] = buffer;\\n                }\\n                defer.resolve( buffer );\\n            } );\\n        };\\n        for ( var key in jsonObj.VertexAttributeList ) {\\n            if ( jsonObj.VertexAttributeList.hasOwnProperty( key ) ) {\\n                createVertexAttribute( key, jsonObj.VertexAttributeList[ key ] );\\n            }\\n        }\\n\\n        var defer = Q.defer();\\n        Q.all( arraysPromise ).then( function () {\\n            defer.resolve( node );\\n        } );\\n        return defer.promise;\\n    };\\n\\n    return osgWrapper;\\n} );\\n\\n//# sourceURL=/osgWrappers/serializers/osg.js\");\n\n",
    "eval(\"define( \\'osgWrappers/serializers/osgAnimation\\',[\\n    \\'Q\\',\\n    \\'osg/Notify\\',\\n    \\'osgWrappers/serializers/osg\\'\\n], function ( Q, Notify, osgWrapper ) {\\n\\n    var osgAnimationWrapper = {};\\n\\n    osgAnimationWrapper.Animation = function ( input, animation ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        //\\n        var check = function ( o ) {\\n            if ( o.Name && o.Channels && o.Channels.length > 0 ) {\\n                return true;\\n            }\\n            if ( !o.Name ) {\\n                Notify.log( \\'animation has field Name, error\\' );\\n                return false;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        if ( !osgWrapper.Object( input, animation ) ) {\\n            return undefined;\\n        }\\n\\n        var createPromiseCallback = function( animation ) {\\n            return function( chan ) {\\n                if ( chan ) {\\n                    animation.getChannels().push( chan );\\n                }\\n            };\\n        };\\n        // channels\\n        for ( var i = 0, l = jsonObj.Channels.length; i < l; i++ ) {\\n            Q.when( input.setJSON( jsonObj.Channels[ i ] ).readObject() ).then( createPromiseCallback( animation ) );\\n        }\\n        return animation;\\n    };\\n\\n    osgAnimationWrapper.Vec3LerpChannel = function ( input, channel ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        //\\n        var check = function ( o ) {\\n            if ( o.KeyFrames && o.TargetName && o.Name ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return undefined;\\n        }\\n\\n        // doit\\n        if ( !osgWrapper.Object( input, channel ) ) {\\n            return undefined;\\n        }\\n\\n        channel.setTargetName( jsonObj.TargetName );\\n\\n        // channels\\n        var keys = channel.getSampler().getKeyframes();\\n        for ( var i = 0, l = jsonObj.KeyFrames.length; i < l; i++ ) {\\n            var nodekey = jsonObj.KeyFrames[ i ];\\n            var mykey = nodekey.slice( 1 );\\n            mykey.t = nodekey[ 0 ];\\n            keys.push( mykey );\\n        }\\n        return channel;\\n    };\\n\\n    osgAnimationWrapper.QuatLerpChannel = function ( input, channel ) {\\n        return osgAnimationWrapper.Vec3LerpChannel( input, channel );\\n    };\\n\\n    osgAnimationWrapper.QuatSlerpChannel = function ( input, channel ) {\\n        return osgAnimationWrapper.Vec3LerpChannel( input, channel );\\n    };\\n\\n    osgAnimationWrapper.FloatLerpChannel = function ( input, channel ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        //\\n        var check = function ( o ) {\\n            if ( o.KeyFrames && o.TargetName && o.Name ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        // doit\\n        if ( !osgWrapper.Object( input, channel ) ) {\\n            return;\\n        }\\n\\n        channel.setTargetName( jsonObj.TargetName );\\n\\n        // channels\\n        var keys = channel.getSampler().getKeyframes();\\n        for ( var i = 0, l = jsonObj.KeyFrames.length; i < l; i++ ) {\\n            var nodekey = jsonObj.KeyFrames[ i ];\\n            var mykey = nodekey.slice( 1 );\\n            mykey.t = nodekey[ 0 ];\\n            keys.push( mykey );\\n        }\\n        return channel;\\n    };\\n\\n    osgAnimationWrapper.BasicAnimationManager = function ( input, manager ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        //\\n        var check = function ( o ) {\\n            if ( o.Animations ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        for ( var i = 0, l = jsonObj.Animations.length; i < l; i++ ) {\\n            var entry = jsonObj.Animations[ i ];\\n            var anim = input.setJSON( entry ).readObject();\\n            if ( anim ) {\\n                manager.registerAnimation( anim );\\n            }\\n        }\\n        return manager;\\n    };\\n\\n    osgAnimationWrapper.UpdateMatrixTransform = function ( input, umt ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        var check = function ( o ) {\\n            if ( o.Name && o.StackedTransforms ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        if ( osgWrapper.Object( input, umt ) === undefined ) {\\n            return;\\n        }\\n\\n        for ( var i = 0, l = jsonObj.StackedTransforms.length; i < l; i++ ) {\\n            var entry = jsonObj.StackedTransforms[ i ];\\n            var ste = input.setJSON( entry ).readObject();\\n            if ( ste ) {\\n                umt.getStackedTransforms().push( ste );\\n            }\\n        }\\n        return umt;\\n    };\\n\\n    osgAnimationWrapper.StackedTranslate = function ( input, st ) {\\n        var jsonObj = input.getJSON();\\n\\n        // check\\n        var check = function ( o ) {\\n            if ( o.Name ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        if ( !osgWrapper.Object( input, st ) ) {\\n            return;\\n        }\\n\\n        if ( jsonObj.Translate ) {\\n            st.setTranslate( jsonObj.Translate );\\n        }\\n        return st;\\n    };\\n\\n    osgAnimationWrapper.StackedQuaternion = function ( input, st ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        var check = function ( o ) {\\n            if ( o.Name ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        if ( !osgWrapper.Object( input, st ) ) {\\n            return;\\n        }\\n\\n        if ( jsonObj.Quaternion ) {\\n            st.setQuaternion( jsonObj.Quaternion );\\n        }\\n        return st;\\n    };\\n\\n    osgAnimationWrapper.StackedRotateAxis = function ( input, st ) {\\n        var jsonObj = input.getJSON();\\n        // check\\n        var check = function ( o ) {\\n            if ( o.Axis ) {\\n                return true;\\n            }\\n            return false;\\n        };\\n        if ( !check( jsonObj ) ) {\\n            return;\\n        }\\n\\n        if ( !osgWrapper.Object( input, st ) ) {\\n            return;\\n        }\\n\\n        if ( jsonObj.Angle ) {\\n            st.setAngle( jsonObj.Angle );\\n        }\\n\\n        st.setAxis( jsonObj.Axis );\\n\\n        return st;\\n    };\\n\\n    return osgAnimationWrapper;\\n} );\\n\\n//# sourceURL=/osgWrappers/serializers/osgAnimation.js\");\n\n",
    "eval(\"define( \\'osgDB/osgDB\\',[\\n    \\'osg/Utils\\',\\n    \\'osgDB/Input\\',\\n    \\'osgDB/ReaderParser\\',\\n    \\'osgWrappers/serializers/osg\\',\\n    \\'osgWrappers/serializers/osgAnimation\\'\\n], function ( MACROUTILS, Input, ReaderParser, osgWrappers, osgAnimationWrappers ) {\\n\\n\\n    var osgDB = {};\\n    osgDB.Input = Input;\\n    MACROUTILS.objectMix( osgDB, ReaderParser );\\n    osgDB.ObjectWrapper.serializers.osg = osgWrappers;\\n    osgDB.ObjectWrapper.serializers.osgAnimation = osgAnimationWrappers;\\n\\n    return osgDB;\\n} );\\n\\n//# sourceURL=/osgDB/osgDB.js\");\n\n",
    "eval(\"define( \\'Hammer\\',[],function ( ) {\\n    return window.Hammer;\\n} );\\n\\n//# sourceURL=/vendors/Hammer.js\");\n\n",
    "eval(\"define( \\'osgGA/Manipulator\\',[\\n    \\'osg/Matrix\\'\\n], function ( Matrix ) {\\n\\n    /**\\n     *  Manipulator\\n     *  @class\\n     */\\n    var Manipulator = function () {\\n        this._controllerList = {};\\n        this._inverseMatrix = new Array( 16 );\\n        Matrix.makeIdentity( this._inverseMatrix );\\n    };\\n\\n    /** @lends Manipulator.prototype */\\n    Manipulator.prototype = {\\n\\n        // eg: var currentTime = nv.getFrameStamp().getSimulationTime();\\n        update: function ( /*nv*/ ) {},\\n\\n        getInverseMatrix: function () {\\n            return this._inverseMatrix;\\n        },\\n\\n        getControllerList: function () {\\n            return this._controllerList;\\n        }\\n    };\\n\\n    return Manipulator;\\n} );\\n\\n//# sourceURL=/osgGA/Manipulator.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulatorLeapMotionController\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Vec3\\'\\n], function ( Notify, Vec3 ) {\\n\\n    var OrbitManipulatorLeapMotionController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    var ModeConfig = {\\n        \\'rotate\\': {\\n            dtx: -1.2 * 1.2,\\n            dty: -0.9 * 1.2,\\n            dtz: -0.1,\\n            delay: 0.05,\\n            method: \\'getRotateInterpolator\\'\\n        },\\n        \\'pan\\': {\\n            dtx: -1.2 * 1.2,\\n            dty: -0.9 * 1.2,\\n            delay: 0.05,\\n            method: \\'getPanInterpolator\\'\\n        },\\n        \\'zoom\\': {\\n            dtx: 0.0,\\n            dty: -0.5,\\n            delay: 0.05,\\n            method: \\'getZoomInterpolator\\'\\n        },\\n        \\'zoom-twohands\\': {\\n            dtx: -0.05,\\n            dty: 0.0,\\n            delay: 0.05,\\n            method: \\'getZoomInterpolator\\'\\n        }\\n    };\\n\\n    OrbitManipulatorLeapMotionController.prototype = {\\n        init: function () {\\n            this._virtualCursor = [ 0.0, 0.0 ];\\n            this._targetPosition = [ 0.0, 0.0 ];\\n            this._previousFrame = undefined;\\n            this._displacement = [ 0.0, 0.0 ];\\n            this._top = [ 0, 1, 0 ];\\n            this._motion = [ 0.0, 0.0 ];\\n            this._delay = 0.05;\\n            this._threshold = 0.08;\\n            this._directionDotThreshold = 0.5;\\n            this._mode = \\'rotate\\';\\n        },\\n\\n        update: function ( frame ) {\\n            if ( !this._previousFrame ) {\\n                this._previousFrame = frame;\\n            }\\n\\n            // no fingers ? return\\n            if ( frame.fingers.length === 0 ) {\\n                return;\\n            }\\n\\n            var deltaFrame = this._previousFrame.translation( frame );\\n\\n            this._previousFrame = frame;\\n\\n            if ( frame.hands.length === 0 ) {\\n                return;\\n            }\\n\\n            // filter noise\\n            if ( Math.abs( deltaFrame[ 0 ] ) < this._threshold &&\\n                Math.abs( deltaFrame[ 1 ] ) < this._threshold ) {\\n                return;\\n            }\\n\\n            var mode = this._mode;\\n            var dist = 0;\\n\\n            // scale is when there two hands with but with two hand with more than 1 fingers\\n            if ( frame.gestures.length > 0 ) {\\n                for ( var i = 0; i < frame.gestures.length; i++ ) {\\n                    var gesture = frame.gestures[ i ];\\n                    if ( gesture.type === \\'circle\\' ) {\\n                        this._manipulator.computeHomePosition();\\n                        return;\\n                    }\\n                }\\n            }\\n\\n            if ( frame.hands.length === 1 ) {\\n                if ( frame.hands[ 0 ].fingers.length >= 3 ) {\\n                    mode = \\'zoom\\';\\n                    dist = frame.hands[ 0 ].palmPosition[ 1 ] / 10.0;\\n                    dist = Math.max( dist - 4, 0.01 );\\n\\n                } else if ( frame.hands[ 0 ].fingers.length > 1 ) {\\n                    mode = \\'pan\\';\\n                } else {\\n                    // by default onw hand moving means rotation\\n                    mode = \\'rotate\\';\\n                }\\n            } else if ( frame.hands.length === 2 ) {\\n                var d0 = Math.abs( Vec3.dot( frame.hands[ 0 ].palmNormal, this._top ) ),\\n                    d1 = Math.abs( Vec3.dot( frame.hands[ 1 ].palmNormal, this._top ) );\\n\\n                // two hands : zoom\\n                if ( d0 < this._directionDotThreshold && d1 < this._directionDotThreshold ) {\\n                    mode = \\'zoom-twohands\\';\\n                } else {\\n                    // if hands flat do nothing\\n                    mode = undefined;\\n                    this._handsDistanceOld = undefined;\\n                }\\n            }\\n            var zoom = this._manipulator.getZoomInterpolator();\\n\\n            if ( mode === undefined ) {\\n                return;\\n            }\\n            // change mode reset counter and skip this frame\\n            if ( mode !== this._mode ) {\\n                Notify.info( \\'Switch to mode \\' + mode );\\n\\n                this._motion[ 0 ] = 0;\\n                this._motion[ 1 ] = 0;\\n                this._mode = mode;\\n\\n                if ( mode === \\'zoom\\' || mode === \\'zoom-twohands\\' ) {\\n                    if ( zoom.isReset() ) {\\n                        zoom._start = 1.0;\\n                        zoom.set( 0.0 );\\n                    }\\n                }\\n                return;\\n            }\\n\\n            var dtx, dty, dtz;\\n            dtx = ModeConfig[ mode ].dtx;\\n            dty = ModeConfig[ mode ].dty;\\n            dtz = ModeConfig[ mode ].dtz;\\n\\n            this._motion[ 0 ] += deltaFrame[ 0 ] * dtx;\\n            this._motion[ 1 ] += deltaFrame[ 1 ] * dty;\\n\\n            var delay = ModeConfig[ mode ].delay;\\n\\n            // we use the mode enum to get the good method\\n            var method = ModeConfig[ mode ].method;\\n            this._manipulator[ method ]().setDelay( delay );\\n\\n            if ( mode === \\'zoom\\' ) {\\n                Notify.log( dist );\\n                zoom.setTarget( dist );\\n            } else if ( mode === \\'zoom-twohands\\' ) { // two hands zoom\\n                // distance between two hands\\n                var handsDistance = Vec3.distance( frame.hands[ 0 ].palmPosition, frame.hands[ 1 ].palmPosition );\\n\\n                if ( this._handsDistanceOld !== undefined ) {\\n                    // compare distance with lastframe and zoom if they get nearer, unzoom if they separate\\n                    var vel = dtx * ( handsDistance - this._handsDistanceOld );\\n\\n                    dist = zoom._target;\\n                    dist[ 0 ] += vel;\\n                }\\n                this._handsDistanceOld = handsDistance;\\n            } else {\\n                if ( mode === \\'rotate\\' ) {\\n                    dist = zoom._target[ 0 ];\\n                    dist += deltaFrame[ 2 ] * dtz;\\n                    dist = Math.max( dist, 0.01 );\\n                    zoom.setTarget( dist );\\n                }\\n                this._manipulator[ method ]().addTarget( this._motion[ 0 ], this._motion[ 1 ] );\\n            }\\n\\n            this._motion[ 1 ] = this._motion[ 0 ] = 0;\\n        }\\n    };\\n    return OrbitManipulatorLeapMotionController;\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulatorLeapMotionController.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulatorEnums\\',[], function () {\\n\\n    return {\\n        ROTATE: 0,\\n        PAN: 1,\\n        ZOOM: 2\\n    };\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulatorEnums.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulatorMouseKeyboardController\\',[\\n    \\'osgGA/OrbitManipulatorEnums\\'\\n], function ( OrbitManipulatorEnums ) {\\n\\n    var OrbitManipulatorMouseKeyboardController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    OrbitManipulatorMouseKeyboardController.prototype = {\\n        init: function () {\\n            this.releaseButton();\\n            this._rotateKey = 65; // a\\n            this._zoomKey = 83; // s\\n            this._panKey = 68; // d\\n\\n            this._mode = undefined;\\n            this._delay = 0.15;\\n        },\\n        getMode: function () {\\n            return this._mode;\\n        },\\n        setMode: function ( mode ) {\\n            this._mode = mode;\\n        },\\n        setEventProxy: function ( proxy ) {\\n            this._eventProxy = proxy;\\n        },\\n        setManipulator: function ( manipulator ) {\\n            this._manipulator = manipulator;\\n        },\\n        mousemove: function ( ev ) {\\n            if ( this._buttonup === true ) {\\n                return;\\n            }\\n            var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\\n            var manipulator = this._manipulator;\\n            if ( isNaN( pos[ 0 ] ) === false && isNaN( pos[ 1 ] ) === false ) {\\n\\n                var mode = this.getMode();\\n                if ( mode === OrbitManipulatorEnums.ROTATE ) {\\n                    manipulator.getRotateInterpolator().setDelay( this._delay );\\n                    manipulator.getRotateInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\\n\\n                } else if ( mode === OrbitManipulatorEnums.PAN ) {\\n                    manipulator.getPanInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\\n\\n                } else if ( mode === OrbitManipulatorEnums.ZOOM ) {\\n                    var zoom = manipulator.getZoomInterpolator();\\n                    if ( zoom.isReset() ) {\\n                        zoom._start = pos[ 1 ];\\n                        zoom.set( 0.0 );\\n                    }\\n                    var dy = pos[ 1 ] - zoom._start;\\n                    zoom._start = pos[ 1 ];\\n                    var v = zoom.getTarget()[ 0 ];\\n                    zoom.setTarget( v - dy / 20.0 );\\n                }\\n            }\\n\\n            ev.preventDefault();\\n        },\\n        mousedown: function ( ev ) {\\n            var manipulator = this._manipulator;\\n            var mode = this.getMode();\\n            if ( mode === undefined ) {\\n                if ( ev.button === 0 ) {\\n                    if ( ev.shiftKey ) {\\n                        this.setMode( OrbitManipulatorEnums.PAN );\\n                    } else if ( ev.ctrlKey ) {\\n                        this.setMode( OrbitManipulatorEnums.ZOOM );\\n                    } else {\\n                        this.setMode( OrbitManipulatorEnums.ROTATE );\\n                    }\\n                } else {\\n                    this.setMode( OrbitManipulatorEnums.PAN );\\n                }\\n            }\\n\\n            this.pushButton();\\n\\n            var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\\n            mode = this.getMode();\\n            if ( mode === OrbitManipulatorEnums.ROTATE ) {\\n                manipulator.getRotateInterpolator().reset();\\n                manipulator.getRotateInterpolator().set( pos[ 0 ], pos[ 1 ] );\\n            } else if ( mode === OrbitManipulatorEnums.PAN ) {\\n                manipulator.getPanInterpolator().reset();\\n                manipulator.getPanInterpolator().set( pos[ 0 ], pos[ 1 ] );\\n            } else if ( mode === OrbitManipulatorEnums.ZOOM ) {\\n                manipulator.getZoomInterpolator()._start = pos[ 1 ];\\n                manipulator.getZoomInterpolator().set( 0.0 );\\n            }\\n            ev.preventDefault();\\n        },\\n        mouseup: function ( /*ev */ ) {\\n            this.releaseButton();\\n            this.setMode( undefined );\\n        },\\n        mouseout: function ( /*ev */ ) {\\n            this.releaseButton();\\n            this.setMode( undefined );\\n        },\\n        mousewheel: function ( ev, intDelta /*, deltaX, deltaY */) {\\n            var manipulator = this._manipulator;\\n            ev.preventDefault();\\n            var zoomTarget = manipulator.getZoomInterpolator().getTarget()[ 0 ] - intDelta;\\n            manipulator.getZoomInterpolator().setTarget( zoomTarget );\\n        },\\n\\n        pushButton: function () {\\n            this._buttonup = false;\\n        },\\n        releaseButton: function () {\\n            this._buttonup = true;\\n        },\\n\\n        keydown: function ( ev ) {\\n            if ( ev.keyCode === 32 ) {\\n                this._manipulator.computeHomePosition();\\n                ev.preventDefault();\\n            } else if ( ev.keyCode === this._panKey &&\\n                this.getMode() !== OrbitManipulatorEnums.PAN ) {\\n                this.setMode( OrbitManipulatorEnums.PAN );\\n                this._manipulator.getPanInterpolator().reset();\\n                this.pushButton();\\n                ev.preventDefault();\\n            } else if ( ev.keyCode === this._zoomKey &&\\n                this.getMode() !== OrbitManipulatorEnums.ZOOM ) {\\n                this.setMode( OrbitManipulatorEnums.ZOOM );\\n                this._manipulator.getZoomInterpolator().reset();\\n                this.pushButton();\\n                ev.preventDefault();\\n            } else if ( ev.keyCode === this._rotateKey &&\\n                this.getMode() !== OrbitManipulatorEnums.ROTATE ) {\\n                this.setMode( OrbitManipulatorEnums.ROTATE );\\n                this._manipulator.getRotateInterpolator().reset();\\n                this.pushButton();\\n                ev.preventDefault();\\n            }\\n\\n        },\\n\\n        keyup: function ( ev ) {\\n            if ( ev.keyCode === this._panKey ) {\\n                this.mouseup( ev );\\n            } else if ( ev.keyCode === this._rotateKey ) {\\n                this.mouseup( ev );\\n            } else if ( ev.keyCode === this._rotateKey ) {\\n                this.mouseup( ev );\\n            }\\n            this.setMode( undefined );\\n        }\\n\\n    };\\n    return OrbitManipulatorMouseKeyboardController;\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulatorMouseKeyboardController.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulatorHammerController\\',[\\n    \\'osg/Notify\\'\\n], function ( Notify ) {\\n\\n    var OrbitManipulatorHammerController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    OrbitManipulatorHammerController.prototype = {\\n        init: function () {\\n            this._panFactorX = 0.5;\\n            this._panFactorY = -this._panFactorX;\\n\\n            this._rotateFactorX = 0.6;\\n            this._rotateFactorY = -this._rotateFactorX;\\n            this._zoomFactor = 5.0;\\n\\n            this._pan = false;\\n            this._delay = 0.15;\\n        },\\n        setEventProxy: function ( proxy ) {\\n            if ( proxy === undefined || ( proxy !== undefined && proxy === this._eventProxy ) ) {\\n                return;\\n            }\\n            this._eventProxy = proxy;\\n            var self = this;\\n            var hammer = proxy;\\n\\n            var computeTouches = function ( gesture ) {\\n                if ( gesture.touches !== undefined )\\n                    return gesture.touches.length;\\n                return 1; // mouse\\n            };\\n\\n            var dragCB = function ( ev ) {\\n                return \\'touches \\' + computeTouches( ev ) + \\' distance \\' + ev.distance + \\' x \\' + ev.deltaX + \\' y \\' + ev.deltaY;\\n            };\\n\\n            hammer.on( \\'dragstart\\', function ( event ) {\\n                var manipulator = self._manipulator;\\n                if ( !manipulator || self._transformStarted ) {\\n                    return;\\n                }\\n                var gesture = event.gesture;\\n                if ( computeTouches( gesture ) === 2 ) {\\n                    self._pan = true;\\n                }\\n\\n                self._dragStarted = true;\\n                if ( self._pan ) {\\n                    manipulator.getPanInterpolator().reset();\\n                    manipulator.getPanInterpolator().set( gesture.center.pageX * self._panFactorX, gesture.center.pageY * self._panFactorY );\\n                } else {\\n                    manipulator.getRotateInterpolator().reset();\\n                    manipulator.getRotateInterpolator().set( gesture.center.pageX * self._rotateFactorX, gesture.center.pageY * self._rotateFactorY );\\n                }\\n                Notify.debug( \\'drag start, \\' + dragCB( gesture ) );\\n            } );\\n\\n            hammer.on( \\'drag\\', function ( event ) {\\n                var manipulator = self._manipulator;\\n                if ( !manipulator ) {\\n                    return;\\n                }\\n                if ( !self._dragStarted ) {\\n                    return;\\n                }\\n                if ( self._transformStarted ) {\\n                    self._dragStarted = false;\\n                    return;\\n                }\\n\\n                var gesture = event.gesture;\\n                if ( self._pan ) {\\n\\n                    // if a pan started and we release one finger,\\n                    // we dont take care of the those event\\n                    if ( computeTouches( gesture ) !== 2 )\\n                        return;\\n\\n                    manipulator.getPanInterpolator().setTarget( gesture.center.pageX * self._panFactorX, gesture.center.pageY * self._panFactorY );\\n                    Notify.debug( \\'pad, \\' + dragCB( gesture ) );\\n                } else {\\n                    manipulator.getRotateInterpolator().setDelay( self._delay );\\n                    manipulator.getRotateInterpolator().setTarget( gesture.center.pageX * self._rotateFactorX, gesture.center.pageY * self._rotateFactorY );\\n                    Notify.debug( \\'rotate, \\' + dragCB( gesture ) );\\n                }\\n            } );\\n            hammer.on( \\'dragend\\', function ( event ) {\\n                var manipulator = self._manipulator;\\n                if ( !manipulator || !self._dragStarted ) {\\n                    return;\\n                }\\n                self._dragStarted = false;\\n                var gesture = event.gesture;\\n                self._pan = false;\\n                Notify.debug( \\'drag end, \\' + dragCB( gesture ) );\\n            } );\\n\\n            var toucheScale;\\n            hammer.on( \\'transformstart\\', function ( event ) {\\n                var manipulator = self._manipulator;\\n                if ( !manipulator ) {\\n                    return;\\n                }\\n                self._transformStarted = true;\\n                var gesture = event.gesture;\\n\\n                toucheScale = gesture.scale;\\n                var scale = gesture.scale;\\n                manipulator.getZoomInterpolator().reset();\\n                manipulator.getZoomInterpolator().set( gesture.scale );\\n\\n                Notify.debug( \\'transform start \\' + gesture.scale + \\' \\' + scale );\\n                event.preventDefault();\\n                hammer.options.drag = false;\\n            } );\\n            hammer.on( \\'transformend\\', function ( event ) {\\n                self._transformStarted = false;\\n                Notify.debug( \\'transform end \\' + event.gesture.scale );\\n                hammer.options.drag = true;\\n\\n            } );\\n            hammer.on( \\'transform\\', function ( event ) {\\n                var manipulator = self._manipulator;\\n                if ( !manipulator || !self._transformStarted ) {\\n                    return;\\n                }\\n\\n                var gesture = event.gesture;\\n\\n                var scale = ( gesture.scale - toucheScale ) * self._zoomFactor;\\n                toucheScale = gesture.scale;\\n                var target = manipulator.getZoomInterpolator().getTarget()[ 0 ];\\n                manipulator.getZoomInterpolator().setTarget( target - scale );\\n                Notify.debug( \\'transform \\' + gesture.scale + \\' \\' + ( target - scale ) );\\n            } );\\n\\n        },\\n        setManipulator: function ( manipulator ) {\\n            this._manipulator = manipulator;\\n        }\\n    };\\n    return OrbitManipulatorHammerController;\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulatorHammerController.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulatorGamePadController\\',[], function () {\\n\\n    var OrbitManipulatorGamePadController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    OrbitManipulatorGamePadController.prototype = {\\n        init: function () {\\n            this._delay = 0.15;\\n            this._threshold = 0.08;\\n            this._mode = 0;\\n            this._padFactor = 10.0;\\n            this._zoomFactor = 0.5;\\n            this._rotateFactor = 5.0;\\n        },\\n\\n\\n        addPan: function ( pan, x, y ) {\\n            pan.setDelay( this._delay );\\n            pan.addTarget( x * this._padFactor, y * this._padFactor );\\n        },\\n\\n        addZoom: function ( zoom, z ) {\\n            zoom.setDelay( this._delay );\\n            zoom.addTarget( z * this._zoomFactor );\\n        },\\n\\n        addRotate: function ( rotate, x, y ) {\\n            rotate.setDelay( this._delay );\\n            //var rotateTarget = rotate.getTarget();\\n            rotate.addTarget( x * this._rotateFactor, y * this._rotateFactor );\\n        },\\n\\n        gamepadaxes: function ( axes ) {\\n\\n            // Block badly balanced controllers\\n            var AXIS_THRESHOLD = 0.005;\\n\\n            //var rotateTarget, panTarget;\\n            var rotate = this._manipulator.getRotateInterpolator();\\n            var zoom = this._manipulator.getZoomInterpolator();\\n            var pan = this._manipulator.getPanInterpolator();\\n            // Regular gamepads\\n            if ( axes.length === 4 ) {\\n\\n                if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {\\n                    this.addRotate( rotate, -axes[ 0 ], axes[ 1 ] );\\n                }\\n                if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD ) {\\n                    this.addZoom( zoom, -axes[ 3 ] );\\n                }\\n\\n                //SpaceNavigator & 6-axis controllers\\n            } else if ( axes.length >= 5 ) {\\n                //Notify.log(axes);\\n                if ( Math.abs( axes[ 0 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 1 ] ) > AXIS_THRESHOLD ) {\\n                    this.addPan( pan, -axes[ 0 ], axes[ 1 ] );\\n                }\\n\\n                if ( Math.abs( axes[ 2 ] ) > AXIS_THRESHOLD ) {\\n                    this.addZoom( zoom, -axes[ 2 ] );\\n                }\\n\\n                if ( Math.abs( axes[ 3 ] ) > AXIS_THRESHOLD || Math.abs( axes[ 4 ] ) > AXIS_THRESHOLD ) {\\n                    this.addRotate( rotate, axes[ 4 ], axes[ 3 ] );\\n                }\\n            }\\n\\n        },\\n\\n        gamepadbuttondown: function ( event /*, pressed */ ) {\\n            // Buttons 12 to 15 are the d-pad.\\n            if ( event.button >= 12 && event.button <= 15 ) {\\n                var pan = this._manipulator.getPanInterpolator();\\n                var panTarget = pan.getTarget();\\n                var delta = {\\n                    12: [ 0, -1 ],\\n                    13: [ 0, 1 ],\\n                    14: [ -1, 0 ],\\n                    15: [ 1, 0 ]\\n                }[ event.button ];\\n                pan.setDelay( this._delay );\\n                pan.setTarget( panTarget[ 0 ] - delta[ 0 ] * 10, panTarget[ 1 ] + delta[ 1 ] * 10 );\\n            }\\n        },\\n\\n        update: function ( gamepadProxyEvent ) {\\n            if ( !gamepadProxyEvent ) {\\n                return;\\n            }\\n\\n            var gm = gamepadProxyEvent.getGamePad();\\n            var axis = gm.axes;\\n            var buttons = gm.buttons;\\n\\n            this.gamepadaxes( axis );\\n\\n            // Dummy event wrapper\\n            var emptyFunc = function () {};\\n            for ( var i = 0; i < buttons.length; i++ ) {\\n                if ( buttons[ i ] ) {\\n                    this.gamepadbuttondown( {\\n                        preventDefault: emptyFunc,\\n                        gamepad: gm,\\n                        button: i\\n                    }, !! buttons[ i ] );\\n                }\\n            }\\n        }\\n    };\\n    return OrbitManipulatorGamePadController;\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulatorGamePadController.js\");\n\n",
    "eval(\"define( \\'osgGA/OrbitManipulator\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Vec3\\',\\n    \\'osg/Matrix\\',\\n    \\'osgGA/Manipulator\\',\\n    \\'osgGA/OrbitManipulatorLeapMotionController\\',\\n    \\'osgGA/OrbitManipulatorMouseKeyboardController\\',\\n    \\'osgGA/OrbitManipulatorHammerController\\',\\n    \\'osgGA/OrbitManipulatorGamePadController\\'\\n], function ( MACROUTILS, Vec3, Matrix, Manipulator, OrbitManipulatorLeapMotionController, OrbitManipulatorMouseKeyboardController, OrbitManipulatorHammerController, OrbitManipulatorGamePadController ) {\\n\\n    /**\\n     *  OrbitManipulator\\n     *  @class\\n     */\\n    var OrbitManipulator = function () {\\n        Manipulator.call( this );\\n        this._homePosition = [ 0.0, 0.0, 0.0 ];\\n        this.init();\\n    };\\n\\n    OrbitManipulator.Interpolator = function ( size, delay ) {\\n        this._current = new Array( size );\\n        this._target = new Array( size );\\n        this._delta = new Array( size );\\n        this._delay = ( delay !== undefined ) ? delay : 0.15;\\n        this._reset = false;\\n        this.reset();\\n    };\\n    OrbitManipulator.Interpolator.prototype = {\\n        setDelay: function ( delay ) {\\n            this._delay = delay;\\n        },\\n        reset: function () {\\n            for ( var i = 0, l = this._current.length; i < l; i++ ) {\\n                this._current[ i ] = this._target[ i ] = 0;\\n            }\\n            this._reset = true;\\n        },\\n        update: function () {\\n            for ( var i = 0, l = this._current.length; i < l; i++ ) {\\n                var d = ( this._target[ i ] - this._current[ i ] ) * this._delay;\\n                this._delta[ i ] = d;\\n                this._current[ i ] += d;\\n            }\\n            return this._delta;\\n        },\\n        set: function () {\\n            for ( var i = 0, l = this._current.length; i < l; i++ ) {\\n                this._current[ i ] = this._target[ i ] = arguments[ i ];\\n            }\\n            this._reset = false;\\n        },\\n        isReset: function () {\\n            return this._reset;\\n        },\\n        getCurrent: function () {\\n            return this._current;\\n        },\\n        setTarget: function () {\\n            for ( var i = 0, l = this._target.length; i < l; i++ ) {\\n                if ( this._reset ) {\\n                    this._target[ i ] = this._current[ i ] = arguments[ i ];\\n                } else {\\n                    this._target[ i ] = arguments[ i ];\\n                }\\n            }\\n            this._reset = false;\\n        },\\n        addTarget: function () {\\n            for ( var i = 0; i < arguments.length; i++ ) {\\n                this._target[ i ] += arguments[ i ];\\n            }\\n        },\\n        getTarget: function () {\\n            return this._target;\\n        },\\n        getDelta: function () {\\n            return this._delta;\\n        }\\n    };\\n\\n    OrbitManipulator.AvailableControllerList = [ \\'StandardMouseKeyboard\\',\\n        \\'LeapMotion\\',\\n        \\'GamePad\\',\\n        \\'Hammer\\'\\n    ];\\n\\n    OrbitManipulator.ControllerList = [ \\'StandardMouseKeyboard\\',\\n        \\'LeapMotion\\',\\n        \\'GamePad\\',\\n        \\'Hammer\\'\\n    ];\\n\\n    /** @lends OrbitManipulator.prototype */\\n    OrbitManipulator.prototype = MACROUTILS.objectInehrit( Manipulator.prototype, {\\n        init: function () {\\n            this._distance = 25.0;\\n            this._target = [ 0.0, 0.0, 0.0 ];\\n            this._upz = [ 0.0, 0.0, 1.0 ];\\n            Vec3.init( this._target );\\n\\n            var rot1 = Matrix.makeRotate( Math.PI, 0.0, 0.0, 1.0, Matrix.create() );\\n            var rot2 = Matrix.makeRotate( -Math.PI / 10.0, 1.0, 0.0, 0.0, Matrix.create() );\\n            this._rotation = Matrix.create();\\n            Matrix.mult( rot1, rot2, this._rotation );\\n            this._time = 0.0;\\n\\n            this._rotate = new OrbitManipulator.Interpolator( 2 );\\n            this._pan = new OrbitManipulator.Interpolator( 2 );\\n            this._zoom = new OrbitManipulator.Interpolator( 1 );\\n            this._zoom.reset = function () {\\n                OrbitManipulator.Interpolator.prototype.reset.call( this );\\n                this._start = 0.0;\\n            };\\n\\n            this._buttonup = true;\\n\\n            this._scale = 10.0;\\n            this._maxDistance = 0.0;\\n            this._minDistance = 0.0;\\n            this._scaleMouseMotion = 1.0;\\n\\n            this._inverseMatrix = Matrix.create();\\n            this._rotateKey = 65; // a\\n            this._zoomKey = 83; // s\\n            this._panKey = 68; // d\\n\\n            // instance of controller\\n            var self = this;\\n\\n            OrbitManipulator.ControllerList.forEach( function ( value ) {\\n                if ( OrbitManipulator[ value ] !== undefined ) {\\n                    self._controllerList[ value ] = new OrbitManipulator[ value ]( self );\\n                }\\n            } );\\n        },\\n        reset: function () {\\n            this.init();\\n        },\\n        setNode: function ( node ) {\\n            this._node = node;\\n        },\\n        setTarget: function ( target ) {\\n            Vec3.copy( target, this._target );\\n            var eyePos = [ 0.0, 0.0, 0.0 ];\\n            this.getEyePosition( eyePos );\\n            this._distance = Vec3.distance( eyePos, target );\\n        },\\n        setEyePosition: ( function () {\\n            var f = [ 0.0, 0.0, 0.0 ];\\n            var s = [ 0.0, 0.0, 0.0 ];\\n            var u = [ 0.0, 0.0, 0.0 ];\\n            return function ( eye ) {\\n                var result = this._rotation;\\n                var center = this._target;\\n\\n                Vec3.sub( eye, center, f );\\n                Vec3.normalize( f, f );\\n\\n                Vec3.cross( f, this._upz, s );\\n                Vec3.normalize( s, s );\\n\\n                Vec3.cross( s, f, u );\\n                Vec3.normalize( u, u );\\n\\n                // s[0], f[0], u[0], 0.0,\\n                // s[1], f[1], u[1], 0.0,\\n                // s[2], f[2], u[2], 0.0,\\n                // 0,    0,    0,     1.0\\n                result[ 0 ] = s[ 0 ];\\n                result[ 1 ] = f[ 0 ];\\n                result[ 2 ] = u[ 0 ];\\n                result[ 3 ] = 0.0;\\n                result[ 4 ] = s[ 1 ];\\n                result[ 5 ] = f[ 1 ];\\n                result[ 6 ] = u[ 1 ];\\n                result[ 7 ] = 0.0;\\n                result[ 8 ] = s[ 2 ];\\n                result[ 9 ] = f[ 2 ];\\n                result[ 10 ] = u[ 2 ];\\n                result[ 11 ] = 0.0;\\n                result[ 12 ] = 0;\\n                result[ 13 ] = 0;\\n                result[ 14 ] = 0;\\n                result[ 15 ] = 1.0;\\n\\n                this._distance = Vec3.distance( eye, center );\\n            };\\n        } )(),\\n        computeHomePosition: function () {\\n            if ( this._node !== undefined ) {\\n                //this.reset();\\n                var bs = this._node.getBound();\\n                this.setDistance( bs.radius() * 1.5 );\\n                this.setTarget( bs.center() );\\n            }\\n        },\\n\\n        getHomePosition: function () {\\n            if ( this._node !== undefined ) {\\n                var bs = this._node.getBound();\\n                var distance = bs.radius() * 1.5;\\n\\n                var target = bs.center();\\n\\n                this.computeEyePosition( target, distance, this._homePosition );\\n            }\\n            return this._homePosition;\\n        },\\n\\n        setMaxDistance: function ( d ) {\\n            this._maxDistance = d;\\n        },\\n        setMinDistance: function ( d ) {\\n            this._minDistance = d;\\n        },\\n        setDistance: function ( d ) {\\n            this._distance = d;\\n        },\\n        getDistance: function () {\\n            return this._distance;\\n        },\\n        computePan: ( function () {\\n            var inv = Matrix.create();\\n            var x = [ 0.0, 0.0, 0.0 ];\\n            var y = [ 0.0, 0.0, 0.0 ];\\n            return function ( dx, dy ) {\\n                dy *= this._distance;\\n                dx *= this._distance;\\n                Matrix.inverse( this._rotation, inv );\\n                x[ 0 ] = Matrix.get( inv, 0, 0 );\\n                x[ 1 ] = Matrix.get( inv, 0, 1 );\\n                x[ 2 ] = Matrix.get( inv, 0, 2 );\\n                Vec3.normalize( x, x );\\n\\n                y[ 0 ] = Matrix.get( inv, 2, 0 );\\n                y[ 1 ] = Matrix.get( inv, 2, 1 );\\n                y[ 2 ] = Matrix.get( inv, 2, 2 );\\n                Vec3.normalize( y, y );\\n\\n                Vec3.mult( x, -dx, x );\\n                Vec3.mult( y, dy, y );\\n                Vec3.add( this._target, x, this._target );\\n                Vec3.add( this._target, y, this._target );\\n            };\\n        } )(),\\n        computeRotation: ( function () {\\n            var of = Matrix.create();\\n            var r = Matrix.create();\\n            var r2 = Matrix.create();\\n            var inv = Matrix.create();\\n            var tmp = [ 0.0, 0.0, 0.0 ];\\n            var tmpDist = [ 0.0, 0.0, 0.0 ];\\n            return function ( dx, dy ) {\\n                Matrix.makeRotate( dx / 10.0, 0.0, 0.0, 1.0, of );\\n                Matrix.mult( this._rotation, of, r );\\n\\n                Matrix.makeRotate( dy / 10.0, 1.0, 0.0, 0.0, of );\\n                Matrix.mult( of, r, r2 );\\n\\n                // test that the eye is not too up and not too down to not kill\\n                // the rotation matrix\\n                Matrix.inverse( r2, inv );\\n                tmpDist[ 1 ] = this._distance;\\n                Matrix.transformVec3( inv, tmpDist, tmp );\\n\\n                Vec3.neg( tmp, tmp );\\n                Vec3.normalize( tmp, tmp );\\n\\n                var p = Vec3.dot( tmp, this._upz );\\n                if ( Math.abs( p ) > 0.95 ) {\\n                    //discard rotation on y\\n                    Matrix.copy( r, this._rotation );\\n                    return;\\n                }\\n                Matrix.copy( r2, this._rotation );\\n            };\\n        } )(),\\n        computeZoom: function ( dz ) {\\n            this.zoom( dz );\\n        },\\n\\n        zoom: function ( ratio ) {\\n            var newValue = this._distance * ratio;\\n            if ( this._minDistance > 0.0 ) {\\n                if ( newValue < this._minDistance ) {\\n                    newValue = this._minDistance;\\n                }\\n            }\\n            if ( this._maxDistance > 0.0 ) {\\n                if ( newValue > this._maxDistance ) {\\n                    newValue = this._maxDistance;\\n                }\\n            }\\n            this._distance = newValue;\\n        },\\n\\n        getRotateInterpolator: function () {\\n            return this._rotate;\\n        },\\n        getPanInterpolator: function () {\\n            return this._pan;\\n        },\\n        getZoomInterpolator: function () {\\n            return this._zoom;\\n        },\\n        getTarget: function ( target ) {\\n            Vec3.copy( this._target, target );\\n            return target;\\n        },\\n        getEyePosition: function ( eye ) {\\n            this.computeEyePosition( this._target, this._distance, eye );\\n        },\\n\\n        computeEyePosition: ( function () {\\n            var tmpDist = [ 0.0, 0.0, 0.0 ];\\n            var tmpInverse = Matrix.create();\\n            return function ( target, distance, eye ) {\\n                Matrix.inverse( this._rotation, tmpInverse );\\n                tmpDist[ 1 ] = distance;\\n                Matrix.transformVec3( tmpInverse, tmpDist, eye );\\n                Vec3.add( target, eye, eye );\\n            };\\n        } )(),\\n\\n        update: ( function () {\\n            var eye = [ 0.0, 0.0, 0.0 ];\\n            var tmpDist = [ 0.0, 0.0, 0.0 ];\\n            return function ( nv ) {\\n                var t = nv.getFrameStamp().getSimulationTime();\\n                if ( this._lastUpdate === undefined ) {\\n                    this._lastUpdate = t;\\n                }\\n                //var dt = t - this._lastUpdate;\\n                this._lastUpdate = t;\\n\\n                var delta;\\n                var mouseFactor = 0.1;\\n                delta = this._rotate.update();\\n                this.computeRotation( -delta[ 0 ] * mouseFactor * this._scaleMouseMotion, -delta[ 1 ] * mouseFactor * this._scaleMouseMotion );\\n\\n\\n                var panFactor = 0.002;\\n                delta = this._pan.update();\\n                this.computePan( -delta[ 0 ] * panFactor, -delta[ 1 ] * panFactor );\\n\\n\\n                delta = this._zoom.update();\\n                this.computeZoom( 1.0 + delta[ 0 ] / 10.0 );\\n\\n                var target = this._target;\\n                var distance = this._distance;\\n\\n                Matrix.inverse( this._rotation, this._inverseMatrix );\\n                tmpDist[ 1 ] = distance;\\n                Matrix.transformVec3( this._inverseMatrix, tmpDist, eye );\\n\\n                Matrix.makeLookAt( Vec3.add( target, eye, eye ), target, this._upz, this._inverseMatrix );\\n            };\\n        } )(),\\n\\n        getInverseMatrix: function () {\\n            return this._inverseMatrix;\\n        }\\n    } );\\n\\n    ( function ( module ) {\\n        module.LeapMotion = OrbitManipulatorLeapMotionController;\\n    } )( OrbitManipulator );\\n\\n\\n    ( function ( module ) {\\n        module.StandardMouseKeyboard = OrbitManipulatorMouseKeyboardController;\\n    } )( OrbitManipulator );\\n\\n\\n    ( function ( module ) {\\n        module.Hammer = OrbitManipulatorHammerController;\\n    } )( OrbitManipulator );\\n\\n    ( function ( module ) {\\n        module.GamePad = OrbitManipulatorGamePadController;\\n    } )( OrbitManipulator );\\n\\n    return OrbitManipulator;\\n} );\\n\\n//# sourceURL=/osgGA/OrbitManipulator.js\");\n\n",
    "eval(\"define( \\'osgGA/FirstPersonManipulatorMouseKeyboardController\\',[], function () {\\n\\n    var FirstPersonManipulatorMouseKeyboardController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    FirstPersonManipulatorMouseKeyboardController.prototype = {\\n        init: function () {\\n            this.releaseButton();\\n            this._delay = 0.15;\\n            this._stepFactor = 1.0; // meaning radius*stepFactor to move\\n        },\\n        setEventProxy: function ( proxy ) {\\n            this._eventProxy = proxy;\\n        },\\n        setManipulator: function ( manipulator ) {\\n            this._manipulator = manipulator;\\n\\n            // we always want to sync speed of controller with manipulator\\n            this._manipulator.setStepFactor( this._stepFactor );\\n        },\\n\\n        pushButton: function () {\\n            this._buttonup = false;\\n        },\\n        releaseButton: function () {\\n            this._buttonup = true;\\n        },\\n\\n        mousedown: function ( ev ) {\\n            var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\\n            var manipulator = this._manipulator;\\n            manipulator.getLookPositionInterpolator().set( pos[ 0 ], pos[ 1 ] );\\n            this.pushButton();\\n        },\\n        mouseup: function ( /*ev */ ) {\\n            this.releaseButton();\\n        },\\n        mouseout: function ( /*ev */ ) {\\n            this.releaseButton();\\n        },\\n        mousemove: function ( ev ) {\\n            if ( this._buttonup === true ) {\\n                return;\\n            }\\n\\n            var pos = this._eventProxy.getPositionRelativeToCanvas( ev );\\n            this._manipulator.getLookPositionInterpolator().setDelay( this._delay );\\n            this._manipulator.getLookPositionInterpolator().setTarget( pos[ 0 ], pos[ 1 ] );\\n        },\\n        mousewheel: function ( ev, intDelta /*, deltaX, deltaY */ ) {\\n            ev.preventDefault();\\n            this._stepFactor = Math.min( Math.max( 0.001, this._stepFactor + intDelta * 0.01 ), 4.0 );\\n            this._manipulator.setStepFactor( this._stepFactor );\\n        },\\n\\n        keydown: function ( event ) {\\n            var manipulator = this._manipulator;\\n            if ( event.keyCode === 32 ) {\\n                manipulator.computeHomePosition();\\n                event.preventDefault();\\n            } else if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 ) { // w/z/up\\n                manipulator.getFowardInterpolator().setDelay( this._delay );\\n                manipulator.getFowardInterpolator().setTarget( 1 );\\n                event.preventDefault();\\n                return false;\\n            } else if ( event.keyCode === 83 || event.keyCode === 40 ) { // S/down\\n                manipulator.getFowardInterpolator().setDelay( this._delay );\\n                manipulator.getFowardInterpolator().setTarget( -1 );\\n                event.preventDefault();\\n                return false;\\n            } else if ( event.keyCode === 68 || event.keyCode === 39 ) { // D/right\\n                manipulator.getSideInterpolator().setDelay( this._delay );\\n                manipulator.getSideInterpolator().setTarget( 1 );\\n                event.preventDefault();\\n                return false;\\n            } else if ( event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left\\n                manipulator.getSideInterpolator().setDelay( this._delay );\\n                manipulator.getSideInterpolator().setTarget( -1 );\\n                event.preventDefault();\\n                return false;\\n            }\\n            return undefined;\\n        },\\n\\n        keyup: function ( event ) {\\n            var manipulator = this._manipulator;\\n            if ( event.keyCode === 87 || event.keyCode === 90 || event.keyCode === 38 || // w/z/up\\n                event.keyCode === 83 || event.keyCode === 40 ) { // S/down\\n                manipulator.getFowardInterpolator().setDelay( this._delay );\\n                manipulator.getFowardInterpolator().setTarget( 0 );\\n                return false;\\n            } else if ( event.keyCode === 68 || event.keyCode === 39 || // D/right\\n                event.keyCode === 65 || event.keyCode === 81 || event.keyCode === 37 ) { // a/q/left\\n                manipulator.getSideInterpolator().setDelay( this._delay );\\n                manipulator.getSideInterpolator().setTarget( 0 );\\n                return false;\\n            }\\n            return undefined;\\n        }\\n\\n    };\\n\\n    return FirstPersonManipulatorMouseKeyboardController;\\n} );\\n\\n//# sourceURL=/osgGA/FirstPersonManipulatorMouseKeyboardController.js\");\n\n",
    "eval(\"define( \\'osgGA/FirstPersonManipulatorOculusController\\',[], function () {\\n\\n    var FirstPersonManipulatorOculusController = function ( manipulator ) {\\n        this._manipulator = manipulator;\\n        this.init();\\n    };\\n\\n    FirstPersonManipulatorOculusController.prototype = {\\n        init: function () {\\n            this._stepFactor = 1.0; // meaning radius*stepFactor to move\\n        },\\n        update: function ( quaternion ) {\\n\\n            this._manipulator.setRotationBaseFromQuat( quaternion );\\n        },\\n\\n    };\\n\\n    return FirstPersonManipulatorOculusController;\\n} );\\n//# sourceURL=/osgGA/FirstPersonManipulatorOculusController.js\");\n\n",
    "eval(\"define( \\'osgGA/FirstPersonManipulator\\',[\\n    \\'osg/Utils\\',\\n    \\'osgGA/Manipulator\\',\\n    \\'osgGA/OrbitManipulator\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec2\\',\\n    \\'osg/Vec3\\',\\n    \\'osgGA/FirstPersonManipulatorMouseKeyboardController\\',\\n    \\'osgGA/FirstPersonManipulatorOculusController\\'\\n], function ( MACROUTILS, Manipulator, OrbitManipulator, Matrix, Vec2, Vec3, FirstPersonManipulatorMouseKeyboardController, FirstPersonManipulatorOculusController ) {\\n\\n    /**\\n     * Authors:\\n     *  Matt Fontaine <tehqin@gmail.com>\\n     *  Cedric Pinson <trigrou@gmail.com>\\n     */\\n\\n    /**\\n     *  FirstPersonManipulator\\n     *  @class\\n     */\\n    var FirstPersonManipulator = function () {\\n        Manipulator.call( this );\\n        this.init();\\n    };\\n\\n    FirstPersonManipulator.AvailableControllerList = [ \\'StandardMouseKeyboard\\', \\'Oculus\\'];\\n    FirstPersonManipulator.ControllerList = [ \\'StandardMouseKeyboard\\', \\'Oculus\\' ];\\n\\n    /** @lends FirstPersonManipulator.prototype */\\n    FirstPersonManipulator.prototype = MACROUTILS.objectInehrit( Manipulator.prototype, {\\n        setNode: function ( node ) {\\n            this._node = node;\\n            this.computeHomePosition();\\n        },\\n        computeHomePosition: function () {\\n            if ( this._node !== undefined ) {\\n                var bs = this._node.getBound();\\n                this._radius = bs.radius();\\n                var eye = this._eye;\\n                eye[ 0 ] = 0.0;\\n                eye[ 1 ] = -bs.radius();\\n                eye[ 2 ] = 0.0;\\n            }\\n        },\\n        init: function () {\\n            this._direction = [ 0.0, 1.0, 0.0 ];\\n            this._eye = [ 0.0, 25.0, 10.0 ];\\n            this._up = [ 0.0, 0.0, 1.0 ];\\n            this._radius = 1.0;\\n            this._forward = new OrbitManipulator.Interpolator( 1 );\\n            this._side = new OrbitManipulator.Interpolator( 1 );\\n            this._lookPosition = new OrbitManipulator.Interpolator( 2 );\\n            this._stepFactor = 1.0; // meaning radius*stepFactor to move\\n            this._target = [ 0.0, 0.0, 0.0 ];\\n            this._angleVertical = 0.0;\\n            this._angleHorizontal = 0.0;\\n\\n            // tmp value use for computation\\n            this._tmpComputeRotation1 = Matrix.create();\\n            this._tmpComputeRotation2 = Matrix.create();\\n            this._tmpComputeRotation3 = Matrix.create();\\n            this._tmpGetTargetDir = [ 0.0, 0.0, 0.0 ];\\n\\n            this._rotBase = Matrix.create();\\n\\n            var self = this;\\n\\n            this._controllerList = {};\\n            FirstPersonManipulator.ControllerList.forEach( function ( value ) {\\n                if ( FirstPersonManipulator[ value ] !== undefined ) {\\n                    self._controllerList[ value ] = new FirstPersonManipulator[ value ]( self );\\n                }\\n            } );\\n\\n        },\\n\\n        getEyePosition: function ( eye ) {\\n            eye[ 0 ] = this._eye[ 0 ];\\n            eye[ 1 ] = this._eye[ 1 ];\\n            eye[ 2 ] = this._eye[ 2 ];\\n            return eye;\\n        },\\n\\n        setEyePosition: function ( eye ) {\\n            this._eye[ 0 ] = eye[ 0 ];\\n            this._eye[ 1 ] = eye[ 1 ];\\n            this._eye[ 2 ] = eye[ 2 ];\\n            return this;\\n        },\\n\\n        getTarget: function ( pos, distance ) {\\n            if ( distance === undefined ) {\\n                distance = 25.0;\\n            }\\n            var dir = Vec3.mult( this._direction, distance, this._tmpGetTargetDir );\\n            Vec3.add( this._eye, dir, pos );\\n        },\\n\\n        setTarget: function ( pos ) {\\n            this._target[ 0 ] = pos[ 0 ];\\n            this._target[ 1 ] = pos[ 1 ];\\n            this._target[ 2 ] = pos[ 2 ];\\n            var dir = this._tmpGetTargetDir;\\n            Vec3.sub( pos, this._eye, dir );\\n            dir[ 2 ] = 0.0;\\n            Vec3.normalize( dir, dir );\\n            this._angleHorizontal = Math.acos( dir[ 1 ] );\\n            if ( dir[ 0 ] < 0.0 ) {\\n                this._angleHorizontal = -this._angleHorizontal;\\n            }\\n            Vec3.sub( pos, this._eye, dir );\\n            Vec3.normalize( dir, dir );\\n\\n            this._angleVertical = -Math.asin( dir[ 2 ] );\\n            Vec3.copy( dir, this._direction );\\n        },\\n\\n        getLookPositionInterpolator: function () {\\n            return this._lookPosition;\\n        },\\n        getSideInterpolator: function () {\\n            return this._side;\\n        },\\n        getFowardInterpolator: function () {\\n            return this._forward;\\n        },\\n\\n        computeRotation: ( function () {\\n            var upy = [ 0.0, 1.0, 0.0 ];\\n            var upz = [ 0.0, 0.0, 1.0 ];\\n            return function ( dx, dy ) {\\n                this._angleVertical += dy * 0.01;\\n                this._angleHorizontal -= dx * 0.01;\\n\\n                var first = this._tmpComputeRotation1;\\n                var second = this._tmpComputeRotation2;\\n                var rotMat = this._tmpComputeRotation3;\\n                Matrix.makeRotate( this._angleVertical, 1.0, 0.0, 0.0, first );\\n                Matrix.makeRotate( this._angleHorizontal, 0.0, 0.0, 1.0, second );\\n                Matrix.mult( second, first, rotMat );\\n\\n                var rotBase = this._rotBase;\\n                // TOTO refactor the way the rotation matrix is managed\\n                Matrix.preMult( rotMat, rotBase );\\n\\n                this._direction = Matrix.transformVec3( rotMat, upy, this._direction );\\n                Vec3.normalize( this._direction, this._direction );\\n\\n                Matrix.transformVec3( rotMat, upz, this._up );\\n            };\\n        } )(),\\n        reset: function () {\\n            this.init();\\n        },\\n\\n        setStepFactor: function ( t ) {\\n            this._stepFactor = t;\\n        },\\n\\n        update: ( function () {\\n            var vec = [ 0.0, 0.0 ];\\n            return function ( nv ) {\\n                var t = nv.getFrameStamp().getSimulationTime();\\n                if ( this._lastUpdate === undefined ) {\\n                    this._lastUpdate = t;\\n                }\\n                var dt = t - this._lastUpdate;\\n                this._lastUpdate = t;\\n\\n                this._forward.update();\\n                this._side.update();\\n                var delta = this._lookPosition.update();\\n\\n                this.computeRotation( -delta[ 0 ] * 0.5, -delta[ 1 ] * 0.5 );\\n\\n                vec[ 0 ] = this._forward.getCurrent()[ 0 ];\\n                vec[ 1 ] = this._side.getCurrent()[ 0 ];\\n                if ( Vec2.length( vec ) > 1.0 ) {\\n                    Vec2.normalize( vec, vec );\\n                }\\n                var factor = this._radius;\\n                if ( this._radius < 1e-3 ) {\\n                    factor = 1.0;\\n                }\\n                this.moveForward( vec[ 0 ] * factor * this._stepFactor * dt );\\n                this.strafe( vec[ 1 ] * factor * this._stepFactor * dt );\\n\\n                Vec3.add( this._eye, this._direction, this._target );\\n\\n                Matrix.makeLookAt( this._eye, this._target, this._up, this._inverseMatrix );\\n            };\\n        } )(),\\n        setRotationBaseFromQuat: function ( quat ) {\\n            Matrix.makeRotateFromQuat( quat, this._rotBase );\\n        },\\n\\n        getInverseMatrix: function () {\\n            return this._inverseMatrix;\\n        },\\n\\n        moveForward: ( function () {\\n            var tmp = [ 0.0, 0.0, 0.0 ];\\n            return function ( distance ) {\\n                Vec3.normalize( this._direction, tmp );\\n                Vec3.mult( tmp, distance, tmp );\\n                Vec3.add( this._eye, tmp, this._eye );\\n            };\\n        } )(),\\n\\n        strafe: ( function () {\\n            var tmp = [ 0.0, 0.0, 0.0 ];\\n            return function ( distance ) {\\n                Vec3.cross( this._direction, this._up, tmp );\\n                Vec3.normalize( tmp, tmp );\\n                Vec3.mult( tmp, distance, tmp );\\n                Vec3.add( this._eye, tmp, this._eye );\\n            };\\n        } )()\\n    } );\\n\\n    ( function ( module ) {\\n        module.StandardMouseKeyboard = FirstPersonManipulatorMouseKeyboardController;\\n    } )( FirstPersonManipulator );\\n\\n    ( function ( module ) {\\n        module.Oculus = FirstPersonManipulatorOculusController;\\n    } )( FirstPersonManipulator );\\n\\n    return FirstPersonManipulator;\\n} );\\n\\n//# sourceURL=/osgGA/FirstPersonManipulator.js\");\n\n",
    "eval(\"define( \\'osgGA/SwitchManipulator\\',[\\n    \\'osg/Notify\\'\\n], function ( Notify ) {\\n\\n    /**\\n     *  OrbitManipulator\\n     *  @class\\n     */\\n    var SwitchManipulator = function () {\\n        this._manipulatorList = [];\\n        this._currentManipulator = undefined;\\n    };\\n\\n    /** @lends SwitchManipulator.prototype */\\n    SwitchManipulator.prototype = {\\n        update: function ( nv ) {\\n            var manipulator = this.getCurrentManipulator();\\n            if ( manipulator !== undefined ) {\\n                return manipulator.update( nv );\\n            }\\n            return undefined;\\n        },\\n        setNode: function ( node ) {\\n            var manipulator = this.getCurrentManipulator();\\n            if ( manipulator.setNode === undefined ) {\\n                Notify.log( \\'manipulator has not setNode method\\' );\\n                return;\\n            }\\n            manipulator.setNode( node );\\n        },\\n        getControllerList: function () {\\n            return this.getCurrentManipulator().getControllerList();\\n        },\\n        getNumManipulator: function () {\\n            return this._manipulatorList.length;\\n        },\\n        addManipulator: function ( manipulator ) {\\n            this._manipulatorList.push( manipulator );\\n            if ( this._currentManipulator === undefined ) {\\n                this.setManipulatorIndex( 0 );\\n            }\\n        },\\n        getManipulatorList: function () {\\n            return this._manipulatorList;\\n        },\\n        setManipulatorIndex: function ( index ) {\\n            this._currentManipulator = index;\\n        },\\n        getCurrentManipulatorIndex: function () {\\n            return this._currentManipulator;\\n        },\\n        getCurrentManipulator: function () {\\n            var manipulator = this._manipulatorList[ this._currentManipulator ];\\n            return manipulator;\\n        },\\n        reset: function () {\\n            this.getCurrentManipulator().reset();\\n        },\\n        computeHomePosition: function () {\\n            var manipulator = this.getCurrentManipulator();\\n            if ( manipulator !== undefined ) {\\n                manipulator.computeHomePosition();\\n            }\\n        },\\n        getInverseMatrix: function () {\\n            var manipulator = this.getCurrentManipulator();\\n            if ( manipulator !== undefined ) {\\n                return manipulator.getInverseMatrix();\\n            }\\n        }\\n    };\\n\\n    return SwitchManipulator;\\n} );\\n\\n//# sourceURL=/osgGA/SwitchManipulator.js\");\n\n",
    "eval(\"define( \\'osgGA/osgGA\\',[\\n    \\'Hammer\\',\\n    \\'osgGA/FirstPersonManipulator\\',\\n    \\'osgGA/FirstPersonManipulatorMouseKeyboardController\\',\\n    \\'osgGA/FirstPersonManipulatorOculusController\\',\\n    \\'osgGA/Manipulator\\',\\n    \\'osgGA/OrbitManipulator\\',\\n    \\'osgGA/OrbitManipulatorGamePadController\\',\\n    \\'osgGA/OrbitManipulatorHammerController\\',\\n    \\'osgGA/OrbitManipulatorLeapMotionController\\',\\n    \\'osgGA/OrbitManipulatorMouseKeyboardController\\',\\n    \\'osgGA/SwitchManipulator\\',\\n    \\'osgGA/OrbitManipulatorEnums\\'\\n], function ( Hammer, FirstPersonManipulator, FirstPersonManipulatorMouseKeyboardController, FirstPersonManipulatorOculusController, Manipulator, OrbitManipulator, OrbitManipulatorGamePadController, OrbitManipulatorHammerController, OrbitManipulatorLeapMotionController, OrbitManipulatorMouseKeyboardController, SwitchManipulator, OrbitManipulatorEnums ) {\\n\\n    var osgGA = {};\\n\\n    Hammer.NO_MOUSEEVENTS = true; // disable hammer js mouse events\\n\\n    osgGA.FirstPersonManipulator = FirstPersonManipulator;\\n    osgGA.getFirstPersonStandardMouseKeyboardControllerClass = function () {\\n        return FirstPersonManipulatorMouseKeyboardController;\\n    };\\n    osgGA.getFirstPersonOculusControllerClass = function () {\\n        return FirstPersonManipulatorOculusController;\\n    };\\n    osgGA.Manipulator = Manipulator;\\n    osgGA.OrbitManipulator = OrbitManipulator;\\n    osgGA.getOrbitManipulatorGamePadController = function () {\\n        return OrbitManipulatorGamePadController;\\n    };\\n    osgGA.getOrbitManipulatorHammerController = function () {\\n        return OrbitManipulatorHammerController;\\n    };\\n    osgGA.getOrbitManipulatorLeapMotionController = function () {\\n        return OrbitManipulatorLeapMotionController;\\n    };\\n    osgGA.getOrbitManipulatorMouseKeyboardController = function () {\\n        return OrbitManipulatorMouseKeyboardController;\\n    };\\n    osgGA.SwitchManipulator = SwitchManipulator;\\n\\n    osgGA.OrbitManipulator.Rotate = OrbitManipulatorEnums.ROTATE;\\n    osgGA.OrbitManipulator.Pan = OrbitManipulatorEnums.PAN;\\n    osgGA.OrbitManipulator.Zoom = OrbitManipulatorEnums.ZOOM;\\n\\n    return osgGA;\\n} );\\n\\n//# sourceURL=/osgGA/osgGA.js\");\n\n",
    "eval(\"define( \\'osgUtil/Composer\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/Node\\',\\n    \\'osg/Depth\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Camera\\',\\n    \\'osg/FrameBufferObject\\',\\n    \\'osg/Viewport\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/StateSet\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Shape\\',\\n    \\'osg/TransformEnums\\',\\n    \\'osg/Vec2\\',\\n    \\'osg/Vec3\\'\\n], function ( Notify, MACROUTILS, Node, Depth, Texture, Camera, FrameBufferObject, Viewport, Matrix,  Uniform, StateSet, Program, Shader, Shape, TransformEnums, Vec2, Vec3 ) {\\n\\n    /*\\n     Composer is an helper to create post fx. The idea is to push one or more textures into a pipe of shader filter.\\n\\n     how to use it:\\n\\n     // example how to blur a texture and render it to screen\\n     var myTexture; // imagine it\\'s your texture you want to process\\n     var composer = new Composer();\\n     composer.addPass(new Composer.Filter.InputTexture(myTexture));\\n     composer.addPass(new Composer.Filter.HBlur(5));\\n     composer.addPass(new Composer.Filter.VBlur(5));\\n     composer.renderToScreen(1200, 900);\\n     composer.build(); // if you dont build manually it will be done in the scenegraph while upading\\n     rootnode.addChild(composer);\\n\\n     // now you can imagine to some process and use the result as input texture for a geometry\\n     var myTexture; // imagine it\\'s your texture you want to process\\n     var myResultTexture = new Texture(); // imagine it\\'s your texture you want to process\\n     myResultTexture.setTextureSize(1200,900);\\n     var composer = new Composer();\\n     composer.addPass(new Composer.Filter.InputTexture(myTexture));\\n     composer.addPass(new Composer.Filter.HBlur(5));\\n     composer.addPass(new Composer.Filter.VBlur(5), resultTexture);\\n\\n     myGeometry.getStateSet().setTextureAttributeAndModes(0, resultTexture);\\n     rootnode.addChild(composer);\\n\\n     */\\n\\n    var Composer = function () {\\n        Node.call( this );\\n        this._stack = [];\\n        this._renderToScreen = false;\\n        this._dirty = false;\\n        var UpdateCallback = function () {\\n\\n        };\\n        UpdateCallback.prototype = {\\n            update: function ( node /*, nv */ ) {\\n                if ( node.isDirty() ) {\\n                    node.build();\\n                }\\n            }\\n        };\\n        this.setUpdateCallback( new UpdateCallback() );\\n        this.getOrCreateStateSet().setAttributeAndModes( new Depth( \\'DISABLE\\' ) );\\n    };\\n\\n    Composer.prototype = MACROUTILS.objectInehrit( Node.prototype, {\\n        dirty: function () {\\n            for ( var i = 0, l = this._stack.length; i < l; i++ ) {\\n                this._stack[ i ].filter.dirty();\\n            }\\n        },\\n\\n        // addPass support different signature\\n        // addPass(filter) -> the filter will be done on a texture of the same size than the previous pass\\n        // addPass(filter, textureWidth, textureHeight) -> the filter will be done on a texture width and height\\n        // addPass(filter, texture) -> the filter will be done on the giver texture using its width and height\\n        addPass: function ( filter, arg0, arg1 ) {\\n            if ( arg0 instanceof Texture ) {\\n                this._stack.push( {\\n                    filter: filter,\\n                    texture: arg0\\n                } );\\n            } else if ( arg0 !== undefined && arg1 !== undefined ) {\\n                this._stack.push( {\\n                    filter: filter,\\n                    width: Math.floor( arg0 ),\\n                    height: Math.floor( arg1 )\\n                } );\\n            } else {\\n                this._stack.push( {\\n                    filter: filter\\n                } );\\n            }\\n        },\\n        renderToScreen: function ( w, h ) {\\n            this._renderToScreen = true;\\n            this._renderToScreenWidth = w;\\n            this._renderToScreenHeight = h;\\n        },\\n\\n        isDirty: function () {\\n            for ( var i = 0, l = this._stack.length; i < l; i++ ) {\\n                if ( this._stack[ i ].filter.isDirty() ) {\\n                    return true;\\n                }\\n            }\\n            return false;\\n        },\\n\\n        build: function () {\\n            var root = this;\\n            this.removeChildren();\\n            var lastTextureResult;\\n            var self = this;\\n            this._stack.forEach( function ( element, i, array ) {\\n                if ( element.filter.isDirty() ) {\\n                    element.filter.build();\\n                }\\n                var stateSet = element.filter.getStateSet();\\n                var w, h;\\n                if ( element.texture !== undefined ) {\\n                    w = element.texture.getWidth();\\n                    h = element.texture.getHeight();\\n                } else if ( element.width !== undefined && element.height !== undefined ) {\\n                    w = element.width;\\n                    h = element.height;\\n                } else {\\n                    // get width from Texture0\\n                    var inputTexture = stateSet.getTextureAttribute( 0, \\'Texture\\' );\\n                    if ( inputTexture === undefined ) {\\n                        Notify.warn( \\'Composer can\\\\\\'t find any information to setup texture output size\\' );\\n                    }\\n                    w = inputTexture.getWidth();\\n                    h = inputTexture.getHeight();\\n                }\\n\\n                // is it the last filter and we want to render to screen ?\\n                var lastFilterRenderToScreen = ( i === array.length - 1 &&\\n                    self._renderToScreen === true );\\n\\n                // check if we have something to do\\n                // else we will just translate stateset to the next filter\\n                // this part exist to manage the Composer.Filter.InputTexture that setup the first texture unit\\n                if ( !lastFilterRenderToScreen ) {\\n                    if ( stateSet.getAttribute( \\'Program\\' ) === undefined ) {\\n                        array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, stateSet.getTextureAttribute( 0, \\'Texture\\' ) );\\n                        return;\\n                    }\\n                }\\n\\n                // check if we want to render on screen\\n                var camera = new Camera();\\n                camera.setStateSet( element.filter.getStateSet() );\\n\\n                var texture;\\n                var quad;\\n                if ( lastFilterRenderToScreen === true ) {\\n                    w = self._renderToScreenWidth;\\n                    h = self._renderToScreenHeight;\\n                } else {\\n                    camera.setRenderOrder( Camera.PRE_RENDER, 0 );\\n                    texture = element.texture;\\n                    if ( texture === undefined ) {\\n                        texture = new Texture();\\n                        texture.setTextureSize( w, h );\\n                    }\\n                    camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture, 0 );\\n                }\\n\\n                var vp = new Viewport( 0, 0, w, h );\\n                camera.setReferenceFrame( TransformEnums.ABSOLUTE_RF );\\n                camera.setViewport( vp );\\n                Matrix.makeOrtho( -w / 2, w / 2, -h / 2, h / 2, -5, 5, camera.getProjectionMatrix() );\\n\\n                quad = Shape.createTexturedQuadGeometry( -w / 2, -h / 2, 0,\\n                    w, 0, 0,\\n                    0, h, 0 );\\n\\n                if ( element.filter.buildGeometry !== undefined )\\n                    quad = element.filter.buildGeometry( quad );\\n\\n                quad.setName( \\'composer layer\\' );\\n\\n                lastTextureResult = texture;\\n\\n                // assign the result texture to the next stateset\\n                if ( i + 1 < array.length ) {\\n                    array[ i + 1 ].filter.getStateSet().setTextureAttributeAndModes( 0, lastTextureResult );\\n                }\\n\\n                camera.addChild( quad );\\n                element.filter.getStateSet().addUniform( Uniform.createFloat2( [ w, h ], \\'RenderSize\\' ) );\\n                camera.setName( \\'Composer Pass\\' + i );\\n                root.addChild( camera );\\n            } );\\n            this._resultTexture = lastTextureResult;\\n        }\\n    } );\\n\\n    Composer.Filter = function () {\\n        this._stateSet = new StateSet();\\n        this._dirty = true;\\n    };\\n\\n    Composer.Filter.prototype = {\\n        getStateSet: function () {\\n            return this._stateSet;\\n        },\\n        getOrCreateStateSet: function () {\\n            return this._stateSet;\\n        },\\n        dirty: function () {\\n            this._dirty = true;\\n        },\\n        isDirty: function () {\\n            return this._dirty;\\n        }\\n    };\\n\\n\\n    Composer.Filter.defaultVertexShader = [\\n        \\'#ifdef GL_ES\\',\\n        \\'precision highp float;\\',\\n        \\'#endif\\',\\n        \\'attribute vec3 Vertex;\\',\\n        \\'attribute vec2 TexCoord0;\\',\\n        \\'varying vec2 FragTexCoord0;\\',\\n        \\'uniform mat4 ModelViewMatrix;\\',\\n        \\'uniform mat4 ProjectionMatrix;\\',\\n        \\'void main(void) {\\',\\n        \\'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);\\',\\n        \\'  FragTexCoord0 = TexCoord0;\\',\\n        \\'}\\',\\n        \\'\\'\\n    ].join( \\'\\\\n\\' );\\n\\n    Composer.Filter.defaultFragmentShaderHeader = [\\n        \\'#ifdef GL_ES\\',\\n        \\'precision highp float;\\',\\n        \\'#endif\\',\\n        \\'varying vec2 FragTexCoord0;\\',\\n        \\'uniform vec2 RenderSize;\\',\\n        \\'uniform sampler2D Texture0;\\',\\n        \\'\\'\\n    ].join( \\'\\\\n\\' );\\n\\n    Composer.Filter.shaderUtils = [\\n        \\'vec4 packFloatTo4x8(in float v) {\\',\\n        \\'vec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\\',\\n        \\'enc = fract(enc);\\',\\n        \\'enc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\\',\\n        \\'return enc;\\',\\n        \\'}\\',\\n\\n        \\' \\',\\n        \\'vec4 pack2FloatTo4x8(in vec2 val) {\\',\\n        \\' const vec2 bitSh = vec2(256.0, 1.0);\\',\\n        \\' const vec2 bitMsk = vec2(0.0, 1.0/256.0);\\',\\n        \\' vec2 res1 = fract(val.x * bitSh);\\',\\n        \\' res1 -= res1.xx * bitMsk;\\',\\n        \\' vec2 res2 = fract(val.y * bitSh);\\',\\n        \\' res2 -= res2.xx * bitMsk;\\',\\n        \\' return vec4(res1.x,res1.y,res2.x,res2.y);\\',\\n        \\'}\\',\\n        \\' \\',\\n        \\'float unpack4x8ToFloat( vec4 rgba ) {\\',\\n        \\' return dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\\',\\n        \\'}\\',\\n        \\' \\',\\n        \\'vec2 unpack4x8To2Float(in vec4 val) {\\',\\n        \\' const vec2 unshift = vec2(1.0/256.0, 1.0);\\',\\n        \\' return vec2(dot(val.xy, unshift), dot(val.zw, unshift));\\',\\n        \\'}\\',\\n\\n        \\'vec2 encodeNormal (vec3 n)\\',\\n        \\'{\\',\\n        \\'    float f = sqrt(8.0*n.z+8.0);\\',\\n        \\'    return n.xy / f + 0.5;\\',\\n        \\'}\\',\\n\\n        \\'vec3 decodeNormal (vec2 enc)\\',\\n        \\'{\\',\\n        \\'    vec2 fenc = enc*4.0-2.0;\\',\\n        \\'    float f = dot(fenc,fenc);\\',\\n        \\'    float g = sqrt(1.0-f/4.0);\\',\\n        \\'    vec3 n;\\',\\n        \\'    n.xy = fenc*g;\\',\\n        \\'    n.z = 1.0-f/2.0;\\',\\n        \\'    return n;\\',\\n        \\'}\\',\\n        \\'\\'\\n    ].join( \\'\\\\n\\' );\\n\\n    Composer.Filter.Helper = {\\n        getOrCreatePascalCoefficients: function () {\\n            var cache = Composer.Filter.Helper.getOrCreatePascalCoefficients.cache;\\n            if ( cache !== undefined ) {\\n                return cache;\\n            }\\n\\n            cache = ( function ( kernelSize ) {\\n                var pascalTriangle = [\\n                    [ 1 ]\\n                ];\\n                for ( var j = 0; j < ( kernelSize - 1 ); j++ ) {\\n                    //var sum = Math.pow( 2, j );\\n                    var currentRow = pascalTriangle[ j ];\\n                    var currentRowSize = currentRow.length;\\n\\n                    var nextRowSize = currentRowSize + 1;\\n                    var nextRow = new Array( currentRowSize );\\n                    nextRow[ 0 ] = 1.0;\\n                    nextRow[ nextRowSize - 1 ] = 1.0;\\n\\n                    var idx = 1;\\n                    for ( var p = 0; p < currentRowSize - 1; p++ ) {\\n                        var val = ( currentRow[ p ] + currentRow[ p + 1 ] );\\n                        nextRow[ idx++ ] = val;\\n                    }\\n                    pascalTriangle.push( nextRow );\\n                }\\n\\n                // compute real coef dividing by sum\\n                ( function () {\\n                    for ( var a = 0; a < pascalTriangle.length; a++ ) {\\n                        var row = pascalTriangle[ a ];\\n                        //var str = \\'\\';\\n\\n                        var sum = Math.pow( 2, a );\\n                        for ( var i = 0; i < row.length; i++ ) {\\n                            row[ i ] = row[ i ] / sum;\\n                            //str += row[i].toString() + \\' \\';\\n                        }\\n                        //Notify.log(str);\\n                    }\\n                } )();\\n\\n                return pascalTriangle;\\n            } )( 20 );\\n            Composer.Filter.Helper.getOrCreatePascalCoefficients.cache = cache;\\n            return cache;\\n        }\\n    };\\n\\n    Composer.Filter.Custom = function ( fragmentShader, uniforms ) {\\n        Composer.Filter.call( this );\\n        this._fragmentShader = fragmentShader;\\n        this._uniforms = uniforms;\\n        this._vertexShader = Composer.Filter.defaultVertexShader;\\n    };\\n\\n    Composer.Filter.Custom.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        build: function () {\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', this._vertexShader ),\\n                new Shader( \\'FRAGMENT_SHADER\\', this._fragmentShader ) );\\n\\n            if ( this._uniforms ) {\\n                var unitIndex = 0;\\n\\n                var r = this._fragmentShader.match( /uniform\\\\s+\\\\w+\\\\s+\\\\w+/g );\\n                if ( r !== null ) {\\n                    for ( var i = 0, l = r.length; i < l; i++ ) {\\n                        var match = r[ i ].match( /uniform\\\\s+(\\\\w+)\\\\s+(\\\\w+)/ );\\n                        var uniformType = match[ 1 ];\\n                        var uniformName = match[ 2 ];\\n                        var uniform;\\n\\n                        if ( this._uniforms[ uniformName ] !== undefined ) {\\n                            var uniformValue = this._uniforms[ uniformName ];\\n                            if ( uniformType.search( \\'sampler\\' ) !== -1 ) {\\n                                this._stateSet.setTextureAttributeAndModes( unitIndex, uniformValue );\\n                                uniform = Uniform.createInt1( unitIndex, uniformName );\\n                                unitIndex++;\\n                                this._stateSet.addUniform( uniform );\\n                            } else {\\n                                if ( Uniform.isUniform( uniformValue ) ) {\\n                                    uniform = uniformValue;\\n                                } else {\\n                                    uniform = Uniform[ uniformType ]( this._uniforms[ uniformName ], uniformName );\\n                                }\\n                                this._stateSet.addUniform( uniform );\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            this._stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n\\n\\n    Composer.Filter.AverageHBlur = function ( nbSamplesOpt ) {\\n        Composer.Filter.call( this );\\n        if ( nbSamplesOpt === undefined ) {\\n            this.setBlurSize( 5 );\\n        } else {\\n            this.setBlurSize( nbSamplesOpt );\\n        }\\n        this._pixelSize = 1.0;\\n    };\\n\\n    Composer.Filter.AverageHBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        setBlurSize: function ( nbSamples ) {\\n            if ( nbSamples % 2 !== 1 ) {\\n                nbSamples += 1;\\n            }\\n            this._nbSamples = nbSamples;\\n            this.dirty();\\n        },\\n        setPixelSize: function ( value ) {\\n            this._pixelSize = value;\\n            this.dirty();\\n        },\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(float(\\' + value + \\'), 0.0)/RenderSize[0];\\';\\n        },\\n        getShaderBlurKernel: function () {\\n            var nbSamples = this._nbSamples;\\n            var kernel = [];\\n            kernel.push( \\' pixel = texture2D(Texture0, FragTexCoord0 );\\' );\\n            kernel.push( \\' if (pixel.w == 0.0) { gl_FragColor = pixel; return; }\\' );\\n            kernel.push( \\' vec2 offset;\\' );\\n            for ( var i = 1; i < Math.ceil( nbSamples / 2 ); i++ ) {\\n                kernel.push( \\' offset = \\' + this.getUVOffset( i * this._pixelSize ) );\\n                kernel.push( \\' pixel += texture2D(Texture0, FragTexCoord0 + offset);\\' );\\n                kernel.push( \\' pixel += texture2D(Texture0, FragTexCoord0 - offset);\\' );\\n            }\\n            kernel.push( \\' pixel /= float(\\' + nbSamples + \\');\\' );\\n            return kernel;\\n        },\\n        build: function () {\\n            //var nbSamples = this._nbSamples;\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var fgt = [\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform float width;\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  vec4 pixel;\\',\\n                this.getShaderBlurKernel().join( \\'\\\\n\\' ),\\n                \\'  gl_FragColor = vec4(pixel);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            if ( this._stateSet.getUniform( \\'Texture0\\' ) === undefined ) {\\n                this._stateSet.addUniform( Uniform.createInt1( 0, \\'Texture0\\' ) );\\n            }\\n            this._stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n\\n    Composer.Filter.AverageVBlur = function ( nbSamplesOpt ) {\\n        Composer.Filter.AverageHBlur.call( this, nbSamplesOpt );\\n    };\\n    Composer.Filter.AverageVBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.AverageHBlur.prototype, {\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(0.0, float(\\' + value + \\'))/RenderSize[1];\\';\\n        }\\n    } );\\n\\n    Composer.Filter.BilateralHBlur = function ( options ) {\\n        Composer.Filter.call( this );\\n\\n        if ( options === undefined ) {\\n            options = {};\\n        }\\n\\n        var nbSamplesOpt = options.nbSamples;\\n        var depthTexture = options.depthTexture;\\n        var radius = options.radius;\\n\\n        if ( nbSamplesOpt === undefined ) {\\n            this.setBlurSize( 5 );\\n        } else {\\n            this.setBlurSize( nbSamplesOpt );\\n        }\\n        this._depthTexture = depthTexture;\\n        this._radius = Uniform.createFloat( 1.0, \\'radius\\' );\\n        this._pixelSize = Uniform.createFloat( 1.0, \\'pixelSize\\' );\\n        this.setRadius( radius );\\n    };\\n\\n    Composer.Filter.BilateralHBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        setBlurSize: function ( nbSamples ) {\\n            if ( nbSamples % 2 !== 1 ) {\\n                nbSamples += 1;\\n            }\\n            //Notify.log(\\'BlurSize \\' + nbSamples);\\n            this._nbSamples = nbSamples;\\n            this.dirty();\\n        },\\n        setPixelSize: function ( value ) {\\n            this._pixelSize.get()[ 0 ] = value;\\n            this._pixelSize.dirty();\\n        },\\n        setRadius: function ( radius ) {\\n            this._radius.get()[ 0 ] = radius; // *2.0;\\n            this._radius.dirty();\\n        },\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(0.0, float(\\' + value + \\') * pixelSize )/RenderSize[1];\\';\\n        },\\n        getShaderBlurKernel: function () {\\n            var nbSamples = this._nbSamples;\\n            var kernel = [];\\n            kernel.push( \\' pixel = texture2D(Texture0, FragTexCoord0 );\\' );\\n            kernel.push( \\' if (pixel.w <= 0.0001) { gl_FragColor = vec4(1.0); return; }\\' );\\n            kernel.push( \\' vec2 offset, tmpUV;\\' );\\n            kernel.push( \\' depth = getDepthValue(texture2D(Texture1, FragTexCoord0 ));\\' );\\n            for ( var i = 1; i < Math.ceil( nbSamples / 2 ); i++ ) {\\n                kernel.push( \\' offset = \\' + this.getUVOffset( i ) );\\n\\n                kernel.push( \\' tmpUV =  FragTexCoord0 + offset;\\' );\\n                kernel.push( \\' tmpDepth = getDepthValue(texture2D(Texture1, tmpUV ));\\' );\\n                kernel.push( \\' if ( abs(depth-tmpDepth) < radius) {\\' );\\n                kernel.push( \\'   pixel += texture2D(Texture0, tmpUV);\\' );\\n                kernel.push( \\'   nbHits += 1.0;\\' );\\n                kernel.push( \\' }\\' );\\n\\n                kernel.push( \\' tmpUV =  FragTexCoord0 - offset;\\' );\\n                kernel.push( \\' tmpDepth = getDepthValue(texture2D(Texture1, tmpUV ));\\' );\\n                kernel.push( \\' if ( abs(depth-tmpDepth) < radius) {\\' );\\n                kernel.push( \\'   pixel += texture2D(Texture0, tmpUV);\\' );\\n                kernel.push( \\'   nbHits += 1.0;\\' );\\n                kernel.push( \\' }\\' );\\n            }\\n            kernel.push( \\' pixel /= nbHits;\\' );\\n            return kernel;\\n        },\\n        build: function () {\\n            //var nbSamples = this._nbSamples;\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var fgt = [\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform sampler2D Texture1;\\',\\n                \\'uniform float width;\\',\\n                \\'uniform mat4 projection;\\',\\n                \\'uniform float radius;\\',\\n                \\'uniform float pixelSize;\\',\\n\\n                \\'float znear,zfar,zrange;\\',\\n                \\'\\',\\n                Composer.Filter.shaderUtils,\\n                \\'\\',\\n                \\'float getDepthValue(vec4 v) {\\',\\n                \\'  float depth = unpack4x8ToFloat(v);\\',\\n                \\'  depth = depth*zrange+znear;\\',\\n                \\'  return -depth;\\',\\n                \\'}\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  vec4 pixel;\\',\\n                \\'  float depth, tmpDepth;\\',\\n                \\'  znear = projection[3][2] / (projection[2][2]-1.0);\\',\\n                \\'  zfar = projection[3][2] / (projection[2][2]+1.0);\\',\\n                \\'  zrange = zfar-znear;\\',\\n                \\'  float nbHits = 1.0;\\',\\n\\n                this.getShaderBlurKernel().join( \\'\\\\n\\' ),\\n                \\'  gl_FragColor = vec4(pixel);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            if ( this._stateSet.getUniform( \\'Texture0\\' ) === undefined ) {\\n                this._stateSet.addUniform( Uniform.createInt1( 0, \\'Texture0\\' ) );\\n            }\\n            if ( this._stateSet.getUniform( \\'Texture1\\' ) === undefined ) {\\n                this._stateSet.addUniform( Uniform.createInt1( 1, \\'Texture1\\' ) );\\n            }\\n            this._stateSet.addUniform( this._radius );\\n            this._stateSet.addUniform( this._pixelSize );\\n            this._stateSet.setTextureAttributeAndModes( 1, this._depthTexture );\\n            this._stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n    Composer.Filter.BilateralVBlur = function ( options ) {\\n        Composer.Filter.BilateralHBlur.call( this, options );\\n    };\\n\\n    Composer.Filter.BilateralVBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.BilateralHBlur.prototype, {\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(float(\\' + value + \\')*pixelSize,0.0)/RenderSize[0];\\';\\n        }\\n    } );\\n\\n    // InputTexture is a fake filter to setup the first texture\\n    // in the composer pipeline\\n    Composer.Filter.InputTexture = function ( texture ) {\\n        Composer.Filter.call( this );\\n        this._stateSet.setTextureAttributeAndModes( 0, texture );\\n    };\\n    Composer.Filter.InputTexture.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        build: function () {\\n            this._dirty = false;\\n        }\\n    } );\\n\\n    // Operate a Gaussian horizontal blur\\n    Composer.Filter.HBlur = function ( nbSamplesOpt ) {\\n        Composer.Filter.call( this );\\n        if ( nbSamplesOpt === undefined ) {\\n            this.setBlurSize( 5 );\\n        } else {\\n            this.setBlurSize( nbSamplesOpt );\\n        }\\n    };\\n\\n    Composer.Filter.HBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        setBlurSize: function ( nbSamples ) {\\n            if ( nbSamples % 2 !== 1 ) {\\n                nbSamples += 1;\\n            }\\n            this._nbSamples = nbSamples;\\n            this.dirty();\\n        },\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(float(\\' + value + \\'), 0.0)/RenderSize[0];\\';\\n        },\\n        build: function () {\\n            var nbSamples = this._nbSamples;\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var pascal = Composer.Filter.Helper.getOrCreatePascalCoefficients();\\n            var weights = pascal[ nbSamples - 1 ];\\n            var start = Math.floor( nbSamples / 2.0 );\\n            var kernel = [];\\n            kernel.push( \\' pixel += float(\\' + weights[ start ] + \\')*texture2D(Texture0, FragTexCoord0 ).rgb;\\' );\\n            var offset = 1;\\n            kernel.push( \\' vec2 offset;\\' );\\n            for ( var i = start + 1; i < nbSamples; i++ ) {\\n                var weight = weights[ i ];\\n                kernel.push( \\' offset = \\' + this.getUVOffset( i ) );\\n                offset++;\\n                kernel.push( \\' pixel += \\' + weight + \\'*texture2D(Texture0, FragTexCoord0 + offset).rgb;\\' );\\n                kernel.push( \\' pixel += \\' + weight + \\'*texture2D(Texture0, FragTexCoord0 - offset).rgb;\\' );\\n            }\\n\\n            var fgt = [\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform float width;\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  vec3 pixel;\\',\\n                kernel.join( \\'\\\\n\\' ),\\n                \\'  gl_FragColor = vec4(pixel,1.0);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            if ( this._stateSet.getUniform( \\'Texture0\\' ) === undefined ) {\\n                this._stateSet.addUniform( Uniform.createInt1( 0, \\'Texture0\\' ) );\\n            }\\n            this._stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n    // Operate a Gaussian vertical blur\\n    Composer.Filter.VBlur = function ( /*nbSamplesOpt*/ ) {\\n        Composer.Filter.HBlur.call( this );\\n    };\\n\\n    Composer.Filter.VBlur.prototype = MACROUTILS.objectInehrit( Composer.Filter.HBlur.prototype, {\\n        getUVOffset: function ( value ) {\\n            return \\'vec2(0.0, float(\\' + value + \\'))/RenderSize[1];\\';\\n        }\\n    } );\\n\\n    // Sobel filter\\n    // http://en.wikipedia.org/wiki/Sobel_operator\\n    Composer.Filter.SobelFilter = function () {\\n        Composer.Filter.call( this );\\n        this._color = Uniform.createFloat3( [ 1.0, 1.0, 1.0 ], \\'color\\' );\\n        this._factor = Uniform.createFloat( 1.0, \\'factor\\' );\\n    };\\n\\n    Composer.Filter.SobelFilter.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        setColor: function ( color ) {\\n            this._color.get()[ 0 ] = color[ 0 ];\\n            this._color.get()[ 1 ] = color[ 1 ];\\n            this._color.get()[ 2 ] = color[ 2 ];\\n            this._color.dirty();\\n        },\\n        setFactor: function ( f ) {\\n            this._factor.get()[ 0 ] = f;\\n            this._factor.dirty();\\n        },\\n        build: function () {\\n            var stateSet = this._stateSet;\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var fgt = [\\n                \\'\\',\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform vec3 color;\\',\\n                \\'uniform float factor;\\',\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  float fac0 = 2.0;\\',\\n                \\'  float fac1 = 1.0;\\',\\n                \\'  float offsetx = 1.0/RenderSize[0];\\',\\n                \\'  float offsety = 1.0/RenderSize[1];\\',\\n                \\'  vec4 texel0 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, offsety));\\',\\n                \\'  vec4 texel1 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, 0.0));\\',\\n                \\'  vec4 texel2 = texture2D(Texture0, FragTexCoord0 + vec2(offsetx, -offsety));\\',\\n                \\'  vec4 texel3 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, -offsety));\\',\\n                \\'  vec4 texel4 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, -offsety));\\',\\n                \\'  vec4 texel5 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, 0.0));\\',\\n                \\'  vec4 texel6 = texture2D(Texture0, FragTexCoord0 + vec2(-offsetx, offsety));\\',\\n                \\'  vec4 texel7 = texture2D(Texture0, FragTexCoord0 + vec2(0.0, offsety));\\',\\n                \\'  vec4 rowx = -fac0*texel5 + fac0*texel1 +  -fac1*texel6 + fac1*texel0 + -fac1*texel4 + fac1*texel2;\\',\\n                \\'  vec4 rowy = -fac0*texel3 + fac0*texel7 +  -fac1*texel4 + fac1*texel6 + -fac1*texel2 + fac1*texel0;\\',\\n                \\'  float mag = sqrt(dot(rowy,rowy)+dot(rowx,rowx));\\',\\n                \\'  if (mag < 1.0/255.0) { discard; return; }\\',\\n                \\'  mag *= factor;\\',\\n                \\'  mag = min(1.0, mag);\\',\\n                \\'  gl_FragColor = vec4(color*mag,mag);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            stateSet.setAttributeAndModes( program );\\n            stateSet.addUniform( this._color );\\n            stateSet.addUniform( this._factor );\\n            stateSet.addUniform( Uniform.createInt1( 0, \\'Texture0\\' ) );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n\\n\\n    Composer.Filter.BlendMix = function () {\\n        Composer.Filter.call( this );\\n        var texture0, texture1, mixValue;\\n        var unit0 = 0;\\n        var unit1 = 1;\\n        var stateSet = this._stateSet;\\n        if ( arguments.length === 3 ) {\\n            texture0 = arguments[ 0 ];\\n            texture1 = arguments[ 1 ];\\n            mixValue = arguments[ 2 ];\\n            unit0 = 1;\\n            unit1 = 2;\\n            stateSet.setTextureAttributeAndModes( unit0, texture0 );\\n        } else if ( arguments.length === 2 ) {\\n            texture1 = arguments[ 0 ];\\n            mixValue = arguments[ 1 ];\\n        } else if ( arguments.length === 1 ) {\\n            texture1 = arguments[ 0 ];\\n            mixValue = 0.5;\\n        }\\n        stateSet.setTextureAttributeAndModes( unit1, texture1 );\\n        stateSet.addUniform( Uniform.createInt1( unit0, \\'Texture0\\' ) );\\n        stateSet.addUniform( Uniform.createInt1( unit1, \\'Texture1\\' ) );\\n        this._mixValueUniform = Uniform.createFloat1( mixValue, \\'MixValue\\' );\\n        stateSet.addUniform( this._mixValueUniform );\\n    };\\n\\n    Composer.Filter.BlendMix.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        getBlendFactorUniform: function () {\\n            return this._mixValueUniform;\\n        },\\n\\n        build: function () {\\n            var stateSet = this._stateSet;\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var fgt = [\\n                \\'\\',\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform sampler2D Texture1;\\',\\n                \\'uniform float MixValue;\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  gl_FragColor = mix(texture2D(Texture0,FragTexCoord0), texture2D(Texture1,FragTexCoord0),MixValue);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n\\n    Composer.Filter.BlendMultiply = function () {\\n        Composer.Filter.call( this );\\n        var stateSet = this._stateSet;\\n        var texture0, texture1;\\n        var unit0 = 0;\\n        var unit1 = 1;\\n        if ( arguments.length === 2 ) {\\n            texture0 = arguments[ 0 ];\\n            texture1 = arguments[ 1 ];\\n            unit0 = 1;\\n            unit0 = 2;\\n            stateSet.setTextureAttributeAndModes( unit0, texture0 );\\n        } else if ( arguments.length === 1 ) {\\n            texture1 = arguments[ 0 ];\\n        }\\n        stateSet.setTextureAttributeAndModes( unit1, texture1 );\\n        stateSet.addUniform( Uniform.createInt1( unit0, \\'Texture0\\' ) );\\n        stateSet.addUniform( Uniform.createInt1( unit1, \\'Texture1\\' ) );\\n    };\\n\\n    Composer.Filter.BlendMultiply.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n        build: function () {\\n            var vtx = Composer.Filter.defaultVertexShader;\\n            var fgt = [\\n                \\'\\',\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform sampler2D Texture1;\\',\\n                \\'uniform float MixValue;\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                \\'  gl_FragColor = texture2D(Texture0,FragTexCoord0)*texture2D(Texture1,FragTexCoord0);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vtx ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fgt ) );\\n\\n            this._stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n    Composer.Filter.SSAO = function ( options ) {\\n        Composer.Filter.call( this );\\n\\n        var stateSet = this._stateSet;\\n        var nbSamples = 16;\\n        var radius = 0.05;\\n        if ( options !== undefined ) {\\n            if ( options.nbSamples !== undefined )\\n                nbSamples = options.nbSamples;\\n\\n            if ( options.radius !== undefined )\\n                radius = options.radius;\\n        }\\n\\n        var textureNormal = options.normal;\\n        var texturePosition = options.position;\\n        this._radius = radius;\\n        this._nbSamples = nbSamples;\\n        this._noiseTextureSize = 16;\\n        this._sceneRadius = 2.0;\\n\\n        stateSet.addUniform( Uniform.createFloat1( 1.0, \\'Power\\' ) );\\n        stateSet.addUniform( Uniform.createFloat1( radius, \\'Radius\\' ) );\\n        stateSet.addUniform( Uniform.createInt1( 0, \\'Texture0\\' ) );\\n        stateSet.addUniform( Uniform.createInt1( 1, \\'Texture1\\' ) );\\n        stateSet.addUniform( Uniform.createInt1( 2, \\'Texture2\\' ) );\\n        stateSet.addUniform( Uniform.createFloat1( 0.1, \\'AngleLimit\\' ) );\\n\\n        var w = textureNormal.getWidth();\\n        var h = textureNormal.getHeight();\\n        this._size = [ w, h ];\\n\\n        stateSet.setTextureAttributeAndModes( 0, textureNormal );\\n        stateSet.setTextureAttributeAndModes( 1, texturePosition );\\n\\n        this.initNoise();\\n\\n    };\\n\\n    Composer.Filter.SSAO.prototype = MACROUTILS.objectInehrit( Composer.Filter.prototype, {\\n\\n        initNoise: function () {\\n            var sizeNoise = this._noiseTextureSize;\\n            var noise = new Array( sizeNoise * sizeNoise * 3 );\\n            ( function ( array ) {\\n                var n = [ 0.0, 0.0 ];\\n                for ( var i = 0; i < sizeNoise * sizeNoise; i++ ) {\\n                    n[ 0 ] = 2.0 * ( Math.random() - 0.5 );\\n                    n[ 1 ] = 2.0 * ( Math.random() - 0.5 );\\n\\n                    Vec2.normalize( n, n );\\n                    array[ i * 3 + 0 ] = 255 * ( n[ 0 ] * 0.5 + 0.5 );\\n                    array[ i * 3 + 1 ] = 255 * ( n[ 1 ] * 0.5 + 0.5 );\\n                    array[ i * 3 + 2 ] = 255 * 0.5;\\n                }\\n            } )( noise );\\n\\n            var noiseTexture = new Texture();\\n            noiseTexture.setWrapS( \\'REPEAT\\' );\\n            noiseTexture.setWrapT( \\'REPEAT\\' );\\n            noiseTexture.setMinFilter( \\'NEAREST\\' );\\n            noiseTexture.setMagFilter( \\'NEAREST\\' );\\n\\n            noiseTexture.setTextureSize( sizeNoise, sizeNoise );\\n            noiseTexture.setImage( new Uint8Array( noise ), \\'RGB\\' );\\n            this._noiseTexture = noiseTexture;\\n        },\\n        setSceneRadius: function ( value ) {\\n            this._sceneRadius = value;\\n            this.dirty();\\n        },\\n        setAngleLimit: function ( value ) {\\n            var uniform = this._stateSet.getUniform( \\'AngleLimit\\' );\\n            uniform.get()[ 0 ] = value;\\n            uniform.dirty();\\n        },\\n        setNbSamples: function ( value ) {\\n            if ( value === this._nbSamples ) {\\n                return;\\n            }\\n            this._nbSamples = Math.floor( value );\\n            this.dirty();\\n        },\\n        setRadius: function ( value ) {\\n            var uniform = this._stateSet.getUniform( \\'Radius\\' );\\n            uniform.get()[ 0 ] = value;\\n            uniform.dirty();\\n        },\\n        setPower: function ( value ) {\\n            var uniform = this._stateSet.getUniform( \\'Power\\' );\\n            uniform.get()[ 0 ] = value;\\n            uniform.dirty();\\n        },\\n        build: function () {\\n            var stateSet = this._stateSet;\\n            var nbSamples = this._nbSamples;\\n            var kernel = new Array( nbSamples * 4 );\\n            ( function ( array ) {\\n                var v = [ 0.0, 0.0, 0.0 ];\\n                for ( var i = 0; i < nbSamples; i++ ) {\\n                    v[ 0 ] = 2.0 * ( Math.random() - 0.5 );\\n                    v[ 1 ] = 2.0 * ( Math.random() - 0.5 );\\n                    v[ 2 ] = Math.random();\\n\\n                    Vec3.normalize( v, v );\\n                    var scale = Math.max( i / nbSamples, 0.1 );\\n                    scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );\\n                    array[ i * 3 + 0 ] = v[ 0 ];\\n                    array[ i * 3 + 1 ] = v[ 1 ];\\n                    array[ i * 3 + 2 ] = v[ 2 ];\\n                    array[ i * 3 + 3 ] = scale;\\n                }\\n            } )( kernel );\\n\\n\\n            stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );\\n            var uniform = stateSet.getUniform( \\'noiseSampling\\' );\\n            if ( uniform === undefined ) {\\n                uniform = Uniform.createFloat2( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ], \\'noiseSampling\\' );\\n                stateSet.addUniform( uniform );\\n            } else {\\n                uniform.set( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ] );\\n                uniform.dirty();\\n            }\\n            var vertexshader = [\\n                \\'\\',\\n                \\'#ifdef GL_ES\\',\\n                \\'precision highp float;\\',\\n                \\'#endif\\',\\n                \\'attribute vec3 Vertex;\\',\\n                \\'attribute vec2 TexCoord0;\\',\\n                \\'varying vec2 FragTexCoord0;\\',\\n                \\'uniform mat4 ModelViewMatrix;\\',\\n                \\'uniform mat4 ProjectionMatrix;\\',\\n                \\'void main(void) {\\',\\n                \\'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);\\',\\n                \\'  FragTexCoord0 = TexCoord0;\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var kernelglsl = [];\\n            for ( var i = 0; i < nbSamples; i++ ) {\\n                kernelglsl.push( \\'kernel[\\' + i + \\'] = vec4(\\' + kernel[ i * 3 ] + \\',\\' + kernel[ i * 3 + 1 ] + \\', \\' + kernel[ i * 3 + 2 ] + \\', \\' + kernel[ i * 3 + 3 ] + \\');\\' );\\n            }\\n            kernelglsl = kernelglsl.join( \\'\\\\n\\' );\\n\\n            //var ssaoRadiusMin = this._sceneRadius * 0.002;\\n            //var ssaoRadiusMax = this._sceneRadius * 0.05;\\n            //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;\\n\\n            var fragmentshader = [\\n                \\'\\',\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'uniform sampler2D Texture1;\\',\\n                \\'uniform sampler2D Texture2;\\',\\n                \\'uniform mat4 projection;\\',\\n                \\'uniform vec2 noiseSampling;\\',\\n                \\'uniform float Power;\\', //\\'+ \\'{ \\'min\\': 0.1, \\'max\\': 16.0, \\'step\\': 0.1, \\'value\\': 1.0 }\\',\\n                \\'uniform float Radius;\\', //\\'+ \\'{ \\'min\\': \\' + ssaoRadiusMin +\\', \\'max\\': \\' + ssaoRadiusMax + \\', \\'step\\': \\'+ ssaoRadiusStep + \\', \\'value\\': 0.01 }\\',\\n                \\'uniform float AngleLimit;\\',\\n                \\'#define NB_SAMPLES \\' + this._nbSamples,\\n                \\'float depth;\\',\\n                \\'vec3 normal;\\',\\n                \\'vec4 position;\\',\\n                \\'vec4 kernel[\\' + nbSamples + \\'];\\',\\n\\n\\n                \\'mat3 computeBasis()\\',\\n                \\'{\\',\\n                \\'  vec2 uvrand = FragTexCoord0*noiseSampling;\\',\\n                \\'  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);\\',\\n                \\'  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));\\',\\n                \\'  vec3 bitangent = cross(normal, tangent);\\',\\n                \\'  mat3 tbn = mat3(tangent, bitangent, normal);\\',\\n                \\'  return tbn;\\',\\n                \\'}\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                kernelglsl,\\n                \\'  position = texture2D(Texture1, FragTexCoord0);\\',\\n                \\'  vec4 p = texture2D(Texture0, FragTexCoord0);\\',\\n                \\'  depth = p.w;\\',\\n                \\'  normal = vec3(p);\\',\\n                \\'  if ( position.w == 0.0) {\\',\\n                \\'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);\\',\\n                \\'     return;\\',\\n                \\'  }\\',\\n                \\'\\',\\n                \\' mat3 tbn = computeBasis();\\',\\n                \\' float occlusion = 0.0;\\',\\n                \\' for (int i = 0; i < NB_SAMPLES; i++) {\\',\\n                \\'    vec3 vecKernel = vec3(kernel[i]);\\',\\n                \\'    vecKernel[2] = max(AngleLimit,vecKernel[2]);\\',\\n                \\'    vec3 sample = tbn * vecKernel;\\',\\n                \\'    vec3 dir = sample;\\',\\n                \\'    float w = dot(dir, normal);\\',\\n                \\'    float dist = 1.0-kernel[i].w;\\',\\n                \\'    w *= dist*dist*Power;\\',\\n                \\'    sample = dir * float(Radius) + position.xyz;\\',\\n\\n                \\'    vec4 offset = projection * vec4(sample,1.0);\\',\\n                \\'    offset.xy /= offset.w;\\',\\n                \\'    offset.xy = offset.xy * 0.5 + 0.5;\\',\\n\\n                \\'    float sample_depth = texture2D(Texture1, offset.xy).z;\\',\\n                \\'    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;\\',\\n                \\'    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;\\',\\n\\n                \\' }\\',\\n                \\' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));\\',\\n                \\' gl_FragColor = vec4(vec3(occlusion),1.0);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vertexshader ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fragmentshader ) );\\n\\n            stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n\\n\\n    Composer.Filter.SSAO8 = function ( options ) {\\n        Composer.Filter.SSAO.call( this, options );\\n    };\\n\\n    Composer.Filter.SSAO8.prototype = MACROUTILS.objectInehrit( Composer.Filter.SSAO.prototype, {\\n        buildGeometry: function ( quad ) {\\n            quad.getAttributes().TexCoord1 = this._texCoord1;\\n            return quad;\\n        },\\n        build: function () {\\n            var stateSet = this._stateSet;\\n            var nbSamples = this._nbSamples;\\n            var kernel = new Array( nbSamples * 4 );\\n            //var angleLimit = this._angleLimit;\\n            ( function ( array ) {\\n                var v = [ 0.0, 0.0, 0.0 ];\\n                for ( var i = 0; i < nbSamples; i++ ) {\\n                    v[ 0 ] = 2.0 * ( Math.random() - 0.5 );\\n                    v[ 1 ] = 2.0 * ( Math.random() - 0.5 );\\n                    v[ 2 ] = Math.random();\\n\\n                    Vec3.normalize( v, v );\\n                    var scale = Math.max( i / nbSamples, 0.1 );\\n                    scale = 0.1 + ( 1.0 - 0.1 ) * ( scale * scale );\\n                    array[ i * 3 + 0 ] = v[ 0 ];\\n                    array[ i * 3 + 1 ] = v[ 1 ];\\n                    array[ i * 3 + 2 ] = v[ 2 ];\\n                    array[ i * 3 + 3 ] = scale;\\n                }\\n            } )( kernel );\\n\\n            //var sizeNoise = this._noiseTextureSize;\\n            stateSet.setTextureAttributeAndModes( 2, this._noiseTexture );\\n            var uniform = stateSet.getUniform( \\'noiseSampling\\' );\\n            if ( uniform === undefined ) {\\n                uniform = Uniform.createFloat2( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ], \\'noiseSampling\\' );\\n                stateSet.addUniform( uniform );\\n            } else {\\n                uniform.set( [ this._size[ 0 ] / this._noiseTextureSize, this._size[ 1 ] / this._noiseTextureSize ] );\\n                uniform.dirty();\\n            }\\n            var vertexshader = [\\n                \\'\\',\\n                \\'#ifdef GL_ES\\',\\n                \\'precision highp float;\\',\\n                \\'#endif\\',\\n                \\'attribute vec3 Vertex;\\',\\n                \\'attribute vec2 TexCoord0;\\',\\n                \\'attribute vec3 TexCoord1;\\',\\n                \\'varying vec2 FragTexCoord0;\\',\\n                \\'varying vec3 FragTexCoord1;\\',\\n                \\'uniform mat4 ModelViewMatrix;\\',\\n                \\'uniform mat4 ProjectionMatrix;\\',\\n                \\'void main(void) {\\',\\n                \\'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex,1.0);\\',\\n                \\'  FragTexCoord0 = TexCoord0;\\',\\n                \\'  FragTexCoord1 = TexCoord1;\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var kernelglsl = [];\\n            for ( var i = 0; i < nbSamples; i++ ) {\\n                kernelglsl.push( \\'kernel[\\' + i + \\'] = vec4(\\' + kernel[ i * 3 ] + \\',\\' + kernel[ i * 3 + 1 ] + \\', \\' + kernel[ i * 3 + 2 ] + \\', \\' + kernel[ i * 3 + 3 ] + \\');\\' );\\n            }\\n            kernelglsl = kernelglsl.join( \\'\\\\n\\' );\\n\\n            //var ssaoRadiusMin = this._sceneRadius * 0.002;\\n            //var ssaoRadiusMax = this._sceneRadius * 0.05;\\n            //var ssaoRadiusStep = ( ssaoRadiusMax - ssaoRadiusMin ) / 200.0;\\n\\n            var fragmentshader = [\\n                \\'\\',\\n                Composer.Filter.defaultFragmentShaderHeader,\\n                \\'varying vec3 FragTexCoord1;\\',\\n                \\'uniform sampler2D Texture1;\\',\\n                \\'uniform sampler2D Texture2;\\',\\n                \\'uniform mat4 projection;\\',\\n                \\'uniform vec2 noiseSampling;\\',\\n                \\'uniform float Power;\\', //\\'+ \\'{ \\'min\\': 0.1, \\'max\\': 16.0, \\'step\\': 0.1, \\'value\\': 1.0 }\\',\\n                \\'uniform float Radius;\\', //\\'+ \\'{ \\'min\\': \\' + ssaoRadiusMin +\\', \\'max\\': \\' + ssaoRadiusMax + \\', \\'step\\': \\'+ ssaoRadiusStep + \\', \\'value\\': 0.01 }\\',\\n                \\'uniform float AngleLimit;\\',\\n                \\'#define NB_SAMPLES \\' + this._nbSamples,\\n                \\'float depth;\\',\\n                \\'float znear, zfar, zrange;\\',\\n                \\'vec3 normal;\\',\\n                \\'vec3 position;\\',\\n                \\'vec4 kernel[\\' + nbSamples + \\'];\\',\\n\\n                Composer.Filter.shaderUtils,\\n\\n                \\'mat3 computeBasis()\\',\\n                \\'{\\',\\n                \\'  vec2 uvrand = FragTexCoord0*noiseSampling;\\',\\n                \\'  //uvrand = rand(gl_FragCoord.xy);\\',\\n                \\'  vec3 rvec = texture2D(Texture2, uvrand*2.0).xyz*2.0-vec3(1.0);\\',\\n                \\'  //vec3 rvec = normalize(vec3(uvrand,0.0));\\',\\n                \\'  vec3 tangent = normalize(rvec - normal * dot(rvec, normal));\\',\\n                \\'  vec3 bitangent = cross(normal, tangent);\\',\\n                \\'  mat3 tbn = mat3(tangent, bitangent, normal);\\',\\n                \\'  return tbn;\\',\\n                \\'}\\',\\n\\n                \\'float getDepthValue(vec4 v) {\\',\\n                \\'  float depth = unpack4x8ToFloat(v);\\',\\n                \\'  depth = depth*zrange+znear;\\',\\n                \\'  //depth = depth*zrange;\\',\\n                \\'  return -depth;\\',\\n                \\'}\\',\\n\\n                \\'void main (void)\\',\\n                \\'{\\',\\n                kernelglsl,\\n                \\'  vec4 p = texture2D(Texture0, FragTexCoord0);\\',\\n                \\'  if (dot(p,p) < 0.001) { \\',\\n                \\'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);\\',\\n                \\'     return;\\',\\n                \\'  }\\',\\n                \\'  znear = projection[3][2] / (projection[2][2]-1.0);\\',\\n                \\'  zfar = projection[3][2] / (projection[2][2]+1.0);\\',\\n                \\'  zrange = zfar-znear;\\',\\n                \\'  depth = getDepthValue(texture2D(Texture1, FragTexCoord0));\\',\\n                //B = (A - znear)/(zfar-znear);\\',\\n                //B = A/(zfar-znear) - znear/(zfar-znear);\\',\\n                //B+ znear/(zfar-znear) = A/(zfar-znear) ;\\',\\n                //(zfar-znear)*(B+ znear/(zfar-znear)) = A ;\\',\\n                //(zfar-znear)*B+ znear = A ;\\',\\n\\n                \\'  if ( -depth < znear) {\\',\\n                \\'     gl_FragColor = vec4(1.0,1.0,1.0,0.0);\\',\\n                \\'     return;\\',\\n                \\'  }\\',\\n\\n                \\'  normal = decodeNormal(unpack4x8To2Float(p));\\',\\n\\n                \\'  position = -FragTexCoord1*depth;\\',\\n                \\'  position.z = -position.z;\\',\\n\\n                \\'\\',\\n                \\' mat3 tbn = computeBasis();\\',\\n                \\' float occlusion = 0.0;\\',\\n                \\' for (int i = 0; i < NB_SAMPLES; i++) {\\',\\n                \\'    vec3 vecKernel = vec3(kernel[i]);\\',\\n                \\'    vecKernel[2] = max(AngleLimit,vecKernel[2]);\\',\\n                \\'    vec3 sample = tbn * vec3(vecKernel);\\',\\n                \\'    vec3 dir = sample;\\',\\n                \\'    float w = dot(dir, normal);\\',\\n                \\'    float dist = 1.0-kernel[i].w;\\',\\n                \\'    w *= dist*dist*Power;\\',\\n                \\'    sample = dir * float(Radius) + position.xyz;\\',\\n\\n                \\'    vec4 offset = projection * vec4(sample,1.0);\\',\\n                \\'    offset.xy /= offset.w;\\',\\n                \\'    offset.xy = offset.xy * 0.5 + 0.5;\\',\\n\\n                \\'    float sample_depth = getDepthValue(texture2D(Texture1, offset.xy));\\',\\n                \\'    float range_check = abs(sample.z - sample_depth) < float(Radius) ? 1.0 : 0.0;\\',\\n                \\'    occlusion += (sample_depth > sample.z ? 1.0 : 0.0) * range_check*w;\\',\\n\\n                \\' }\\',\\n                \\' occlusion = 1.0 - (occlusion / float(NB_SAMPLES));\\',\\n                \\' gl_FragColor = vec4(vec3(occlusion),1.0);\\',\\n                \\'}\\',\\n                \\'\\'\\n            ].join( \\'\\\\n\\' );\\n\\n            var program = new Program(\\n                new Shader( \\'VERTEX_SHADER\\', vertexshader ),\\n                new Shader( \\'FRAGMENT_SHADER\\', fragmentshader ) );\\n\\n            stateSet.setAttributeAndModes( program );\\n            this._dirty = false;\\n        }\\n    } );\\n\\n    return Composer;\\n} );\\n\\n//# sourceURL=/osgUtil/Composer.js\");\n\n",
    "eval(\"define( \\'osgUtil/IntersectVisitor\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/NodeVisitor\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Vec3\\',\\n    \\'osgUtil/TriangleIntersect\\'\\n], function( MACROUTILS, NodeVisitor, Matrix, Vec3, TriangleIntersect ) {\\n\\n    var IntersectVisitor = function() {\\n        NodeVisitor.call( this );\\n        this.matrix = [];\\n        this.hits = [];\\n        this.nodePath = [];\\n    };\\n    IntersectVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n        addLineSegment: function( start, end ) {\\n            this.start = start;\\n            this.end = end;\\n        },\\n        intersectSegmentWithSphere: ( function() {\\n            var sm = [ 0.0, 0.0, 0.0 ];\\n            var se = [ 0.0, 0.0, 0.0 ];\\n            return function( start, end, bsphere ) {\\n                // test for _start inside the bounding sphere\\n                Vec3.sub( start, bsphere.center(), sm );\\n                var c = Vec3.length2( sm ) - bsphere.radius2();\\n                if ( c < 0.0 ) {\\n                    return true;\\n                }\\n\\n                // solve quadratic equation\\n                Vec3.sub( end, start, se );\\n                var a = Vec3.length2( se );\\n                var b = Vec3.dot( sm, se ) * 2.0;\\n                var d = b * b - 4.0 * a * c;\\n                // no intersections if d<0\\n                if ( d < 0.0 ) {\\n                    return false;\\n                }\\n\\n                // compute two solutions of quadratic equation\\n                d = Math.sqrt( d );\\n                var div = 1.0 / ( 2.0 * a );\\n                var r1 = ( -b - d ) * div;\\n                var r2 = ( -b + d ) * div;\\n\\n                // return false if both intersections are before the ray start\\n                if ( r1 <= 0.0 && r2 <= 0.0 ) {\\n                    return false;\\n                }\\n\\n                if ( r1 >= 1.0 && r2 >= 1.0 ) {\\n                    return false;\\n                }\\n                return true;\\n            };\\n        } )(),\\n        pushModelMatrix: function( matrix ) {\\n            if ( this.matrix.length > 0 ) {\\n                var m = Matrix.copy( this.matrix[ this.matrix.length - 1 ], Matrix.create() );\\n                Matrix.preMult( m, matrix );\\n                this.matrix.push( m );\\n            } else {\\n                this.matrix.push( matrix );\\n            }\\n        },\\n        getModelMatrix: function() {\\n            if ( this.matrix.length === 0 ) {\\n                return Matrix.create();\\n            }\\n            return this.matrix[ this.matrix.length - 1 ];\\n        },\\n        popModelMatrix: function() {\\n            return this.matrix.pop();\\n        },\\n        getWindowMatrix: function() {\\n            return this.windowMatrix;\\n        },\\n        getProjectionMatrix: function() {\\n            return this.projectionMatrix;\\n        },\\n        getViewMatrix: function() {\\n            return this.viewMatrix;\\n        },\\n        intersectSegmentWithShape: function( start, end, shape ) {\\n            return shape.intersect( start, end, this.hits, this.nodePath );\\n        },\\n        intersectSegmentWithGeometry: function( start, end, geometry ) {\\n            var ti = new TriangleIntersect();\\n            ti.setNodePath( this.nodePath );\\n            ti.set( start, end );\\n            ti.apply( geometry );\\n            var l = ti.hits.length;\\n            if ( l > 0 ) {\\n                for ( var i = 0; i < l; i++ ) {\\n                    this.hits.push( ti.hits[ i ] );\\n                }\\n                return true;\\n            }\\n            return false;\\n        },\\n        pushCamera: function( camera ) {\\n            // we should support hierarchy of camera\\n            // but right now we want just simple picking on main\\n            // camera\\n            this.projectionMatrix = camera.getProjectionMatrix();\\n            this.viewMatrix = camera.getViewMatrix();\\n\\n            var vp = camera.getViewport();\\n            if ( vp !== undefined ) {\\n                this.windowMatrix = vp.computeWindowMatrix();\\n            }\\n        },\\n        applyCamera: function( camera ) {\\n            // we should support hierarchy of camera\\n            // but right now we want just simple picking on main\\n            // camera\\n            this.pushCamera( camera );\\n            this.traverse( camera );\\n        },\\n\\n        applyNode: function( node, ns, ne ) {\\n            if ( node.getMatrix ) {\\n                this.pushModelMatrix( node.getMatrix() );\\n            }\\n\\n            if ( node.primitives ) {\\n                var kdtree = node.getShape();\\n                if ( kdtree ) {\\n                    this.intersectSegmentWithShape( ns, ne, kdtree );\\n                } else\\n                    this.intersectSegmentWithGeometry( ns, ne, node );\\n            }\\n\\n            if ( node.traverse ) {\\n                this.traverse( node );\\n            }\\n\\n            if ( node.getMatrix ) {\\n                this.popModelMatrix();\\n            }\\n        },\\n\\n        transformRay: (function() {\\n            var inv = Matrix.create();\\n            return function(tStart, tEnd) {\\n                Matrix.copy(this.getWindowMatrix(), inv);\\n                Matrix.preMult(inv, this.getProjectionMatrix());\\n                Matrix.preMult(inv, this.getViewMatrix());\\n                Matrix.preMult(inv, this.getModelMatrix());\\n\\n                var valid = Matrix.inverse(inv, inv);\\n                // if matrix is invalid do nothing on this node\\n                if (!valid) {\\n                    return false;\\n                }\\n\\n                Matrix.transformVec3(inv, this.start, tStart);\\n                Matrix.transformVec3(inv, this.end, tEnd);\\n\\n                return true;\\n            };\\n        })(),\\n        apply: ( function() {\\n            var ns = [ 0.0, 0.0, 0.0 ];\\n            var ne = [ 0.0, 0.0, 0.0 ];\\n            return function( node ) {\\n                // World space Operation\\n                if ( this.transformRay( ns, ne ) === false ) {\\n                    return;\\n                }\\n\\n                if ( this.enterNode( node, ns, ne ) === false ) {\\n                    return;\\n                }\\n\\n                if ( node.getViewMatrix ) { // Camera/View\\n                    this.applyCamera( node );\\n                } else {\\n                    // now on to local space\\n                    this.applyNode( node, ns, ne );\\n                }\\n            };\\n        } )(),\\n\\n        enterNode: function( node, ns, ne ) {\\n            return this.intersectSegmentWithSphere( ns, ne, node.getBound() );\\n        }\\n    } );\\n\\n    return IntersectVisitor;\\n} );\\n\\n//# sourceURL=/osgUtil/IntersectVisitor.js\");\n\n",
    "eval(\"define( \\'osgUtil/ParameterVisitor\\',[\\n    \\'osg/Utils\\',\\n    \\'osg/Notify\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/NodeVisitor\\'\\n], function ( MACROUTILS, Notify, Uniform, NodeVisitor ) {\\n\\n    var ArraySlider = function ( params ) {\\n        if ( params !== undefined ) {\\n            if ( params.object !== undefined && params.field !== undefined ) {\\n                this.createInternalSlider( params );\\n            }\\n            this._uniform = this.createInternalSliderUniform( params );\\n        }\\n    };\\n\\n    ArraySlider.prototype = {\\n        setTargetHTML: function ( target ) {\\n            this.parent = target;\\n        },\\n        addToDom: function ( content ) {\\n            var mydiv = document.createElement( \\'div\\' );\\n            mydiv.innerHTML = content;\\n            this.parent.appendChild( mydiv );\\n        },\\n\\n        getValue: function ( name ) {\\n            if ( window.localStorage ) {\\n                var value = window.localStorage.getItem( name );\\n                return value;\\n            }\\n            return null;\\n        },\\n        setValue: function ( name, value ) {\\n            if ( window.localStorage ) {\\n                window.localStorage.setItem( name, value );\\n            }\\n        },\\n        createHTMLSlider: function ( param, value, nameIndex, cbnameIndex ) {\\n            var input = \\'<div>NAME [ MIN - MAX ] <input type=\\\"range\\\" min=\\\"MIN\\\" max=\\\"MAX\\\" value=\\\"VALUE\\\" step=\\\"STEP\\\" onchange=\\\"ONCHANGE\\\" /><span id=\\\"UPDATE\\\"></span></div>\\';\\n            var min = param.min;\\n            var max = param.max;\\n            var step = param.step;\\n            var name = nameIndex;\\n            var cbname = cbnameIndex;\\n            var onchange = cbname + \\'(this.value)\\';\\n            input = input.replace( /MIN/g, min );\\n            input = input.replace( /MAX/g, ( max + step ) );\\n            input = input.replace( \\'STEP\\', step );\\n            input = input.replace( \\'VALUE\\', value );\\n            input = input.replace( /NAME/g, name );\\n            input = input.replace( /UPDATE/g, cbname );\\n            input = input.replace( \\'ONCHANGE\\', onchange );\\n            return input;\\n        },\\n\\n        createUniformFunction: function ( param, name, index, uniform, cbnameIndex ) {\\n            var self = this;\\n            return ( function () {\\n                var cname = name;\\n                var cindex = index;\\n                var cuniform = uniform;\\n                var id = cbnameIndex;\\n                var func = function ( value ) {\\n                    cuniform.get()[ cindex ] = value;\\n                    cuniform.dirty();\\n                    Notify.debug( cname + \\' value \\' + value );\\n                    document.getElementById( cbnameIndex ).innerHTML = Number( value ).toFixed( 4 );\\n                    self.setValue( id, value );\\n                    if ( param.onchange !== undefined ) {\\n                        param.onchange( cuniform.get() );\\n                    }\\n                    // store the value to localstorage\\n                };\\n                return func;\\n            } )();\\n        },\\n\\n        createFunction: function ( param, name, index, object, field, cbnameIndex ) {\\n            var self = this;\\n            return ( function () {\\n                var cname = name;\\n                //var cindex = index;\\n                var cfield = field;\\n                var id = cbnameIndex;\\n                var obj = object;\\n                var func = function ( value ) {\\n                    if ( typeof ( value ) === \\'string\\' ) {\\n                        value = parseFloat( value );\\n                    }\\n\\n                    if ( typeof ( object[ cfield ] ) === \\'number\\' ) {\\n                        obj[ cfield ] = value;\\n                    } else {\\n                        obj[ cfield ][ index ] = value;\\n                    }\\n                    Notify.debug( cname + \\' value \\' + value );\\n                    document.getElementById( cbnameIndex ).innerHTML = Number( value ).toFixed( 4 );\\n                    self.setValue( id, value );\\n                    if ( param.onchange !== undefined ) {\\n                        param.onchange( obj[ cfield ] );\\n                    }\\n\\n                    // store the value to localstorage\\n                };\\n                return func;\\n            } )();\\n        },\\n\\n        getCallbackName: function ( name, prgId ) {\\n            return \\'change_\\' + prgId + \\'_\\' + name;\\n        },\\n\\n        copyDefaultValue: function ( param ) {\\n            var uvalue = param.value;\\n            if ( Array.isArray( param.value ) ) {\\n                uvalue = param.value.slice();\\n            } else {\\n                uvalue = [ uvalue ];\\n            }\\n            return uvalue;\\n        },\\n\\n        createInternalSliderUniform: function ( param ) {\\n            var uvalue = param.value;\\n            var uniform = param.uniform;\\n            if ( uniform === undefined ) {\\n                var type = param.type;\\n                type = type.charAt( 0 ).toUpperCase() + type.slice( 1 );\\n                uniform = Uniform[ \\'create\\' + type ]( uvalue, param.name );\\n            }\\n\\n            var cbname = this.getCallbackName( param.name, param.id );\\n            var dim = uvalue.length;\\n            for ( var i = 0; i < dim; i++ ) {\\n\\n                var istring = i.toString();\\n                var nameIndex = param.name + istring;\\n                var cbnameIndex = cbname + istring;\\n\\n                // default value\\n                var value = uvalue[ i ];\\n\\n                // read local storage value if it exist\\n                var readValue = this.getValue( cbnameIndex );\\n                if ( readValue !== null ) {\\n                    value = readValue;\\n                } else if ( param.uniform && param.uniform.get()[ i ] !== undefined ) {\\n                    // read value from original uniform\\n                    value = param.uniform.get()[ i ];\\n                }\\n\\n                var dom = this.createHTMLSlider( param, value, nameIndex, cbnameIndex );\\n                this.addToDom( dom );\\n                window[ cbnameIndex ] = this.createUniformFunction( param, nameIndex, i, uniform, cbnameIndex );\\n                Notify.log( nameIndex + \\' \\' + value );\\n                window[ cbnameIndex ]( value );\\n            }\\n            this.uniform = uniform;\\n            return uniform;\\n        },\\n\\n        createInternalSlider: function ( param ) {\\n            var uvalue = param.value;\\n            var name = param.name;\\n            var id = param.id;\\n            var dim = uvalue.length;\\n            var cbname = this.getCallbackName( name, id );\\n            var object = param.object;\\n            var field = param.field;\\n            for ( var i = 0; i < dim; i++ ) {\\n\\n                var istring = i.toString();\\n                var nameIndex = name + istring;\\n                var cbnameIndex = cbname + istring;\\n\\n                // default value\\n                var value = uvalue[ i ];\\n\\n                // read local storage value if it exist\\n                var readValue = this.getValue( cbnameIndex );\\n                if ( readValue !== null ) {\\n                    value = readValue;\\n                } else {\\n                    if ( typeof object[ field ] === \\'number\\' ) {\\n                        value = object[ field ];\\n                    } else {\\n                        value = object[ field ][ i ];\\n                    }\\n                }\\n\\n                var dom = this.createHTMLSlider( param, value, nameIndex, cbnameIndex );\\n                this.addToDom( dom );\\n                window[ cbnameIndex ] = this.createFunction( param, nameIndex, i, object, field, cbnameIndex );\\n                Notify.log( nameIndex + \\' \\' + value );\\n                window[ cbnameIndex ]( value );\\n            }\\n        },\\n\\n        createSlider: function ( param ) {\\n            if ( param.html !== undefined ) {\\n                this.setTargetHTML( param.html );\\n            }\\n            if ( param.id === undefined ) {\\n                param.id = param.name;\\n            }\\n            param.value = this.copyDefaultValue( param );\\n            if ( param.type !== undefined ) {\\n                return this.createInternalSliderUniform( param );\\n            } else {\\n                if ( param.object === undefined ) {\\n                    param.object = {\\n                        \\'data\\': param.value\\n                    };\\n                    param.field = \\'data\\';\\n                }\\n                return this.createInternalSlider( param );\\n            }\\n        }\\n    };\\n\\n\\n    var ParameterVisitor = function () {\\n        NodeVisitor.call( this );\\n\\n        this.arraySlider = new ArraySlider();\\n        this.setTargetHTML( document.body );\\n    };\\n\\n    ParameterVisitor.createSlider = function ( param ) {\\n        ( new ArraySlider() ).createSlider( param );\\n    };\\n\\n    ParameterVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n\\n        setTargetHTML: function ( html ) {\\n            this.targetHTML = html;\\n            this.arraySlider.setTargetHTML( this.targetHTML );\\n        },\\n\\n        getUniformList: function ( str, map ) {\\n\\n            //var txt=\\'uniform float Power; // { min: 0.1, max: 2.0, step: 0.1, value: [0,0,0]  }\\';\\n\\n            var re1 = \\'(uniform)\\'; // Word 1\\n            var re2 = \\'.*?\\'; // Non-greedy match on filler\\n            var re3 = \\'((?:[a-z][a-z]+))\\'; // Word 2\\n            var re4 = \\'.*?\\'; // Non-greedy match on filler\\n            var re5 = \\'((?:[a-z][a-z]+))\\'; // Word 3\\n            var re6 = \\'.*?\\'; // Non-greedy match on filler\\n            var re7 = \\'.\\'; // Uninteresting: c\\n            var re8 = \\'.*?\\'; // Non-greedy match on filler\\n            var re9 = \\'.\\'; // Uninteresting: c\\n            var re10 = \\'.*?\\'; // Non-greedy match on filler\\n            var re11 = \\'(.)\\'; // Any Single Character 1\\n            var re12 = \\'(.)\\'; // Any Single Character 2\\n            var re13 = \\'.*?\\'; // Non-greedy match on filler\\n            var re14 = \\'(\\\\\\\\{.*?\\\\\\\\})\\'; // Curly Braces 1\\n\\n            var p = new RegExp( re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9 + re10 + re11 + re12 + re13 + re14, [ \\'g\\' ] );\\n            var r = str.match( p );\\n            var list = map;\\n\\n            var createGetter = function( value ) {\\n                return function() { return value; };\\n            };\\n\\n            if ( r !== null ) {\\n                var re = new RegExp( re1 + re2 + re3 + re4 + re5 + re6 + re7 + re8 + re9 + re10 + re11 + re12 + re13 + re14, [ \\'i\\' ] );\\n                for ( var i = 0, l = r.length; i < l; i++ ) {\\n                    var result = r[ i ].match( re );\\n                    //var result = p.exec(str);\\n                    if ( result !== null ) {\\n                        //var word1 = result[ 1 ];\\n                        var type = result[ 2 ];\\n                        var name = result[ 3 ];\\n                        //var c1 = result[ 4 ];\\n                        //var c2 = result[ 5 ];\\n                        var json = result[ 6 ];\\n\\n                        var param = JSON.parse( json );\\n                        param.type = type;\\n                        param.name = name;\\n                        var value = param.value;\\n                        param.value = createGetter( value );\\n                        list[ name ] = param;\\n                    }\\n                }\\n            }\\n            return list;\\n        },\\n\\n        getUniformFromStateSet: function ( stateSet, uniformMap ) {\\n            var maps = stateSet.getUniformList();\\n            if ( !maps ) {\\n                return;\\n            }\\n            var keys = window.Object.keys( uniformMap );\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                var k = keys[ i ];\\n                // get the first one found in the tree\\n                if ( maps[ k ] !== undefined && uniformMap[ k ].uniform === undefined ) {\\n                    uniformMap[ k ].uniform = maps[ k ].object;\\n                }\\n            }\\n        },\\n\\n        findExistingUniform: function ( node, uniformMap ) {\\n            var BackVisitor = function () {\\n                NodeVisitor.call( this, NodeVisitor.TRAVERSE_PARENTS );\\n            };\\n            BackVisitor.prototype = MACROUTILS.objectInehrit( NodeVisitor.prototype, {\\n                setUniformMap: function ( map ) {\\n                    this.uniformMap = map;\\n                },\\n                apply: function ( node ) {\\n                    var stateSet = node.getStateSet();\\n                    if ( stateSet ) {\\n                        ParameterVisitor.prototype.getUniformFromStateSet( stateSet, this.uniformMap );\\n                    }\\n                    this.traverse( node );\\n                }\\n            } );\\n            var visitor = new BackVisitor();\\n            visitor.setUniformMap( uniformMap );\\n            node.accept( visitor );\\n        },\\n\\n        applyProgram: function ( node, stateset ) {\\n            var program = stateset.getAttribute( \\'Program\\' );\\n            var programName = program.getName();\\n            //var string = program.getVertexShader().getText();\\n            var uniformMap = {};\\n            this.getUniformList( program.getVertexShader().getText(), uniformMap );\\n            this.getUniformList( program.getFragmentShader().getText(), uniformMap );\\n\\n\\n            var keys = window.Object.keys( uniformMap );\\n\\n            if ( programName === undefined ) {\\n                var hashCode = function ( str ) {\\n                    var hash = 0;\\n                    var chara = 0;\\n                    if ( str.length === 0 ) {\\n                        return hash;\\n                    }\\n                    for ( i = 0; i < str.length; i++ ) {\\n                        chara = str.charCodeAt( i );\\n                        /*jshint bitwise: false */\\n                        hash = ( ( hash << 5 ) - hash ) + chara;\\n                        hash = hash & hash; // Convert to 32bit integer\\n                        /*jshint bitwise: true */\\n                    }\\n                    if ( hash < 0 ) {\\n                        hash = -hash;\\n                    }\\n                    return hash;\\n                };\\n                var str = keys.join( \\'\\' );\\n                programName = hashCode( str ).toString();\\n            }\\n\\n            this.findExistingUniform( node, uniformMap );\\n\\n            var addedSlider = false;\\n            for ( var i = 0; i < keys.length; i++ ) {\\n                var k = keys[ i ];\\n                var entry = uniformMap[ k ];\\n                var type = entry.type;\\n                var name = entry.name;\\n                entry.id = programName;\\n                var uniform = this.arraySlider.createSlider( entry );\\n                if ( false ) {\\n                    uniform = this.arraySlider.createSlider( {\\n                        name: name,\\n                        type: type,\\n                        id: programName,\\n                        uniform: entry.uniform\\n                    } );\\n                }\\n                if ( entry.uniform === undefined && uniform ) {\\n                    stateset.addUniform( uniform );\\n                }\\n                addedSlider = true;\\n            }\\n\\n            // add a separator\\n            if ( addedSlider ) {\\n                var mydiv = document.createElement( \\'div\\' );\\n                mydiv.innerHTML = \\'<p> </p>\\';\\n                this.targetHTML.appendChild( mydiv );\\n            }\\n\\n            Notify.log( uniformMap );\\n        },\\n\\n\\n        applyStateSet: function ( node, stateset ) {\\n            if ( stateset.getAttribute( \\'Program\\' ) !== undefined ) {\\n                this.applyProgram( node, stateset );\\n            }\\n        },\\n\\n        apply: function ( node ) {\\n            var element = this.targetHTML;\\n            if ( element === undefined || element === null ) {\\n                return;\\n            }\\n\\n            var st = node.getStateSet();\\n            if ( st !== undefined ) {\\n                this.applyStateSet( node, st );\\n            }\\n\\n            this.traverse( node );\\n        }\\n    } );\\n\\n    return ParameterVisitor;\\n} );\\n\\n//# sourceURL=/osgUtil/ParameterVisitor.js\");\n\n",
    "eval(\"define( \\'osgUtil/Oculus\\',[\\n    \\'osg/Camera\\',\\n    \\'osg/FrameBufferObject\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Node\\',\\n    \\'osg/Program\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Shape\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Transform\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Viewport\\'\\n], function ( Camera, FrameBufferObject, Matrix, Node, Program, Shader, Shape, Texture, Transform, Uniform, Viewport ) {\\n\\n    \\'use strict\\';\\n\\n    var UpdateRttCameraCallback = function ( rootView, offsetView ) {\\n        this._rootView = rootView;\\n        this._offsetView = offsetView;\\n    };\\n\\n    UpdateRttCameraCallback.prototype = {\\n        update: function ( node /*, nv */ ) {\\n            var nodeView = node.getViewMatrix();\\n            Matrix.mult( this._offsetView, this._rootView, nodeView );\\n            return true;\\n        }\\n    };\\n\\n    var setupOculus = function ( worldFactor, HMD, oculusUniforms, oculusMatrices ) {\\n        var aspect = HMD.hResolution / ( 2.0 * HMD.vResolution );\\n        var r = -1.0 - ( 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize );\\n        var distScale = ( HMD.distortionK[ 0 ] + HMD.distortionK[ 1 ] * Math.pow( r, 2 ) + HMD.distortionK[ 2 ] * Math.pow( r, 4 ) + HMD.distortionK[ 3 ] * Math.pow( r, 6 ) );\\n        var fov = ( 180.0 / Math.PI ) * 2.0 * Math.atan2( HMD.vScreenSize * distScale, 2.0 * HMD.eyeToScreenDistance );\\n\\n        var proj = Matrix.makePerspective( fov, aspect, 0.3, 10000.0, Matrix.create() );\\n        var hOffset = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.interpupillaryDistance * 0.5 ) / HMD.hScreenSize;\\n        var lensShift = 4.0 * ( HMD.hScreenSize * 0.25 - HMD.lensSeparationDistance * 0.5 ) / HMD.hScreenSize;\\n\\n        oculusMatrices.projectionLeft = Matrix.preMult( Matrix.makeTranslate( hOffset, 0.0, 0.0, Matrix.create() ), proj );\\n        oculusMatrices.projectionRight = Matrix.preMult( Matrix.makeTranslate( -hOffset, 0.0, 0.0, Matrix.create() ), proj );\\n        oculusMatrices.viewLeft = Matrix.makeTranslate( worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0, Matrix.create() );\\n        oculusMatrices.viewRight = Matrix.makeTranslate( -worldFactor * HMD.interpupillaryDistance * 0.5, 0.0, 0.0, Matrix.create() );\\n\\n        oculusUniforms.lensCenterLeft = [ lensShift, 0.0 ];\\n        oculusUniforms.lensCenterRight = [ -lensShift, 0.0 ];\\n        oculusUniforms.hmdWarpParam = HMD.distortionK;\\n        oculusUniforms.chromAbParam = HMD.chromaAbParameter;\\n        oculusUniforms.scaleIn = [ 1.0, 1.0 / aspect ];\\n        oculusUniforms.scale = [ 1.0 / distScale, 1.0 * aspect / distScale ];\\n    };\\n\\n    var getOculusShader = function () {\\n        var vertexshader = [\\n            \\'\\',\\n            \\'#ifdef GL_ES\\',\\n            \\'precision highp float;\\',\\n            \\'#endif\\',\\n\\n            \\'attribute vec3 Vertex;\\',\\n            \\'attribute vec3 Normal;\\',\\n            \\'attribute vec2 TexCoord0;\\',\\n\\n            \\'uniform mat4 ModelViewMatrix;\\',\\n            \\'uniform mat4 ProjectionMatrix;\\',\\n            \\'uniform mat4 NormalMatrix;\\',\\n\\n            \\'varying vec2 vTexCoord;\\',\\n\\n            \\'void main(void) {\\',\\n            \\'  vTexCoord = TexCoord0;\\',\\n            \\'  gl_Position = ProjectionMatrix * ModelViewMatrix * vec4(Vertex, 1.0);\\',\\n            \\'}\\'\\n        ].join( \\'\\\\n\\' );\\n\\n        var fragmentshader = [\\n            \\'\\',\\n            \\'#ifdef GL_ES\\',\\n            \\'precision highp float;\\',\\n            \\'#endif\\',\\n\\n            \\'uniform vec2 uScale;\\',\\n            \\'uniform vec2 uScaleIn;\\',\\n            \\'uniform vec2 uLensCenter;\\',\\n            \\'uniform vec4 uHmdWarpParam;\\',\\n            \\'uniform vec4 uChromAbParam;\\',\\n            \\'uniform sampler2D Texture0;\\',\\n\\n            \\'varying vec2 vTexCoord;\\',\\n\\n            // from http://paradise.untergrund.net/tmp/demoshit/examples/js/effects/OculusRiftEffect.js\\n            \\'void main(void) {\\',\\n            \\'  vec2 uv = (vTexCoord * 2.0) - 1.0;\\', // range from [0,1] to [-1,1]\\n            \\'  vec2 theta = (uv - uLensCenter) * uScaleIn;\\',\\n            \\'  float rSq = theta.x * theta.x + theta.y * theta.y;\\',\\n            \\'  vec2 rvector = theta * (uHmdWarpParam.x + uHmdWarpParam.y * rSq + uHmdWarpParam.z * rSq * rSq + uHmdWarpParam.w * rSq * rSq * rSq);\\',\\n            \\'  vec2 rBlue = rvector * (uChromAbParam.z + uChromAbParam.w * rSq);\\',\\n            \\'  vec2 tcBlue = (uLensCenter + uScale * rBlue);\\',\\n            \\'  tcBlue = (tcBlue + 1.0) * 0.5;\\', // range from [-1,1] to [0,1]\\n            \\'  if (any(bvec2(clamp(tcBlue, vec2(0.0, 0.0), vec2(1.0, 1.0)) - tcBlue))) {\\',\\n            \\'    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\\',\\n            \\'    return;\\',\\n            \\'  }\\',\\n            \\'  vec2 tcGreen = uLensCenter + uScale * rvector;\\',\\n            \\'  tcGreen = (tcGreen + 1.0) * 0.5;\\', // range from [-1,1] to [0,1]\\n            \\'  vec2 rRed = rvector * (uChromAbParam.x + uChromAbParam.y * rSq);\\',\\n            \\'  vec2 tcRed = uLensCenter + uScale * rRed;\\',\\n            \\'  tcRed = (tcRed + 1.0) * 0.5;\\', // range from [-1,1] to [0,1]\\n            \\'  gl_FragColor = vec4(texture2D(Texture0, tcRed).r, texture2D(Texture0, tcGreen).g, texture2D(Texture0, tcBlue).b, 1);\\',\\n            \\'}\\',\\n            \\'\\'\\n        ].join( \\'\\\\n\\' );\\n\\n        var program = new Program(\\n            new Shader( Shader.VERTEX_SHADER, vertexshader ),\\n            new Shader( Shader.FRAGMENT_SHADER, fragmentshader ) );\\n\\n        return program;\\n    };\\n\\n    var createTextureRtt = function ( rttSize ) {\\n        var rttTexture = new Texture();\\n        rttTexture.setTextureSize( rttSize[ 0 ], rttSize[ 1 ] );\\n        rttTexture.setMinFilter( \\'LINEAR\\' );\\n        rttTexture.setMagFilter( \\'LINEAR\\' );\\n        return rttTexture;\\n    };\\n\\n    var createQuadRtt = function ( isLeftCam, texture, ocUnifs ) {\\n        var quad = Shape.createTexturedQuadGeometry( -0.5, -0.5, 0, 1, 0, 0, 0, 1, 0 );\\n        var orStateSet = quad.getOrCreateStateSet();\\n        orStateSet.setTextureAttributeAndMode( 0, texture );\\n        orStateSet.setAttributeAndMode( getOculusShader() );\\n        orStateSet.addUniform( new Uniform.createFloat2( ocUnifs.scale, \\'uScale\\' ) );\\n        orStateSet.addUniform( new Uniform.createFloat2( ocUnifs.scaleIn, \\'uScaleIn\\' ) );\\n        orStateSet.addUniform( new Uniform.createFloat2( isLeftCam ? ocUnifs.lensCenterLeft : ocUnifs.lensCenterRight, \\'uLensCenter\\' ) );\\n        orStateSet.addUniform( new Uniform.createFloat4( ocUnifs.hmdWarpParam, \\'uHmdWarpParam\\' ) );\\n        orStateSet.addUniform( new Uniform.createFloat4( ocUnifs.chromAbParam, \\'uChromAbParam\\' ) );\\n        return quad;\\n    };\\n\\n    var createOrthoRtt = function ( left, viewportSize, canvasSize ) {\\n        var orthoCamera = new Camera();\\n        var vw = viewportSize[ 0 ];\\n        var vh = viewportSize[ 1 ];\\n        var cw = canvasSize[ 0 ];\\n        var ch = canvasSize[ 1 ];\\n        if ( left )\\n            orthoCamera.setViewport( new Viewport( 0.5 * cw - vw, 0.5 * ( ch - vh ), vw, vh ) );\\n        else\\n            orthoCamera.setViewport( new Viewport( 0.5 * cw, 0.5 * ( ch - vh ), vw, vh ) );\\n        Matrix.makeOrtho( -0.5, 0.5, -0.5, 0.5, -5, 5, orthoCamera.getProjectionMatrix() );\\n        orthoCamera.setRenderOrder( Camera.NESTED_RENDER, 0 );\\n        orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );\\n        return orthoCamera;\\n    };\\n\\n    var createCameraRtt = function ( texture, projMatrix ) {\\n        var camera = new Camera();\\n        camera.setName( \\'rtt camera\\' );\\n        camera.setViewport( new Viewport( 0, 0, texture.getWidth(), texture.getHeight() ) );\\n        camera.setProjectionMatrix( projMatrix );\\n        camera.setClearColor( [ 0.0, 0.0, 0.0, 0.0 ] );\\n        camera.setRenderOrder( Camera.POST_RENDER, 0 );\\n        camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture, 0 );\\n        camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\\n        camera.setReferenceFrame( Transform.ABSOLUTE_RF );\\n        return camera;\\n    };\\n\\n    var Oculus = {};\\n\\n    Oculus.createScene = function ( viewer, rttScene, HMDconfig ) {\\n        var HMD = Oculus.getDefaultConfig( HMDconfig );\\n        var rttSize = [ HMD.hResolution, HMD.vResolution ];\\n        var viewportSize = [ HMD.hResolution * 0.5, HMD.vResolution ];\\n        var vp = viewer.getCamera().getViewport();\\n        var canvasSize = [ vp.width(), vp.height() ];\\n\\n        var worldFactor = 1.0; //world unit\\n        var oculusUniforms = {};\\n        var oculusMatrices = {};\\n        setupOculus( worldFactor, HMD, oculusUniforms, oculusMatrices );\\n\\n        var rootViewMatrix = viewer.getCamera().getViewMatrix();\\n\\n        var root = new Node();\\n\\n        var rttTextureLeft = createTextureRtt( rttSize );\\n        var rttCamLeft = createCameraRtt( rttTextureLeft, oculusMatrices.projectionLeft );\\n        var quadTextLeft = createQuadRtt( true, rttTextureLeft, oculusUniforms );\\n        var orthoCameraLeft = createOrthoRtt( true, viewportSize, canvasSize );\\n        rttCamLeft.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, oculusMatrices.viewLeft ) );\\n\\n        var rttTextureRight = createTextureRtt( rttSize );\\n        var rttCamRight = createCameraRtt( rttTextureRight, oculusMatrices.projectionRight );\\n        var quadTextRight = createQuadRtt( false, rttTextureRight, oculusUniforms );\\n        var orthoCameraRight = createOrthoRtt( false, viewportSize, canvasSize );\\n        rttCamRight.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, oculusMatrices.viewRight ) );\\n\\n        rttCamLeft.addChild( rttScene );\\n        rttCamRight.addChild( rttScene );\\n\\n        orthoCameraLeft.addChild( quadTextLeft );\\n        orthoCameraRight.addChild( quadTextRight );\\n\\n        root.addChild( rttCamLeft );\\n        root.addChild( rttCamRight );\\n\\n        root.addChild( orthoCameraLeft );\\n        root.addChild( orthoCameraRight );\\n\\n        return root;\\n    };\\n\\n    Oculus.getDefaultConfig = function ( hmdConfig ) {\\n        // FOV: 103.506416\\n        // vScreenCenter: 0.03645\\n\\n        // Oculus Rift DK2\\n        var hmd = {\\n            hResolution: 1920,\\n            vResolution: 1080,\\n            hScreenSize: 0.1296,\\n            vScreenSize: 0.0729,\\n            interpupillaryDistance: 0.064,\\n            lensSeparationDistance: 0.0635,\\n            eyeToScreenDistance: 0.04,\\n            distortionK: [ 1.0, 0.22, 0.13, 0.02 ],\\n            chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0 ]\\n        };\\n        if ( hmdConfig === 2 || hmdConfig === undefined )\\n            return hmd;\\n        if ( hmdConfig === 1 ) {\\n            // Oculus Rift DK1\\n            hmd.hResolution = 1280;\\n            hmd.vResolution = 800;\\n            hmd.hScreenSize = 0.14976;\\n            hmd.vScreenSize = 0.0936;\\n            hmd.lensSeparationDistance = 0.064;\\n            hmd.eyeToScreenDistance = 0.041;\\n            hmd.distortionK = [ 1.0, 0.22, 0.24, 0.0 ];\\n            return hmd;\\n        }\\n        // custom param\\n        if ( hmdConfig.hResolution !== undefined ) hmd.hResolution = hmdConfig.hResolution;\\n        if ( hmdConfig.vResolution !== undefined ) hmd.vResolution = hmdConfig.vResolution;\\n        if ( hmdConfig.hScreenSize !== undefined ) hmd.hScreenSize = hmdConfig.hScreenSize;\\n        if ( hmdConfig.vScreenSize !== undefined ) hmd.vScreenSize = hmdConfig.vScreenSize;\\n        if ( hmdConfig.interpupillaryDistance !== undefined ) hmd.interpupillaryDistance = hmdConfig.interpupillaryDistance;\\n        if ( hmdConfig.lensSeparationDistance !== undefined ) hmd.lensSeparationDistance = hmdConfig.lensSeparationDistance;\\n        if ( hmdConfig.eyeToScreenDistance !== undefined ) hmd.eyeToScreenDistance = hmdConfig.eyeToScreenDistance;\\n        if ( hmdConfig.distortionK !== undefined ) hmd.distortionK = hmdConfig.distortionK;\\n        if ( hmdConfig.chromaAbParameter !== undefined ) hmd.chromaAbParameter = hmdConfig.chromaAbParameter;\\n\\n        return hmd;\\n    };\\n\\n    return Oculus;\\n\\n} );\\n\\n//# sourceURL=/osgUtil/Oculus.js\");\n\n",
    "eval(\"define( \\'osgUtil/WebVR\\',[\\n    \\'osg/Camera\\',\\n    \\'osg/FrameBufferObject\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Node\\',\\n    \\'osg/Program\\',\\n    \\'osg/Projection\\',\\n    \\'osg/Shader\\',\\n    \\'osg/Shape\\',\\n    \\'osg/Texture\\',\\n    \\'osg/Transform\\',\\n    \\'osg/Uniform\\',\\n    \\'osg/Viewport\\',\\n    \\'osgUtil/Composer\\'\\n], function ( Camera, FrameBufferObject, Matrix, Node, Program, Projection, Shader, Shape, Texture, Transform, Uniform, Viewport, Composer ) {\\n\\n    \\'use strict\\';\\n\\n    var UpdateRttCameraCallback = function ( rootView, offsetView ) {\\n        this._rootView = rootView;\\n        this._offsetView = offsetView;\\n    };\\n\\n    UpdateRttCameraCallback.prototype = {\\n        update: function ( node /*, nv */ ) {\\n            var nodeView = node.getViewMatrix();\\n            Matrix.mult( this._offsetView, this._rootView, nodeView );\\n            return true;\\n        }\\n    };\\n\\n    function perspectiveMatrixFromVRFieldOfView( fov, zNear, zFar ) {\\n\\n        var matrix = new Matrix.create();\\n\\n        var upTan = Math.tan( fov.upDegrees * Math.PI / 180.0 );\\n        var downTan = Math.tan( fov.downDegrees * Math.PI / 180.0 );\\n        var leftTan = Math.tan( fov.leftDegrees * Math.PI / 180.0 );\\n        var rightTan = Math.tan( fov.rightDegrees * Math.PI / 180.0 );\\n\\n        var xScale = 2.0 / ( leftTan + rightTan );\\n        var yScale = 2.0 / ( upTan + downTan );\\n\\n        // return Matrix.makeFrustum( xmin, xmax, ymin, ymax, znear, zfar, result );\\n\\n        matrix[ 0 ] = xScale;\\n        matrix[ 4 ] = 0.0;\\n        matrix[ 8 ] = -( ( leftTan - rightTan ) * xScale * 0.5 );\\n        matrix[ 12 ] = 0.0;\\n\\n        matrix[ 1 ] = 0.0;\\n        matrix[ 5 ] = yScale;\\n        matrix[ 9 ] = ( ( upTan - downTan ) * yScale * 0.5 );\\n        matrix[ 13 ] = 0.0;\\n\\n        matrix[ 2 ] = 0.0;\\n        matrix[ 6 ] = 0.0;\\n        matrix[ 10 ] = zFar / ( zNear - zFar );\\n        matrix[ 14 ] = ( zFar * zNear ) / ( zNear - zFar );\\n\\n        matrix[ 3 ] = 0.0;\\n        matrix[ 7 ] = 0.0;\\n        matrix[ 11 ] = -1.0;\\n        matrix[ 15 ] = 0.0;\\n\\n        return matrix;\\n    }\\n\\n\\n    var createTexture = function ( size ) {\\n        var texture = new Texture();\\n        texture.setTextureSize( size.width, size.height );\\n        texture.setMinFilter( \\'LINEAR\\' );\\n        texture.setMagFilter( \\'LINEAR\\' );\\n        return texture;\\n    };\\n\\n    function getAssembleShader() {\\n\\n        var fragmentShader = [\\n            \\'#ifdef GL_ES\\',\\n            \\'   precision highp float;\\',\\n            \\'#endif\\',\\n            \\'varying vec2 FragTexCoord0;\\',\\n            \\'uniform sampler2D leftEyeTexture;\\',\\n            \\'uniform sampler2D rightEyeTexture;\\',\\n\\n            \\'void main() {\\',\\n            \\'   if (FragTexCoord0.x < 0.5)\\',\\n            \\'       gl_FragColor = texture2D(leftEyeTexture, vec2(FragTexCoord0.x * 2.0, FragTexCoord0.y));\\',\\n            \\'   else\\',\\n            \\'       gl_FragColor = texture2D(rightEyeTexture, vec2(FragTexCoord0.x * 2.0 - 1.0, FragTexCoord0.y));\\',\\n            \\'}\\',\\n        ].join( \\'\\\\n\\' );\\n\\n        return new Program(\\n            new Shader( Shader.VERTEX_SHADER, Composer.Filter.defaultVertexShader ),\\n            new Shader( Shader.FRAGMENT_SHADER, fragmentShader )\\n        );\\n    }\\n\\n    // This camera will render both textures on the canvas in a single pass\\n    var createCameraCanvas = function ( leftEyeTexture, rightEyeTexture, viewport ) {\\n\\n        var orthoCamera = new Camera();\\n        orthoCamera.setViewport( viewport );\\n        orthoCamera.setRenderOrder( Camera.POST_RENDER, 0 );\\n        orthoCamera.setReferenceFrame( Transform.ABSOLUTE_RF );\\n        Matrix.makeOrtho( -0.5, 0.5, -0.5, 0.5, -5.0, 5.0, orthoCamera.getProjectionMatrix() );\\n\\n        var quad = Shape.createTexturedQuadGeometry( -0.5, -0.5, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0 );\\n        var stateSet = quad.getOrCreateStateSet();\\n        var samplerLeft = Uniform.createInt1( 0, \\'leftEyeTexture\\' );\\n        var samplerRight = Uniform.createInt1( 1, \\'rightEyeTexture\\' );\\n\\n        stateSet.setTextureAttributeAndMode( 0, leftEyeTexture );\\n        stateSet.setTextureAttributeAndMode( 1, rightEyeTexture );\\n        stateSet.setAttributeAndMode( getAssembleShader() );\\n        stateSet.addUniform( samplerLeft );\\n        stateSet.addUniform( samplerRight );\\n\\n        orthoCamera.addChild( quad );\\n\\n        return orthoCamera;\\n    };\\n\\n    // This camera will render the scene on a texture for an eye \\n    var createCameraRtt = function ( texture, projection ) {\\n        var camera = new Camera();\\n        camera.setName( \\'rtt camera\\' );\\n        camera.setViewport( new Viewport( 0.0, 0.0, texture.getWidth(), texture.getHeight() ) );\\n        camera.setProjectionMatrix( projection );\\n        camera.setClearColor( [ 0.3, 0.3, 0.3, 0.0 ] );\\n        camera.setRenderOrder( Camera.PRE_RENDER, 0 );\\n        camera.attachTexture( FrameBufferObject.COLOR_ATTACHMENT0, texture, 0 );\\n        camera.attachRenderBuffer( FrameBufferObject.DEPTH_ATTACHMENT, FrameBufferObject.DEPTH_COMPONENT16 );\\n        camera.setReferenceFrame( Transform.ABSOLUTE_RF );\\n        return camera;\\n    };\\n\\n    var WebVR = {};\\n\\n    WebVR.createScene = function ( viewer, rttScene, HMDdevice ) {\\n\\n        var root = new Node();\\n        var worldFactor = 1.0;\\n\\n        var hmd = getHMDOptions( HMDdevice );\\n\\n        // Compute projections and view matrices for both eyes\\n        var projectionLeft = perspectiveMatrixFromVRFieldOfView( hmd.fovLeft, 0.1, 1000 );\\n        var projectionRight = perspectiveMatrixFromVRFieldOfView( hmd.fovRight, 0.1, 1000 );\\n        var viewLeft = Matrix.makeTranslate( worldFactor * hmd.eyeOffsetLeft.x, hmd.eyeOffsetLeft.y, hmd.eyeOffsetLeft.z, Matrix.create() );\\n        var viewRight = Matrix.makeTranslate( worldFactor * hmd.eyeOffsetRight.x, hmd.eyeOffsetRight.y, hmd.eyeOffsetRight.z, Matrix.create() );\\n\\n        // Each eye is rendered on a texture whose width is half of the final combined texture\\n        var eyeTextureSize = {\\n            width: hmd.rttResolution.width / 2.0,\\n            height: hmd.rttResolution.height\\n        };\\n\\n        var leftEyeTexture = createTexture( eyeTextureSize );\\n        var rightEyeTexture = createTexture( eyeTextureSize );\\n\\n        // Setup the render cameras for both eyes\\n        var camRttLeft = createCameraRtt( leftEyeTexture, projectionLeft );\\n        var camRttRight = createCameraRtt( rightEyeTexture, projectionRight );\\n\\n        // The viewMatrix of each eye is updated with the current viewer\\'s camera viewMatrix\\n        var rootViewMatrix = viewer.getCamera().getViewMatrix();\\n        camRttLeft.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewLeft ) );\\n        camRttRight.setUpdateCallback( new UpdateRttCameraCallback( rootViewMatrix, viewRight ) );\\n\\n        // Render both textures on the canvas, using the viewer\\'s camera viewport to render on the fullscreen canvas\\n        var camCanvas = createCameraCanvas( leftEyeTexture, rightEyeTexture, viewer.getCamera().getViewport() );\\n\\n        camRttLeft.addChild( rttScene );\\n        camRttRight.addChild( rttScene );\\n\\n        root.addChild( camRttLeft );\\n        root.addChild( camRttRight );\\n        root.addChild( camCanvas );\\n\\n        return root;\\n    };\\n\\n    function getHMDOptions( hmdDevice ) {\\n\\n        /* WebVR API state as of 22/07/2014\\n        Firefox { \\n            getCurrentEyeFieldOfView()\\n            getMaximumEyeFieldOfView()\\n            getRecommendedEyeFieldOfView()\\n            getEyeTranslation()\\n        },\\n        Chrome {\\n            getCurrentEyeFieldOfView()\\n            getMaximumEyeFieldOfView()\\n            getRecommendedEyeFieldOfView()\\n            getEyeTranslation()\\n            getRecommendedRenderTargetSize()\\n        }*/\\n\\n        var hmd = {\\n\\n            fovLeft: hmdDevice.getRecommendedEyeFieldOfView( \\'left\\' ),\\n            fovRight: hmdDevice.getRecommendedEyeFieldOfView( \\'right\\' ),\\n            eyeOffsetLeft: hmdDevice.getEyeTranslation( \\'left\\' ),\\n            eyeOffsetRight: hmdDevice.getEyeTranslation( \\'right\\' ),\\n            rttResolution: {\\n                width: 1920,\\n                height: 1080\\n            },\\n        };\\n        if ( hmdDevice.getRecommendedRenderTargetSize )\\n            hmd.rttResolution = hmdDevice.getRecommendedRenderTargetSize();\\n\\n        return hmd;\\n    }\\n\\n    return WebVR;\\n\\n} );\\n\\n//# sourceURL=/osgUtil/WebVR.js\");\n\n",
    "eval(\"define( \\'osgUtil/osgUtil\\',[\\n    \\'osgUtil/Composer\\',\\n    \\'osgUtil/IntersectVisitor\\',\\n    \\'osgUtil/ParameterVisitor\\',\\n    \\'osgUtil/TriangleIntersect\\',\\n    \\'osgUtil/Oculus\\',\\n    \\'osgUtil/WebVR\\'\\n], function( Composer, IntersectVisitor, ParameterVisitor, TriangleIntersect, Oculus, WebVR ) {\\n\\n    var osgUtil = {};\\n\\n    osgUtil.Composer = Composer;\\n    osgUtil.IntersectVisitor = IntersectVisitor;\\n    osgUtil.ParameterVisitor = ParameterVisitor;\\n    osgUtil.TriangleIntersect = TriangleIntersect;\\n    osgUtil.Oculus = Oculus;\\n    osgUtil.WebVR = WebVR;\\n\\n    return osgUtil;\\n} );\\n\\n//# sourceURL=/osgUtil/osgUtil.js\");\n\n",
    "eval(\"define( \\'osgViewer/View\\',[\\n    \\'osg/Camera\\',\\n    \\'osg/Node\\',\\n    \\'osg/FrameStamp\\',\\n    \\'osg/Material\\',\\n    \\'osg/Depth\\',\\n    \\'osg/BlendFunc\\',\\n    \\'osg/CullFace\\',\\n    \\'osg/Viewport\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/Light\\',\\n    \\'osg/WebGLCaps\\',\\n    \\'osgUtil/IntersectVisitor\\'\\n], function ( Camera, Node, FrameStamp, Material, Depth, BlendFunc, CullFace, Viewport, Matrix, Light, WebGLCaps, IntersectVisitor ) {\\n\\n    \\'use strict\\';\\n\\n    var View = function () {\\n        this._graphicContext = undefined;\\n        this._camera = new Camera();\\n        this._scene = new Node();\\n        this._sceneData = undefined;\\n        this._frameStamp = new FrameStamp();\\n        this._lightingMode = undefined;\\n        this._manipulator = undefined;\\n        this._webGLCaps = undefined;\\n\\n\\n        this.setLightingMode( View.LightingMode.HEADLIGHT );\\n\\n        this._scene.getOrCreateStateSet().setAttributeAndMode( new Material() );\\n        this._scene.getOrCreateStateSet().setAttributeAndMode( new Depth() );\\n        this._scene.getOrCreateStateSet().setAttributeAndMode( new BlendFunc() );\\n        this._scene.getOrCreateStateSet().setAttributeAndMode( new CullFace() );\\n    };\\n\\n    View.LightingMode = {\\n        NO_LIGHT: 0,\\n        HEADLIGHT: 1,\\n        SKY_LIGHT: 2\\n    };\\n\\n    View.prototype = {\\n        setGraphicContext: function ( gc ) {\\n            this._graphicContext = gc;\\n        },\\n        getGraphicContext: function () {\\n            return this._graphicContext;\\n        },\\n        getWebGLCaps: function () {\\n            return this._webGLCaps;\\n        },\\n        initWebGLCaps: function ( gl ) {\\n            this._webGLCaps = new WebGLCaps();\\n            this._webGLCaps.init( gl );\\n        },\\n\\n        computeCanvasSize: ( function() {\\n            var canvasWidth = 0;\\n            var canvasHeight = 0;\\n\\n            return function ( canvas ) {\\n\\n                var clientWidth, clientHeight;\\n                clientWidth = canvas.clientWidth;\\n                clientHeight = canvas.clientHeight;\\n\\n                if ( clientWidth < 1 ) clientWidth = 1;\\n                if ( clientHeight < 1 ) clientHeight = 1;\\n\\n                var devicePixelRatio = 1;\\n                if ( this._options.getBoolean( \\'useDevicePixelRatio\\' ) ) {\\n                    devicePixelRatio = window.devicePixelRatio || 1;\\n                }\\n\\n                var widthPixel = clientWidth * devicePixelRatio;\\n                var heightPixel = clientHeight * devicePixelRatio;\\n\\n                if ( canvasWidth !== widthPixel ) {\\n                    canvas.width = widthPixel;\\n                    canvasWidth = widthPixel;\\n                }\\n\\n                if ( canvasHeight !== heightPixel ) {\\n                    canvas.height = heightPixel;\\n                    canvasHeight = heightPixel;\\n                }\\n\\n            }; })(),\\n\\n        setUpView: function ( canvas ) {\\n            this.computeCanvasSize( canvas );\\n\\n            var ratio = canvas.clientWidth / canvas.clientHeight;\\n\\n            var width  = canvas.width;\\n            var height = canvas.height;\\n\\n            this._camera.setViewport( new Viewport( 0, 0, width, height ) );\\n\\n            this._camera.setGraphicContext( this._graphicContext );\\n            Matrix.makeLookAt( [ 0, 0, -10 ], [ 0, 0, 0 ], [ 0, 1, 0 ], this._camera.getViewMatrix() );\\n            Matrix.makePerspective( 55, ratio, 1.0, 1000.0, this._camera.getProjectionMatrix() );\\n        },\\n\\n        /**\\n         * X = 0 at the left\\n         * Y = 0 at the BOTTOM\\n         */\\n        computeIntersections: function ( x, y, traversalMask ) {\\n            /*jshint bitwise: false */\\n            if ( traversalMask === undefined ) {\\n                traversalMask = ~0;\\n            }\\n            /*jshint bitwise: true */\\n\\n            var iv = new IntersectVisitor();\\n            iv.setTraversalMask( traversalMask );\\n            iv.addLineSegment( [ x, y, 0.0 ], [ x, y, 1.0 ] );\\n            iv.pushCamera( this._camera );\\n            this._sceneData.accept( iv );\\n            return iv.hits;\\n        },\\n\\n        setFrameStamp: function ( frameStamp ) {\\n            this._frameStamp = frameStamp;\\n        },\\n        getFrameStamp: function () {\\n            return this._frameStamp;\\n        },\\n        setCamera: function ( camera ) {\\n            this._camera = camera;\\n        },\\n        getCamera: function () {\\n            return this._camera;\\n        },\\n\\n        setSceneData: function ( node ) {\\n            this._scene.removeChildren();\\n            this._scene.addChild( node );\\n            this._sceneData = node;\\n        },\\n        getSceneData: function () {\\n            return this._sceneData;\\n        },\\n        getScene: function () {\\n            return this._scene;\\n        },\\n\\n        getManipulator: function () {\\n            return this._manipulator;\\n        },\\n        setManipulator: function ( manipulator ) {\\n            this._manipulator = manipulator;\\n        },\\n\\n        getLight: function () {\\n            return this._light;\\n        },\\n        setLight: function ( light ) {\\n            this._light = light;\\n            if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {\\n                this._scene.getOrCreateStateSet().setAttributeAndMode( this._light );\\n            }\\n        },\\n        getLightingMode: function () {\\n            return this._lightingMode;\\n        },\\n        setLightingMode: function ( lightingMode ) {\\n            if ( this._lightingMode !== lightingMode ) {\\n                this._lightingMode = lightingMode;\\n                if ( this._lightingMode !== View.LightingMode.NO_LIGHT ) {\\n                    if ( !this._light ) {\\n                        this._light = new Light();\\n                        //this._light.setColor( [ 0.8, 0.8, 0.8, 1.0 ] );\\n                    }\\n                } else {\\n                    this._light = undefined;\\n                }\\n            }\\n        }\\n\\n    };\\n\\n    return View;\\n} );\\n\\n//# sourceURL=/osgViewer/View.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/GamePad\\',[\\n    \\'osg/Notify\\'\\n], function ( Notify ) {\\n\\n    var GamePad = function ( viewer ) {\\n        this._viewer = viewer;\\n        this._type = \\'GamePad\\';\\n        this._enable = true;\\n    };\\n\\n    GamePad.prototype = {\\n        init: function ( /*args*/ ) {\\n\\n            var gamepadSupportAvailable = !! navigator.webkitGetGamepads || !! navigator.webkitGamepads;\\n            // || (navigator.userAgent.indexOf(\\'Firefox/\\') != -1); // impossible to detect Gamepad API support in FF\\n            if ( !gamepadSupportAvailable ) return;\\n\\n        },\\n\\n        isValid: function () {\\n            if ( !this._enable )\\n                return false;\\n\\n            var manipulator = this._viewer.getManipulator();\\n            if ( !manipulator )\\n                return false;\\n\\n            var constrollerList = manipulator.getControllerList();\\n            if ( !constrollerList[ this._type ] )\\n                return false;\\n\\n            return true;\\n        },\\n\\n        getManipulatorController: function () {\\n            return this._viewer.getManipulator().getControllerList()[ this._type ];\\n        },\\n\\n        webkitGamepadPoll: function () {\\n            var rawGamepads = ( navigator.webkitGetGamepads && navigator.webkitGetGamepads() ) || navigator.webkitGamepads;\\n            if ( !rawGamepads ) {\\n                return;\\n            }\\n\\n            if ( rawGamepads[ 0 ] ) {\\n                if ( !this._gamepad ) {\\n                    this.onGamepadConnect( {\\n                        gamepad: rawGamepads[ 0 ]\\n                    } );\\n                }\\n                this._gamepad = rawGamepads[ 0 ];\\n            } else if ( this._gamepad ) {\\n                this.onGamepadDisconnect( {\\n                    gamepad: this._gamepad\\n                } );\\n            }\\n        },\\n\\n        onGamepadConnect: function ( evt ) {\\n            this._gamepad = evt.gamepad;\\n            Notify.log( \\'Detected new gamepad!\\', this._gamepad );\\n        },\\n\\n        onGamepadDisconnect: function ( /*evt*/ ) {\\n            this._gamepad = false;\\n            Notify.log( \\'Gamepad disconnected\\', this._gamepad );\\n        },\\n        getGamePad: function () {\\n            return this._gamepad;\\n        },\\n\\n        // Called in each frame\\n        update: function () {\\n\\n            // necessary\\n            this.webkitGamepadPoll();\\n\\n            if ( !this._gamepad )\\n                return;\\n\\n            var manipulatorAdapter = this.getManipulatorController();\\n            //manipulatorAdapter.setEventProxy(this);\\n            if ( manipulatorAdapter.update ) {\\n                manipulatorAdapter.update( this );\\n            }\\n        }\\n    };\\n    return GamePad;\\n} );\\n\\n//# sourceURL=/osgViewer/eventProxy/GamePad.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/Hammer\\',[\\n    \\'Hammer\\'\\n], function ( Hammer ) {\\n\\n    var HammerController = function ( viewer ) {\\n        this._enable = true;\\n        this._viewer = viewer;\\n        this._type = \\'Hammer\\';\\n\\n        this._eventNode = undefined;\\n\\n    };\\n\\n    HammerController.prototype = {\\n        init: function ( args ) {\\n\\n            /*jshint camelcase: false */\\n            var options = {\\n                prevent_default: true,\\n                drag_max_touches: 2,\\n                transform_min_scale: 0.08,\\n                transform_min_rotation: 180,\\n                transform_always_block: true,\\n                hold: false,\\n                release: false,\\n                swipe: false,\\n                tap: false\\n            };\\n            /*jshint camelcase: true */\\n\\n            this._eventNode = args.eventNode;\\n            if ( this._eventNode ) {\\n                this._hammer = new Hammer( this._eventNode, options );\\n            }\\n        },\\n\\n        isValid: function () {\\n            if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )\\n                return true;\\n            return false;\\n        },\\n        getManipulatorController: function () {\\n            return this._viewer.getManipulator().getControllerList()[ this._type ];\\n        },\\n\\n        // use the update to set the input device to mouse controller\\n        // it\\'s needed to compute size\\n        update: function () {\\n            if ( !this.isValid() )\\n                return;\\n\\n            // we pass directly hammer object\\n            this.getManipulatorController().setEventProxy( this._hammer );\\n        }\\n\\n    };\\n    return HammerController;\\n} );\\n\\n//# sourceURL=/osgViewer/eventProxy/Hammer.js\");\n\n",
    "eval(\"define( \\'Leap\\',[],function ( ) {\\n    return window.Leap;\\n} );\\n\\n//# sourceURL=/vendors/Leap.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/LeapMotion\\',[\\n    \\'Leap\\',\\n    \\'osg/Notify\\'\\n], function ( Leap, Notify ) {\\n\\n    var LeapMotion = function ( viewer ) {\\n        this._viewer = viewer;\\n        this._type = \\'LeapMotion\\';\\n        this._enable = true;\\n    };\\n\\n    LeapMotion.prototype = {\\n        init: function ( args ) {\\n\\n            // add condition if no leap in global space\\n            if ( typeof Leap === \\'undefined\\' || !Leap.Controller)\\n                return;\\n\\n            var self = this;\\n            this._controller = new Leap.Controller( {\\n                enableGestures: args.gestures || true,\\n                tryReconnectOnDisconnect: true,\\n                connectAttempts: 3\\n            } );\\n            this._controller.on( \\'ready\\', function () {\\n                if ( args.readyCallback )\\n                    args.readyCallback( self._controller );\\n                self._leapMotionReady = true;\\n                Notify.info( \\'leapmotion ready\\' );\\n            } );\\n            this._controller.loop( this._update.bind( this ) );\\n        },\\n\\n        isValid: function () {\\n            if ( !this._enable )\\n                return false;\\n\\n            var manipulator = this._viewer.getManipulator();\\n            if ( !manipulator )\\n                return false;\\n\\n            var constrollerList = manipulator.getControllerList();\\n            if ( !constrollerList[ this._type ] )\\n                return false;\\n\\n            return true;\\n        },\\n        getManipulatorController: function () {\\n            return this._viewer.getManipulator().getControllerList()[ this._type ];\\n        },\\n\\n        // this is binded\\n        _update: function ( frame ) {\\n            if ( !frame.valid || !this.isValid() ) {\\n                return;\\n            }\\n            var manipulatorAdapter = this.getManipulatorController();\\n            if ( manipulatorAdapter.update ) {\\n                manipulatorAdapter.update( frame );\\n            }\\n        }\\n    };\\n    return LeapMotion;\\n} );\\n\\n//# sourceURL=/osgViewer/eventProxy/LeapMotion.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/StandardMouseKeyboard\\',[], function () {\\n\\n    var StandardMouseKeyboard = function ( viewer ) {\\n        this._enable = true;\\n        this._viewer = viewer;\\n        this._type = \\'StandardMouseKeyboard\\';\\n\\n        this._mouseEventNode = undefined;\\n        this._wheelEventNode = undefined;\\n        this._keyboardEventNode = undefined;\\n        this._eventList = [ \\'mousedown\\', \\'mouseup\\', \\'mouseout\\', \\'mousemove\\', \\'dblclick\\' ];\\n        this._mousePosition = [ 0, 0 ];\\n    };\\n\\n    StandardMouseKeyboard.prototype = {\\n        init: function ( args ) {\\n\\n            this.removeEventListeners( this._mouseEventNode, this._wheelEventNode, this._keyboardEventNode );\\n\\n            var mouse = args.mouseEventNode;\\n            var mousewheel = args.wheelEventNode || mouse;\\n            var keyboard = args.keyboardEventNode || mouse;\\n\\n            this.addEventListeners( mouse, mousewheel, keyboard );\\n            this._mouseEventNode = mouse;\\n            this._wheelEventNode = mousewheel;\\n            this._keyboardEventNode = keyboard;\\n        },\\n\\n        addEventListeners: function ( mouse, mousewheel, keyboard ) {\\n            if ( mouse ) {\\n                for ( var i = 0, l = this._eventList.length; i < l; i++ ) {\\n                    var ev = this._eventList[ i ];\\n                    if ( this[ ev ] ) {\\n                        mouse.addEventListener( ev, this[ ev ].bind( this ), false );\\n                    }\\n                }\\n            }\\n            if ( mousewheel ) {\\n                mousewheel.addEventListener( \\'DOMMouseScroll\\', this.mousewheel.bind( this ), false );\\n                mousewheel.addEventListener( \\'mousewheel\\', this.mousewheel.bind( this ), false );\\n                mousewheel.addEventListener( \\'MozMousePixelScroll\\', this.preventDefault.bind( this ), false );\\n            }\\n\\n            if ( keyboard ) {\\n                keyboard.addEventListener( \\'keydown\\', this.keydown.bind( this ), false );\\n                keyboard.addEventListener( \\'keyup\\', this.keyup.bind( this ), false );\\n            }\\n        },\\n\\n        removeEventListeners: function ( mouse, mousewheel, keyboard ) {\\n            if ( mouse ) {\\n                for ( var i = 0, l = this._eventList.length; i < l; i++ ) {\\n                    var ev = this._eventList[ i ];\\n                    if ( this[ ev ] ) {\\n                        mouse.removeEventListener( ev, this[ ev ] );\\n                    }\\n                }\\n            }\\n            if ( mousewheel ) {\\n                mousewheel.removeEventListener( \\'DOMMouseScroll\\', this.mousewheel );\\n                mousewheel.removeEventListener( \\'mousewheel\\', this.mousewheel );\\n                mousewheel.removeEventListener( \\'MozMousePixelScroll\\', this.preventDefault );\\n            }\\n            if ( keyboard ) {\\n                keyboard.removeEventListener( \\'keydown\\', this.keydown );\\n                keyboard.removeEventListener( \\'keyup\\', this.keyup );\\n            }\\n        },\\n\\n        isValid: function () {\\n            if ( this._enable && this._viewer.getManipulator() && this._viewer.getManipulator().getControllerList()[ this._type ] )\\n                return true;\\n            return false;\\n        },\\n        getManipulatorController: function () {\\n            return this._viewer.getManipulator().getControllerList()[ this._type ];\\n        },\\n        keyup: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().keyup )\\n                return this.getManipulatorController().keyup( ev );\\n        },\\n        keydown: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().keydown )\\n                return this.getManipulatorController().keydown( ev );\\n        },\\n\\n        mousedown: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().mousedown )\\n                return this.getManipulatorController().mousedown( ev );\\n        },\\n\\n        mouseup: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().mouseup )\\n                return this.getManipulatorController().mouseup( ev );\\n        },\\n\\n        mouseout: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().mouseout )\\n                return this.getManipulatorController().mouseout( ev );\\n        },\\n\\n        mousemove: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().mousemove )\\n                return this.getManipulatorController().mousemove( ev );\\n        },\\n\\n        dblclick: function ( ev ) {\\n            if ( !this.isValid() )\\n                return;\\n            if ( this.getManipulatorController().dblclick )\\n                return this.getManipulatorController().dblclick( ev );\\n        },\\n\\n        mousewheel: function ( event ) {\\n            if ( !this.isValid() )\\n                return;\\n\\n            var manipulatorAdapter = this.getManipulatorController();\\n            if ( !manipulatorAdapter.mousewheel )\\n                return;\\n\\n            // from jquery\\n            var orgEvent = event || window.event,\\n                args = [].slice.call( arguments, 1 ),\\n                delta = 0,\\n                //returnValue = true,\\n                deltaX = 0,\\n                deltaY = 0;\\n            //event = $.event.fix(orgEvent);\\n            event.type = \\'mousewheel\\';\\n\\n            // Old school scrollwheel delta\\n            if ( event.wheelDelta ) {\\n                delta = event.wheelDelta / 120;\\n            }\\n            if ( event.detail ) {\\n                delta = -event.detail / 3;\\n            }\\n\\n            // New school multidimensional scroll (touchpads) deltas\\n            deltaY = delta;\\n\\n            // Gecko\\n            if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {\\n                deltaY = 0;\\n                deltaX = -1 * delta;\\n            }\\n\\n            // Webkit\\n            if ( orgEvent.wheelDeltaY !== undefined ) {\\n                deltaY = orgEvent.wheelDeltaY / 120;\\n            }\\n            if ( orgEvent.wheelDeltaX !== undefined ) {\\n                deltaX = -1 * orgEvent.wheelDeltaX / 120;\\n            }\\n            // Add event and delta to the front of the arguments\\n            args.unshift( event, delta, deltaX, deltaY );\\n\\n            return this.getManipulatorController().mousewheel.apply( manipulatorAdapter, args );\\n        },\\n\\n        preventDefault: function ( event ) {\\n            event.preventDefault();\\n        },\\n\\n        divGlobalOffset: function ( obj ) {\\n            var x = 0,\\n                y = 0;\\n            x = obj.offsetLeft;\\n            y = obj.offsetTop;\\n            var body = document.getElementsByTagName( \\'body\\' )[ 0 ];\\n            while ( obj.offsetParent && obj !== body ) {\\n                x += obj.offsetParent.offsetLeft;\\n                y += obj.offsetParent.offsetTop;\\n                obj = obj.offsetParent;\\n            }\\n            this._mousePosition[ 0 ] = x;\\n            this._mousePosition[ 1 ] = y;\\n            return this._mousePosition;\\n        },\\n\\n        getPositionRelativeToCanvas: function ( e, result ) {\\n            var myObject = e.target;\\n            var posx, posy;\\n            if ( e.pageX || e.pageY ) {\\n                posx = e.pageX;\\n                posy = e.pageY;\\n            } else if ( e.clientX || e.clientY ) {\\n                posx = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\\n                posy = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\\n            }\\n\\n            // posx and posy contain the mouse position relative to the document\\n            // Do something with this information\\n            var globalOffset = this.divGlobalOffset( myObject );\\n            posx = posx - globalOffset[ 0 ];\\n            posy = myObject.height - ( posy - globalOffset[ 1 ] );\\n\\n            // NaN in camera check here\\n            if ( isNaN( posx ) || isNaN( posy ) ) {\\n                //debugger;\\n            }\\n\\n            // copy data to result if need to keep result\\n            // else we use a tmp variable inside manipulator\\n            // that we override at each call\\n            if ( result === undefined ) {\\n                result = this._mousePosition;\\n            }\\n            result[ 0 ] = posx;\\n            result[ 1 ] = posy;\\n            return result;\\n        },\\n\\n        // use the update to set the input device to mouse controller\\n        // it\\'s needed to compute size\\n        update: function () {\\n            if ( !this.isValid() )\\n                return;\\n\\n            this.getManipulatorController().setEventProxy( this );\\n        }\\n\\n    };\\n    return StandardMouseKeyboard;\\n} );\\n\\n//# sourceURL=/osgViewer/eventProxy/StandardMouseKeyboard.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/Oculus\\',[ \\n    \\'osg/Notify\\',\\n    \\'osg/Quat\\' ], function ( Notify, Quat ) {\\n\\n    \\'use strict\\';\\n\\n    var Oculus = function ( viewer ) {\\n        this._viewer = viewer;\\n        this._type = \\'Oculus\\';\\n        this._enable = true;\\n        this._hmd = undefined;\\n        this._sensor = undefined;\\n        this._quat = Quat.create();\\n    };\\n\\n    Oculus.prototype = {\\n\\n        init: function () {\\n\\n            var self = this;\\n\\n            function vrDeviceCallback( vrDevices ) {\\n\\n                var i;\\n\\n                // First, find a HMD -- just use the first one we find\\n                for ( i = 0; i < vrDevices.length; ++i ) {\\n                    if ( vrDevices[ i ] instanceof window.HMDVRDevice ) {\\n                        self._hmd = vrDevices[ i ];\\n                        break;\\n                    }\\n                }\\n\\n                // Then, find a sensor corresponding to the same hardwareUnitId\\n                for ( i = 0; i < vrDevices.length; ++i ) {\\n                    if ( vrDevices[ i ] instanceof window.PositionSensorVRDevice && vrDevices[ i ].hardwareUnitId === self._hmd.hardwareUnitId ) {\\n                        self._sensor = vrDevices[ i ];\\n                        break;\\n                    }\\n                }\\n\\n                if ( self._hmd && self._sensor )\\n                    Notify.log( \\'Found a HMD and Sensor\\' );\\n            }\\n\\n            if ( navigator.getVRDevices ) {\\n                navigator.getVRDevices().then( vrDeviceCallback );\\n            } else if ( navigator.mozGetVRDevices ) {\\n                navigator.mozGetVRDevices( vrDeviceCallback );\\n            }\\n\\n        },\\n\\n        getManipulatorController: function () {\\n            return this._viewer.getManipulator().getControllerList()[ this._type ];\\n        },\\n\\n        isValid: function () {\\n            if ( !this._enable )\\n                return false;\\n\\n            var manipulator = this._viewer.getManipulator();\\n            if ( !manipulator )\\n                return false;\\n\\n            if ( !manipulator.getControllerList()[ this._type ] )\\n                return false;\\n\\n            if ( !this._hmd || !this._sensor )\\n                return false;\\n\\n            return true;\\n        },\\n\\n        update: function () {\\n\\n            if ( !this.isValid() )\\n                return;\\n\\n            var manipulatorAdapter = this.getManipulatorController();\\n\\n            // update the manipulator with the rotation of the device\\n            if ( manipulatorAdapter.update ) {\\n\\n                var quat = this._sensor.getState().orientation;\\n\\n                // If no real oculus is detected, navigators (vr builds of FF and Chrome) simulate a fake oculus\\n                // On firefox, this fake oculus returns a wrong quaternion: [0, 0, 0, 0]\\n                // So we detect and set this quaternion to a neutral value: [0, 0, 0, 1]\\n                if ( quat.x === 0.0 && quat.y === 0.0 && quat.y === 0.0 && quat.w === 0.0 )\\n                    quat.w = 1.0;\\n\\n                // On oculus the up vector is [0,1,0]\\n                // On osgjs the up vector is [0,0,1]\\n                this._quat[ 0 ] = quat.x;\\n                this._quat[ 1 ] = -quat.z;\\n                this._quat[ 2 ] = quat.y;\\n                this._quat[ 3 ] = quat.w;\\n\\n                manipulatorAdapter.update( this._quat );\\n            }\\n        }\\n    };\\n    return Oculus;\\n} );\\n\\n//# sourceURL=/osgViewer/eventProxy/Oculus.js\");\n\n",
    "eval(\"define( \\'osgViewer/eventProxy/EventProxy\\',[\\n    \\'osgViewer/eventProxy/GamePad\\',\\n    \\'osgViewer/eventProxy/Hammer\\',\\n    \\'osgViewer/eventProxy/LeapMotion\\',\\n    \\'osgViewer/eventProxy/StandardMouseKeyboard\\',\\n    \\'osgViewer/eventProxy/Oculus\\'\\n], function ( GamePad, HammerOsg, LeapMotion, StandardMouseKeyboard, Oculus ) {\\n\\n    return {\\n        GamePad: GamePad,\\n        Hammer: HammerOsg,\\n        LeapMotion: LeapMotion,\\n        StandardMouseKeyboard: StandardMouseKeyboard,\\n        Oculus: Oculus\\n    };\\n} );\\n//# sourceURL=/osgViewer/eventProxy/EventProxy.js\");\n\n",
    "eval(\"/* jshint ignore:start */\\n\\ndefine( \\'osgViewer/webgl-utils\\',[], function () {\\n\\n    /*\\n     * Copyright 2010, Google Inc.\\n     * All rights reserved.\\n     *\\n     * Redistribution and use in source and binary forms, with or without\\n     * modification, are permitted provided that the following conditions are\\n     * met:\\n     *\\n     *     * Redistributions of source code must retain the above copyright\\n     * notice, this list of conditions and the following disclaimer.\\n     *     * Redistributions in binary form must reproduce the above\\n     * copyright notice, this list of conditions and the following disclaimer\\n     * in the documentation and/or other materials provided with the\\n     * distribution.\\n     *     * Neither the name of Google Inc. nor the names of its\\n     * contributors may be used to endorse or promote products derived from\\n     * this software without specific prior written permission.\\n     *\\n     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\\n     * \\\"AS IS\\\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\\n     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\\n     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\\n     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\\n     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\\n     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\\n     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\\n     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\\n     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\\n     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\\n     */\\n\\n\\n    /**\\n     * @fileoverview This file contains functions every webgl program will need\\n     * a version of one way or another.\\n     *\\n     * Instead of setting up a context manually it is recommended to\\n     * use. This will check for success or failure. On failure it\\n     * will attempt to present an approriate message to the user.\\n     *\\n     *       gl = WebGLUtils.setupWebGL(canvas);\\n     *\\n     * For animated WebGL apps use of setTimeout or setInterval are\\n     * discouraged. It is recommended you structure your rendering\\n     * loop like this.\\n     *\\n     *       function render() {\\n     *         window.requestAnimationFrame(render, canvas);\\n     *\\n     *         // do rendering\\n     *         ...\\n     *       }\\n     *       render();\\n     *\\n     * This will call your rendering function up to the refresh rate\\n     * of your display but will stop rendering if your app is not\\n     * visible.\\n     */\\n\\n    var WebGLUtils = function () {\\n\\n        /**\\n         * Creates the HTLM for a failure message\\n         * @param {string} canvasContainerId id of container of th\\n         *        canvas.\\n         * @return {string} The html.\\n         */\\n        var makeFailHTML = function ( msg ) {\\n            return \\'\\' +\\n                \\'<div style=\\\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\\\">\\' + msg + \\'</div>\\';\\n            // return \\'\\' +\\n            //   \\'<table style=\\\"background-color: #8CE; width: 100%; height: 100%;\\\"><tr>\\' +\\n            //   \\'<td align=\\\"center\\\">\\' +\\n            //   \\'<div style=\\\"display: table-cell; vertical-align: middle;\\\">\\' +\\n            //   \\'<div style=\\\"\\\">\\' + msg + \\'</div>\\' +\\n            //   \\'</div>\\' +\\n            //   \\'</td></tr></table>\\';\\n        };\\n\\n        /**\\n         * Mesasge for getting a webgl browser\\n         * @type {string}\\n         */\\n        var GET_A_WEBGL_BROWSER = \\'\\' +\\n            \\'This page requires a browser that supports WebGL.<br/>\\' +\\n            \\'<a href=\\\"http://get.webgl.org\\\">Click here to upgrade your browser.</a>\\';\\n\\n        /**\\n         * Mesasge for need better hardware\\n         * @type {string}\\n         */\\n        var OTHER_PROBLEM = \\'\\' +\\n            \\\"It doesn\\'t appear your computer can support WebGL.<br/>\\\" +\\n            \\'<a href=\\\"http://get.webgl.org\\\">Click here for more information.</a>\\';\\n\\n        /**\\n         * Creates a webgl context. If creation fails it will\\n         * change the contents of the container of the <canvas>\\n         * tag to an error message with the correct links for WebGL.\\n         * @return {WebGLRenderingContext} The created context.\\n         */\\n        var setupWebGL = function (\\n            /** Element */\\n            canvas,\\n            /** WebGLContextCreationAttirbutes */\\n            opt_attribs,\\n            /** function:(msg) */\\n            opt_onError ) {\\n            function handleCreationError( msg ) {\\n                var container = document.getElementsByTagName( \\\"body\\\" )[ 0 ];\\n                //var container = canvas.parentNode;\\n                if ( container ) {\\n                    var str = window.WebGLRenderingContext ?\\n                        OTHER_PROBLEM :\\n                        GET_A_WEBGL_BROWSER;\\n                    if ( msg ) {\\n                        str += \\\"<br/><br/>Status: \\\" + msg;\\n                    }\\n                    container.innerHTML = makeFailHTML( str );\\n                }\\n            }\\n\\n            opt_onError = opt_onError || handleCreationError;\\n\\n            if ( canvas.addEventListener ) {\\n                canvas.addEventListener( \\\"webglcontextcreationerror\\\", function ( event ) {\\n                    opt_onError( event.statusMessage );\\n                }, false );\\n            }\\n            var context = create3DContext( canvas, opt_attribs );\\n            if ( !context ) {\\n                if ( !window.WebGLRenderingContext ) {\\n                    opt_onError( \\\"\\\" );\\n                } else {\\n                    opt_onError( \\\"\\\" );\\n                }\\n            }\\n\\n            return context;\\n        };\\n\\n        /**\\n         * Creates a webgl context.\\n         * @param {!Canvas} canvas The canvas tag to get context\\n         *     from. If one is not passed in one will be created.\\n         * @return {!WebGLContext} The created context.\\n         */\\n        var create3DContext = function ( canvas, opt_attribs ) {\\n            var names = [ \\\"webgl\\\", \\\"experimental-webgl\\\", \\\"webkit-3d\\\", \\\"moz-webgl\\\" ];\\n            var context = null;\\n            for ( var ii = 0; ii < names.length; ++ii ) {\\n                try {\\n                    context = canvas.getContext( names[ ii ], opt_attribs );\\n                } catch ( e ) {}\\n                if ( context ) {\\n                    break;\\n                }\\n            }\\n            return context;\\n        };\\n\\n        return {\\n            create3DContext: create3DContext,\\n            setupWebGL: setupWebGL\\n        };\\n    }();\\n\\n    /**\\n     * Provides requestAnimationFrame in a cross browser\\n     * way.\\n     */\\n    if ( !window.requestAnimationFrame ) {\\n        window.requestAnimationFrame = ( function () {\\n            return window.requestAnimationFrame ||\\n                window.webkitRequestAnimationFrame ||\\n                window.mozRequestAnimationFrame ||\\n                window.oRequestAnimationFrame ||\\n                window.msRequestAnimationFrame ||\\n                function ( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element ) {\\n                    window.setTimeout( callback, 1000 / 60 );\\n            };\\n        } )();\\n    }\\n\\n    if ( !window.cancelRequestAnimFrame ) {\\n        window.cancelRequestAnimFrame = ( function () {\\n            return window.cancelAnimationFrame ||\\n                window.webkitCancelRequestAnimationFrame ||\\n                window.mozCancelRequestAnimationFrame ||\\n                window.oCancelRequestAnimationFrame ||\\n                window.msCancelRequestAnimationFrame ||\\n                clearTimeout;\\n        } )();\\n    }\\n\\n    if ( !Date.now ) {\\n        Date.now = function now() {\\n            return new Date().getTime();\\n        };\\n    }\\n\\n    return WebGLUtils;\\n} );\\n\\n/* jshint ignore:end */\\n\\n//# sourceURL=/osgViewer/webgl-utils.js\");\n\n",
    "eval(\"/* jshint ignore:start */\\n\\ndefine( \\'osgViewer/webgl-debug\\',[\\n\\n    \\'osg/Notify\\'\\n\\n], function ( Notify ) {\\n\\n    //Copyright (c) 2009 The Chromium Authors. All rights reserved.\\n    //Use of this source code is governed by a BSD-style license that can be\\n    //found in the LICENSE file.\\n\\n    // Various functions for helping debug WebGL apps.\\n\\n    var WebGLDebugUtils = function () {\\n\\n        /**\\n         * Which arguements are enums.\\n         * @type {!Object.<number, string>}\\n         */\\n        var glValidEnumContexts = {\\n\\n            // Generic setters and getters\\n\\n            \\'enable\\': {\\n                0: true\\n            },\\n            \\'disable\\': {\\n                0: true\\n            },\\n            \\'getParameter\\': {\\n                0: true\\n            },\\n\\n            // Rendering\\n\\n            \\'drawArrays\\': {\\n                0: true\\n            },\\n            \\'drawElements\\': {\\n                0: true,\\n                2: true\\n            },\\n\\n            // Shaders\\n\\n            \\'createShader\\': {\\n                0: true\\n            },\\n            \\'getShaderParameter\\': {\\n                1: true\\n            },\\n            \\'getProgramParameter\\': {\\n                1: true\\n            },\\n\\n            // Vertex attributes\\n\\n            \\'getVertexAttrib\\': {\\n                1: true\\n            },\\n            \\'vertexAttribPointer\\': {\\n                2: true\\n            },\\n\\n            // Textures\\n\\n            \\'bindTexture\\': {\\n                0: true\\n            },\\n            \\'activeTexture\\': {\\n                0: true\\n            },\\n            \\'getTexParameter\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'texParameterf\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'texParameteri\\': {\\n                0: true,\\n                1: true,\\n                2: true\\n            },\\n            \\'texImage2D\\': {\\n                0: true,\\n                2: true,\\n                6: true,\\n                7: true\\n            },\\n            \\'texSubImage2D\\': {\\n                0: true,\\n                6: true,\\n                7: true\\n            },\\n            \\'copyTexImage2D\\': {\\n                0: true,\\n                2: true\\n            },\\n            \\'copyTexSubImage2D\\': {\\n                0: true\\n            },\\n            \\'generateMipmap\\': {\\n                0: true\\n            },\\n\\n            // Buffer objects\\n\\n            \\'bindBuffer\\': {\\n                0: true\\n            },\\n            \\'bufferData\\': {\\n                0: true,\\n                2: true\\n            },\\n            \\'bufferSubData\\': {\\n                0: true\\n            },\\n            \\'getBufferParameter\\': {\\n                0: true,\\n                1: true\\n            },\\n\\n            // Renderbuffers and framebuffers\\n\\n            \\'pixelStorei\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'readPixels\\': {\\n                4: true,\\n                5: true\\n            },\\n            \\'bindRenderbuffer\\': {\\n                0: true\\n            },\\n            \\'bindFramebuffer\\': {\\n                0: true\\n            },\\n            \\'checkFramebufferStatus\\': {\\n                0: true\\n            },\\n            \\'framebufferRenderbuffer\\': {\\n                0: true,\\n                1: true,\\n                2: true\\n            },\\n            \\'framebufferTexture2D\\': {\\n                0: true,\\n                1: true,\\n                2: true\\n            },\\n            \\'getFramebufferAttachmentParameter\\': {\\n                0: true,\\n                1: true,\\n                2: true\\n            },\\n            \\'getRenderbufferParameter\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'renderbufferStorage\\': {\\n                0: true,\\n                1: true\\n            },\\n\\n            // Frame buffer operations (clear, blend, depth test, stencil)\\n\\n            \\'clear\\': {\\n                0: true\\n            },\\n            \\'depthFunc\\': {\\n                0: true\\n            },\\n            \\'blendFunc\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'blendFuncSeparate\\': {\\n                0: true,\\n                1: true,\\n                2: true,\\n                3: true\\n            },\\n            \\'blendEquation\\': {\\n                0: true\\n            },\\n            \\'blendEquationSeparate\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'stencilFunc\\': {\\n                0: true\\n            },\\n            \\'stencilFuncSeparate\\': {\\n                0: true,\\n                1: true\\n            },\\n            \\'stencilMaskSeparate\\': {\\n                0: true\\n            },\\n            \\'stencilOp\\': {\\n                0: true,\\n                1: true,\\n                2: true\\n            },\\n            \\'stencilOpSeparate\\': {\\n                0: true,\\n                1: true,\\n                2: true,\\n                3: true\\n            },\\n\\n            // Culling\\n\\n            \\'cullFace\\': {\\n                0: true\\n            },\\n            \\'frontFace\\': {\\n                0: true\\n            }\\n        };\\n\\n        /**\\n         * Map of numbers to names.\\n         * @type {Object}\\n         */\\n        var glEnums = null;\\n\\n        /**\\n         * Initializes this module. Safe to call more than once.\\n         * @param {!WebGLRenderingContext} ctx A WebGL context. If\\n         *    you have more than one context it doesn\\'t matter which one\\n         *    you pass in, it is only used to pull out constants.\\n         */\\n        function init( ctx ) {\\n            if ( glEnums === null ) {\\n                glEnums = {};\\n                for ( var propertyName in ctx ) {\\n                    if ( typeof ctx[ propertyName ] === \\'number\\' ) {\\n                        glEnums[ ctx[ propertyName ] ] = propertyName;\\n                    }\\n                }\\n            }\\n        }\\n\\n        /**\\n         * Checks the utils have been initialized.\\n         */\\n        function checkInit() {\\n            if ( glEnums === null ) {\\n                throw \\'WebGLDebugUtils.init(ctx) not called\\';\\n            }\\n        }\\n\\n        /**\\n         * Returns true or false if value matches any WebGL enum\\n         * @param {*} value Value to check if it might be an enum.\\n         * @return {boolean} True if value matches one of the WebGL defined enums\\n         */\\n        function mightBeEnum( value ) {\\n            checkInit();\\n            return ( glEnums[ value ] !== undefined );\\n        }\\n\\n        /**\\n         * Gets an string version of an WebGL enum.\\n         *\\n         * Example:\\n         *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\\n         *\\n         * @param {number} value Value to return an enum for\\n         * @return {string} The string version of the enum.\\n         */\\n        function glEnumToString( value ) {\\n            checkInit();\\n            var name = glEnums[ value ];\\n            return ( name !== undefined ) ? name :\\n                ( \\'*UNKNOWN WebGL ENUM (0x\\' + value.toString( 16 ) + \\')\\' );\\n        }\\n\\n        /**\\n         * Returns the string version of a WebGL argument.\\n         * Attempts to convert enum arguments to strings.\\n         * @param {string} functionName the name of the WebGL function.\\n         * @param {number} argumentIndx the index of the argument.\\n         * @param {*} value The value of the argument.\\n         * @return {string} The value as a string.\\n         */\\n        function glFunctionArgToString( functionName, argumentIndex, value ) {\\n            var funcInfo = glValidEnumContexts[ functionName ];\\n            if ( funcInfo !== undefined ) {\\n                if ( funcInfo[ argumentIndex ] ) {\\n                    return glEnumToString( value );\\n                }\\n            }\\n            return value.toString();\\n        }\\n\\n        function makePropertyWrapper( wrapper, original, propertyName ) {\\n            //Notify.log(\\\"wrap prop: \\\" + propertyName);\\n            wrapper.__defineGetter__( propertyName, function () {\\n                return original[ propertyName ];\\n            } );\\n            // TODO(gmane): this needs to handle properties that take more than\\n            // one value?\\n            wrapper.__defineSetter__( propertyName, function ( value ) {\\n                //Notify.log(\\\"set: \\\" + propertyName);\\n                original[ propertyName ] = value;\\n            } );\\n        }\\n\\n        // Makes a function that calls a function on another object.\\n        function makeFunctionWrapper( original, functionName ) {\\n            //Notify.log(\\\"wrap fn: \\\" + functionName);\\n            var f = original[ functionName ];\\n            return function () {\\n                //Notify.log(\\\"call: \\\" + functionName);\\n                var result = f.apply( original, arguments );\\n                return result;\\n            };\\n        }\\n\\n        /**\\n         * Given a WebGL context returns a wrapped context that calls\\n         * gl.getError after every command and calls a function if the\\n         * result is not gl.NO_ERROR.\\n         *\\n         * @param {!WebGLRenderingContext} ctx The webgl context to\\n         *        wrap.\\n         * @param {!function(err, funcName, args): void} opt_onErrorFunc\\n         *        The function to call when gl.getError returns an\\n         *        error. If not specified the default function calls\\n         *        Notify.log with a message.\\n         */\\n        function makeDebugContext( ctx, opt_onErrorFunc ) {\\n            init( ctx );\\n            opt_onErrorFunc = opt_onErrorFunc || function ( err, functionName, args ) {\\n                // apparently we can\\'t do args.join(\\\",\\\");\\n                var argStr = \\\"\\\";\\n                for ( var ii = 0; ii < args.length; ++ii ) {\\n                    argStr += ( ( ii === 0 ) ? \\'\\' : \\', \\' ) +\\n                        glFunctionArgToString( functionName, ii, args[ ii ] );\\n                }\\n                Notify.log( \\\"WebGL error \\\" + glEnumToString( err ) + \\\" in \\\" + functionName +\\n                    \\\"(\\\" + argStr + \\\")\\\" );\\n            };\\n\\n            // Holds booleans for each GL error so after we get the error ourselves\\n            // we can still return it to the client app.\\n            var glErrorShadow = {};\\n\\n            // Makes a function that calls a WebGL function and then calls getError.\\n            function makeErrorWrapper( ctx, functionName ) {\\n                return function () {\\n                    var result = ctx[ functionName ].apply( ctx, arguments );\\n                    var err = ctx.getError();\\n                    if ( err !== 0 ) {\\n                        glErrorShadow[ err ] = true;\\n                        opt_onErrorFunc( err, functionName, arguments );\\n                    }\\n                    return result;\\n                };\\n            }\\n\\n            // Make a an object that has a copy of every property of the WebGL context\\n            // but wraps all functions.\\n            var wrapper = {};\\n            for ( var propertyName in ctx ) {\\n                if ( typeof ctx[ propertyName ] == \\'function\\' ) {\\n                    wrapper[ propertyName ] = makeErrorWrapper( ctx, propertyName );\\n                } else {\\n                    makePropertyWrapper( wrapper, ctx, propertyName );\\n                }\\n            }\\n\\n            // Override the getError function with one that returns our saved results.\\n            wrapper.getError = function () {\\n                for ( var err in glErrorShadow ) {\\n                    if ( glErrorShadow[ err ] ) {\\n                        glErrorShadow[ err ] = false;\\n                        return err;\\n                    }\\n                }\\n                return ctx.NO_ERROR;\\n            };\\n\\n            return wrapper;\\n        }\\n\\n        function resetToInitialState( ctx ) {\\n            var numAttribs = ctx.getParameter( ctx.MAX_VERTEX_ATTRIBS );\\n            var tmp = ctx.createBuffer();\\n            ctx.bindBuffer( ctx.ARRAY_BUFFER, tmp );\\n            var ii;\\n            for ( ii = 0; ii < numAttribs; ++ii ) {\\n                ctx.disableVertexAttribArray( ii );\\n                ctx.vertexAttribPointer( ii, 4, ctx.FLOAT, false, 0, 0 );\\n                ctx.vertexAttrib1f( ii, 0 );\\n            }\\n            ctx.deleteBuffer( tmp );\\n\\n            var numTextureUnits = ctx.getParameter( ctx.MAX_TEXTURE_IMAGE_UNITS );\\n            for ( ii = 0; ii < numTextureUnits; ++ii ) {\\n                ctx.activeTexture( ctx.TEXTURE0 + ii );\\n                ctx.bindTexture( ctx.TEXTURE_CUBE_MAP, null );\\n                ctx.bindTexture( ctx.TEXTURE_2D, null );\\n            }\\n\\n            ctx.activeTexture( ctx.TEXTURE0 );\\n            ctx.useProgram( null );\\n            ctx.bindBuffer( ctx.ARRAY_BUFFER, null );\\n            ctx.bindBuffer( ctx.ELEMENT_ARRAY_BUFFER, null );\\n            ctx.bindFramebuffer( ctx.FRAMEBUFFER, null );\\n            ctx.bindRenderbuffer( ctx.RENDERBUFFER, null );\\n            ctx.disable( ctx.BLEND );\\n            ctx.disable( ctx.CULL_FACE );\\n            ctx.disable( ctx.DEPTH_TEST );\\n            ctx.disable( ctx.DITHER );\\n            ctx.disable( ctx.SCISSOR_TEST );\\n            ctx.blendColor( 0, 0, 0, 0 );\\n            ctx.blendEquation( ctx.FUNC_ADD );\\n            ctx.blendFunc( ctx.ONE, ctx.ZERO );\\n            ctx.clearColor( 0, 0, 0, 0 );\\n            ctx.clearDepth( 1 );\\n            ctx.clearStencil( -1 );\\n            ctx.colorMask( true, true, true, true );\\n            ctx.cullFace( ctx.BACK );\\n            ctx.depthFunc( ctx.LESS );\\n            ctx.depthMask( true );\\n            ctx.depthRange( 0, 1 );\\n            ctx.frontFace( ctx.CCW );\\n            ctx.hint( ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE );\\n            ctx.lineWidth( 1 );\\n            ctx.pixelStorei( ctx.PACK_ALIGNMENT, 4 );\\n            ctx.pixelStorei( ctx.UNPACK_ALIGNMENT, 4 );\\n            ctx.pixelStorei( ctx.UNPACK_FLIP_Y_WEBGL, false );\\n            ctx.pixelStorei( ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false );\\n            // TODO: Delete this IF.\\n            if ( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL ) {\\n                ctx.pixelStorei( ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL );\\n            }\\n            ctx.polygonOffset( 0, 0 );\\n            ctx.sampleCoverage( 1, false );\\n            ctx.scissor( 0, 0, ctx.canvas.width, ctx.canvas.height );\\n            ctx.stencilFunc( ctx.ALWAYS, 0, 0xFFFFFFFF );\\n            ctx.stencilMask( 0xFFFFFFFF );\\n            ctx.stencilOp( ctx.KEEP, ctx.KEEP, ctx.KEEP );\\n            ctx.viewport( 0, 0, ctx.canvas.width, ctx.canvas.height );\\n            ctx.clear( ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT );\\n\\n            // TODO: This should NOT be needed but Firefox fails with \\'hint\\'\\n            while ( ctx.getError() ) {}\\n        }\\n\\n        function makeLostContextSimulatingCanvas( canvas ) {\\n            var unwrappedContext_;\\n            //var wrappedContext_;\\n            var onLost_ = [];\\n            var onRestored_ = [];\\n            var wrappedContext_ = {};\\n            var contextId_ = 1;\\n            var contextLost_ = false;\\n            var resourceId_ = 0;\\n            var resourceDb_ = [];\\n            var numCallsToLoseContext_ = 0;\\n            var numCalls_ = 0;\\n            var canRestore_ = false;\\n            var restoreTimeout_ = 0;\\n\\n            // Holds booleans for each GL error so can simulate errors.\\n            var glErrorShadow_ = {};\\n\\n            canvas.getContext = function ( f ) {\\n                return function () {\\n                    var ctx = f.apply( canvas, arguments );\\n                    // Did we get a context and is it a WebGL context?\\n                    if ( ctx instanceof WebGLRenderingContext ) {\\n                        if ( ctx != unwrappedContext_ ) {\\n                            if ( unwrappedContext_ ) {\\n                                throw \\\"got different context\\\";\\n                            }\\n                            unwrappedContext_ = ctx;\\n                            wrappedContext_ = makeLostContextSimulatingContext( unwrappedContext_ );\\n                        }\\n                        return wrappedContext_;\\n                    }\\n                    return ctx;\\n                };\\n            }( canvas.getContext );\\n\\n            function wrapEvent( listener ) {\\n                if ( typeof ( listener ) == \\\"function\\\" ) {\\n                    return listener;\\n                } else {\\n                    return function ( info ) {\\n                        listener.handleEvent( info );\\n                    };\\n                }\\n            }\\n\\n            var addOnContextLostListener = function ( listener ) {\\n                onLost_.push( wrapEvent( listener ) );\\n            };\\n\\n            var addOnContextRestoredListener = function ( listener ) {\\n                onRestored_.push( wrapEvent( listener ) );\\n            };\\n\\n\\n            function wrapAddEventListener( canvas ) {\\n                var f = canvas.addEventListener;\\n                canvas.addEventListener = function ( type, listener, bubble ) {\\n                    switch ( type ) {\\n                    case \\'webglcontextlost\\':\\n                        addOnContextLostListener( listener );\\n                        break;\\n                    case \\'webglcontextrestored\\':\\n                        addOnContextRestoredListener( listener );\\n                        break;\\n                    default:\\n                        f.apply( canvas, arguments );\\n                    }\\n                };\\n            }\\n\\n            wrapAddEventListener( canvas );\\n\\n            canvas.loseContext = function () {\\n                if ( !contextLost_ ) {\\n                    contextLost_ = true;\\n                    numCallsToLoseContext_ = 0;\\n                    ++contextId_;\\n                    while ( unwrappedContext_.getError() ) {}\\n                    clearErrors();\\n                    glErrorShadow_[ unwrappedContext_.CONTEXT_LOST_WEBGL ] = true;\\n                    var event = makeWebGLContextEvent( \\\"context lost\\\" );\\n                    var callbacks = onLost_.slice();\\n                    setTimeout( function () {\\n                        //Notify.log(\\\"numCallbacks:\\\" + callbacks.length);\\n                        for ( var ii = 0; ii < callbacks.length; ++ii ) {\\n                            //Notify.log(\\\"calling callback:\\\" + ii);\\n                            callbacks[ ii ]( event );\\n                        }\\n                        if ( restoreTimeout_ >= 0 ) {\\n                            setTimeout( function () {\\n                                canvas.restoreContext();\\n                            }, restoreTimeout_ );\\n                        }\\n                    }, 0 );\\n                }\\n            };\\n\\n            canvas.restoreContext = function () {\\n                if ( contextLost_ ) {\\n                    if ( onRestored_.length ) {\\n                        setTimeout( function () {\\n                            if ( !canRestore_ ) {\\n                                throw \\\"can not restore. webglcontestlost listener did not call event.preventDefault\\\";\\n                            }\\n                            freeResources();\\n                            resetToInitialState( unwrappedContext_ );\\n                            contextLost_ = false;\\n                            numCalls_ = 0;\\n                            canRestore_ = false;\\n                            var callbacks = onRestored_.slice();\\n                            var event = makeWebGLContextEvent( \\\"context restored\\\" );\\n                            for ( var ii = 0; ii < callbacks.length; ++ii ) {\\n                                callbacks[ ii ]( event );\\n                            }\\n                        }, 0 );\\n                    }\\n                }\\n            };\\n\\n            canvas.loseContextInNCalls = function ( numCalls ) {\\n                if ( contextLost_ ) {\\n                    throw \\\"You can not ask a lost contet to be lost\\\";\\n                }\\n                numCallsToLoseContext_ = numCalls_ + numCalls;\\n            };\\n\\n            canvas.getNumCalls = function () {\\n                return numCalls_;\\n            };\\n\\n            canvas.setRestoreTimeout = function ( timeout ) {\\n                restoreTimeout_ = timeout;\\n            };\\n\\n            function isWebGLObject( obj ) {\\n                //return false;\\n                return ( obj instanceof WebGLBuffer ||\\n                    obj instanceof WebGLFramebuffer ||\\n                    obj instanceof WebGLProgram ||\\n                    obj instanceof WebGLRenderbuffer ||\\n                    obj instanceof WebGLShader ||\\n                    obj instanceof WebGLTexture );\\n            }\\n\\n            function checkResources( args ) {\\n                for ( var ii = 0; ii < args.length; ++ii ) {\\n                    var arg = args[ ii ];\\n                    if ( isWebGLObject( arg ) ) {\\n                        return arg.__webglDebugContextLostId__ == contextId_;\\n                    }\\n                }\\n                return true;\\n            }\\n\\n            function clearErrors() {\\n                var k = Object.keys( glErrorShadow_ );\\n                for ( var ii = 0; ii < k.length; ++ii ) {\\n                    delete glErrorShadow_[ k ];\\n                }\\n            }\\n\\n            function loseContextIfTime() {\\n                ++numCalls_;\\n                if ( !contextLost_ ) {\\n                    if ( numCallsToLoseContext_ == numCalls_ ) {\\n                        canvas.loseContext();\\n                    }\\n                }\\n            }\\n\\n            // Makes a function that simulates WebGL when out of context.\\n            function makeLostContextFunctionWrapper( ctx, functionName ) {\\n                var f = ctx[ functionName ];\\n                return function () {\\n                    // Notify.log(\\\"calling:\\\" + functionName);\\n                    // Only call the functions if the context is not lost.\\n                    loseContextIfTime();\\n                    if ( !contextLost_ ) {\\n                        //if (!checkResources(arguments)) {\\n                        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;\\n                        //  return;\\n                        //}\\n                        var result = f.apply( ctx, arguments );\\n                        return result;\\n                    }\\n                };\\n            }\\n\\n            function freeResources() {\\n                for ( var ii = 0; ii < resourceDb_.length; ++ii ) {\\n                    var resource = resourceDb_[ ii ];\\n                    if ( resource instanceof WebGLBuffer ) {\\n                        unwrappedContext_.deleteBuffer( resource );\\n                    } else if ( resource instanceof WebGLFramebuffer ) {\\n                        unwrappedContext_.deleteFramebuffer( resource );\\n                    } else if ( resource instanceof WebGLProgram ) {\\n                        unwrappedContext_.deleteProgram( resource );\\n                    } else if ( resource instanceof WebGLRenderbuffer ) {\\n                        unwrappedContext_.deleteRenderbuffer( resource );\\n                    } else if ( resource instanceof WebGLShader ) {\\n                        unwrappedContext_.deleteShader( resource );\\n                    } else if ( resource instanceof WebGLTexture ) {\\n                        unwrappedContext_.deleteTexture( resource );\\n                    }\\n                }\\n            }\\n\\n            function makeWebGLContextEvent( statusMessage ) {\\n                return {\\n                    statusMessage: statusMessage,\\n                    preventDefault: function () {\\n                        canRestore_ = true;\\n                    }\\n                };\\n            }\\n\\n\\n            function makeLostContextSimulatingContext( ctx ) {\\n                // copy all functions and properties to wrapper\\n                for ( var propertyName in ctx ) {\\n                    if ( typeof ctx[ propertyName ] == \\'function\\' ) {\\n                        wrappedContext_[ propertyName ] = makeLostContextFunctionWrapper(\\n                            ctx, propertyName );\\n                    } else {\\n                        makePropertyWrapper( wrappedContext_, ctx, propertyName );\\n                    }\\n                }\\n\\n                // Wrap a few functions specially.\\n                wrappedContext_.getError = function () {\\n                    loseContextIfTime();\\n                    var err;\\n                    if ( !contextLost_ ) {\\n                        while ( err = unwrappedContext_.getError() ) {\\n                            glErrorShadow_[ err ] = true;\\n                        }\\n                    }\\n                    for ( err in glErrorShadow_ ) {\\n                        if ( glErrorShadow_[ err ] ) {\\n                            delete glErrorShadow_[ err ];\\n                            return err;\\n                        }\\n                    }\\n                    return wrappedContext_.NO_ERROR;\\n                };\\n\\n                var creationFunctions = [\\n                    \\\"createBuffer\\\",\\n                    \\\"createFramebuffer\\\",\\n                    \\\"createProgram\\\",\\n                    \\\"createRenderbuffer\\\",\\n                    \\\"createShader\\\",\\n                    \\\"createTexture\\\"\\n                ];\\n                var functionName, ii;\\n                for ( ii = 0; ii < creationFunctions.length; ++ii ) {\\n                    functionName = creationFunctions[ ii ];\\n                    wrappedContext_[ functionName ] = function ( f ) {\\n                        return function () {\\n                            loseContextIfTime();\\n                            if ( contextLost_ ) {\\n                                return null;\\n                            }\\n                            var obj = f.apply( ctx, arguments );\\n                            obj.__webglDebugContextLostId__ = contextId_;\\n                            resourceDb_.push( obj );\\n                            return obj;\\n                        };\\n                    }( ctx[ functionName ] );\\n                }\\n\\n                var functionsThatShouldReturnNull = [\\n                    \\\"getActiveAttrib\\\",\\n                    \\\"getActiveUniform\\\",\\n                    \\\"getBufferParameter\\\",\\n                    \\\"getContextAttributes\\\",\\n                    \\\"getAttachedShaders\\\",\\n                    \\\"getFramebufferAttachmentParameter\\\",\\n                    \\\"getParameter\\\",\\n                    \\\"getProgramParameter\\\",\\n                    \\\"getProgramInfoLog\\\",\\n                    \\\"getRenderbufferParameter\\\",\\n                    \\\"getShaderParameter\\\",\\n                    \\\"getShaderInfoLog\\\",\\n                    \\\"getShaderSource\\\",\\n                    \\\"getTexParameter\\\",\\n                    \\\"getUniform\\\",\\n                    \\\"getUniformLocation\\\",\\n                    \\\"getVertexAttrib\\\"\\n                ];\\n                for ( ii = 0; ii < functionsThatShouldReturnNull.length; ++ii ) {\\n                    functionName = functionsThatShouldReturnNull[ ii ];\\n                    wrappedContext_[ functionName ] = function ( f ) {\\n                        return function () {\\n                            loseContextIfTime();\\n                            if ( contextLost_ ) {\\n                                return null;\\n                            }\\n                            return f.apply( ctx, arguments );\\n                        };\\n                    }( wrappedContext_[ functionName ] );\\n                }\\n\\n                var isFunctions = [\\n                    \\\"isBuffer\\\",\\n                    \\\"isEnabled\\\",\\n                    \\\"isFramebuffer\\\",\\n                    \\\"isProgram\\\",\\n                    \\\"isRenderbuffer\\\",\\n                    \\\"isShader\\\",\\n                    \\\"isTexture\\\"\\n                ];\\n                for ( ii = 0; ii < isFunctions.length; ++ii ) {\\n                    functionName = isFunctions[ ii ];\\n                    wrappedContext_[ functionName ] = function ( f ) {\\n                        return function () {\\n                            loseContextIfTime();\\n                            if ( contextLost_ ) {\\n                                return false;\\n                            }\\n                            return f.apply( ctx, arguments );\\n                        };\\n                    }( wrappedContext_[ functionName ] );\\n                }\\n\\n                wrappedContext_.checkFramebufferStatus = function ( f ) {\\n                    return function () {\\n                        loseContextIfTime();\\n                        if ( contextLost_ ) {\\n                            return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;\\n                        }\\n                        return f.apply( ctx, arguments );\\n                    };\\n                }( wrappedContext_.checkFramebufferStatus );\\n\\n                wrappedContext_.getAttribLocation = function ( f ) {\\n                    return function () {\\n                        loseContextIfTime();\\n                        if ( contextLost_ ) {\\n                            return -1;\\n                        }\\n                        return f.apply( ctx, arguments );\\n                    };\\n                }( wrappedContext_.getAttribLocation );\\n\\n                wrappedContext_.getVertexAttribOffset = function ( f ) {\\n                    return function () {\\n                        loseContextIfTime();\\n                        if ( contextLost_ ) {\\n                            return 0;\\n                        }\\n                        return f.apply( ctx, arguments );\\n                    };\\n                }( wrappedContext_.getVertexAttribOffset );\\n\\n                wrappedContext_.isContextLost = function () {\\n                    return contextLost_;\\n                };\\n\\n                return wrappedContext_;\\n            }\\n\\n            // TODO: find why this is there ?\\n            return canvas;\\n        }\\n\\n        return {\\n            /**\\n     * Initializes this module. Safe to call more than once.\\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\\n    }\\n   *    you have more than one context it doesn\\'t matter which one\\n   *    you pass in, it is only used to pull out constants.\\n   */\\n            \\'init\\': init,\\n\\n            /**\\n             * Returns true or false if value matches any WebGL enum\\n             * @param {*} value Value to check if it might be an enum.\\n             * @return {boolean} True if value matches one of the WebGL defined enums\\n             */\\n            \\'mightBeEnum\\': mightBeEnum,\\n\\n            /**\\n             * Gets an string version of an WebGL enum.\\n             *\\n             * Example:\\n             *   WebGLDebugUtil.init(ctx);\\n             *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\\n             *\\n             * @param {number} value Value to return an enum for\\n             * @return {string} The string version of the enum.\\n             */\\n            \\'glEnumToString\\': glEnumToString,\\n\\n            /**\\n             * Converts the argument of a WebGL function to a string.\\n             * Attempts to convert enum arguments to strings.\\n             *\\n             * Example:\\n             *   WebGLDebugUtil.init(ctx);\\n             *   var str = WebGLDebugUtil.glFunctionArgToString(\\'bindTexture\\', 0, gl.TEXTURE_2D);\\n             *\\n             * would return \\'TEXTURE_2D\\'\\n             *\\n             * @param {string} functionName the name of the WebGL function.\\n             * @param {number} argumentIndx the index of the argument.\\n             * @param {*} value The value of the argument.\\n             * @return {string} The value as a string.\\n             */\\n            \\'glFunctionArgToString\\': glFunctionArgToString,\\n\\n            /**\\n             * Given a WebGL context returns a wrapped context that calls\\n             * gl.getError after every command and calls a function if the\\n             * result is not NO_ERROR.\\n             *\\n             * You can supply your own function if you want. For example, if you\\'d like\\n             * an exception thrown on any GL error you could do this\\n             *\\n             *    function throwOnGLError(err, funcName, args) {\\n             *      throw WebGLDebugUtils.glEnumToString(err) + \\\" was caused by call to\\\" +\\n             *            funcName;\\n             *    };\\n             *\\n             *    ctx = WebGLDebugUtils.makeDebugContext(\\n             *        canvas.getContext(\\\"webgl\\\"), throwOnGLError);\\n             *\\n             * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\\n             * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\\n             *     to call when gl.getError returns an error. If not specified the default\\n             *     function calls Notify.log with a message.\\n             */\\n            \\'makeDebugContext\\': makeDebugContext,\\n\\n            /**\\n             * Given a canvas element returns a wrapped canvas element that will\\n             * simulate lost context. The canvas returned adds the following functions.\\n             *\\n             * loseContext:\\n             *   simulates a lost context event.\\n             *\\n             * restoreContext:\\n             *   simulates the context being restored.\\n             *\\n             * lostContextInNCalls:\\n             *   loses the context after N gl calls.\\n             *\\n             * getNumCalls:\\n             *   tells you how many gl calls there have been so far.\\n             *\\n             * setRestoreTimeout:\\n             *   sets the number of milliseconds until the context is restored\\n             *   after it has been lost. Defaults to 0. Pass -1 to prevent\\n             *   automatic restoring.\\n             *\\n             * @param {!Canvas} canvas The canvas element to wrap.\\n             */\\n            \\'makeLostContextSimulatingCanvas\\': makeLostContextSimulatingCanvas,\\n\\n            /**\\n             * Resets a context to the initial state.\\n             * @param {!WebGLRenderingContext} ctx The webgl context to\\n             *     reset.\\n             */\\n            \\'resetToInitialState\\': resetToInitialState\\n        };\\n\\n    }();\\n\\n    return WebGLDebugUtils;\\n} );\\n\\n/* jshint ignore:end */\\n\\n//# sourceURL=/osgViewer/webgl-debug.js\");\n\n",
    "eval(\"define( \\'osgViewer/stats\\',[\\n    \\'osg/Utils\\'\\n], function ( MACROUTILS ) {\\n\\n    var Stats = {};\\n\\n    Stats.Stats = function ( canvas, textCanvas ) {\\n        this.layers = [];\\n        this.lastUpdate = undefined;\\n        this.canvas = canvas;\\n        this.textCanvas = textCanvas;\\n        this.numberUpdate = 0;\\n    };\\n\\n    Stats.Stats.prototype = {\\n        addLayer: function ( color, maxVal, getter, texter ) {\\n            if ( color === undefined ) {\\n                color = \\'rgb(255,255,255)\\';\\n            }\\n            this.layers.push( {\\n                previous: 0,\\n                color: color,\\n                getValue: getter,\\n                getText: texter,\\n                average: 0,\\n                max: maxVal\\n            } );\\n        },\\n\\n        update: function () {\\n\\n            var delta, i, l, layer, value, c, ctx, height, myImageData, t = MACROUTILS.performance.now();\\n            if ( this.lastUpdate === undefined ) {\\n                this.lastUpdate = t;\\n            }\\n            this.numberUpdate++;\\n            for ( i = 0, l = this.layers.length; i < l; i++ ) {\\n                layer = this.layers[ i ];\\n                value = layer.getValue( t );\\n                layer.average += value;\\n            }\\n            //i = 2.0 * 60.0 / 1000.0;\\n            i = 0.12; //4.0 * 60.0 / 1000.0;\\n            delta = ( t - this.lastUpdate ) * i;\\n            if ( delta >= 1.0 ) {\\n\\n                t -= ( delta - Math.floor( delta ) ) / i;\\n                delta = Math.floor( delta );\\n\\n                c = this.canvas;\\n                ctx = c.getContext( \\'2d\\' );\\n\\n                myImageData = ctx.getImageData( delta, 0, c.width - delta, c.height );\\n                ctx.putImageData( myImageData, 0, 0 );\\n                ctx.clearRect( c.width - delta, 0, delta, c.height );\\n\\n                for ( i = 0, l = this.layers.length; i < l; i++ ) {\\n                    layer = this.layers[ i ];\\n                    value = layer.getValue( t );\\n                    value *= c.height / layer.max;\\n                    if ( value > c.height ) value = c.height;\\n                    ctx.lineWidth = 1.0;\\n                    ctx.strokeStyle = layer.color;\\n                    ctx.beginPath();\\n                    ctx.moveTo( c.width - delta, c.height - layer.previous );\\n                    ctx.lineTo( c.width, c.height - value );\\n                    ctx.stroke();\\n                    layer.previous = value;\\n                }\\n            }\\n\\n            if ( this.numberUpdate % 60 === 0 ) {\\n                c = this.textCanvas;\\n                ctx = c.getContext( \\'2d\\' );\\n                ctx.font = \\'14px Sans\\';\\n                height = 17;\\n                delta = height;\\n                ctx.clearRect( 0, 0, c.width, c.height );\\n                for ( i = 0, l = this.layers.length; i < l; i++ ) {\\n                    layer = this.layers[ i ];\\n                    value = layer.getText( layer.average / this.numberUpdate );\\n                    layer.average = 0;\\n                    ctx.fillStyle = layer.color;\\n                    ctx.fillText( value, 0, delta );\\n                    delta += height;\\n                }\\n                this.numberUpdate = 0;\\n            }\\n            this.lastUpdate = t;\\n        }\\n    };\\n\\n    return Stats;\\n} );\\n\\n//# sourceURL=/osgViewer/stats.js\");\n\n",
    "eval(\"define( \\'osgViewer/Viewer\\',[\\n    \\'osg/Notify\\',\\n    \\'osg/Utils\\',\\n    \\'osg/UpdateVisitor\\',\\n    \\'osg/CullVisitor\\',\\n    \\'osgUtil/osgUtil\\',\\n    \\'osgViewer/View\\',\\n    \\'osg/RenderStage\\',\\n    \\'osg/StateGraph\\',\\n    \\'osg/Matrix\\',\\n    \\'osg/State\\',\\n    \\'osgGA/OrbitManipulator\\',\\n    \\'osgViewer/eventProxy/EventProxy\\',\\n    \\'osgViewer/webgl-utils\\',\\n    \\'osgViewer/webgl-debug\\',\\n    \\'osgViewer/stats\\'\\n], function ( Notify, MACROUTILS, UpdateVisitor, CullVisitor, osgUtil, View, RenderStage, StateGraph, Matrix, State, OrbitManipulator, EventProxy, WebGLUtils, WebGLDebugUtils, Stats ) {\\n\\n\\n    var OptionsDefault = {\\n        \\'antialias\\': true,\\n        \\'useDevicePixelRatio\\': true,\\n        \\'fullscreen\\': true,\\n        \\'enableFrustumCulling\\': false\\n    };\\n\\n\\n    var Options = function( defaults ) {\\n\\n        Object.keys( defaults ).forEach( function ( key ) {\\n            this[ key ] = defaults[ key ];\\n        }.bind( this ) );\\n\\n    };\\n\\n    Options.prototype = {\\n        get: function( key ) {\\n            return this[key];\\n        },\\n        getBoolean: function ( key ) {\\n            var val = this.getString( key );\\n            if ( val ) return Boolean( JSON.parse(val) );\\n            return undefined;\\n        },\\n\\n        getNumber: function ( key ) {\\n            var val = this[ key ];\\n            if ( val ) return Number( JSON.parse(val));\\n            return undefined;\\n        },\\n\\n        getString: function ( key ) {\\n            var val = this[ key ];\\n            if ( val ) return this[ key ].toString();\\n            return undefined;\\n        }\\n\\n    };\\n\\n    var OptionsURL = ( function () {\\n        var options = {};\\n        ( function ( options ) {\\n            var vars = [],\\n                hash;\\n            var indexOptions = window.location.href.indexOf( \\'?\\' );\\n            if ( indexOptions < 0 ) return;\\n\\n            var hashes = window.location.href.slice( indexOptions + 1 ).split( \\'&\\' );\\n            for ( var i = 0; i < hashes.length; i++ ) {\\n                hash = hashes[ i ].split( \\'=\\' );\\n                var element = hash[ 0 ];\\n                vars.push( element );\\n                var result = hash[ 1 ];\\n                if ( result === undefined ) {\\n                    result = \\'1\\';\\n                }\\n                options[ element ] = result;\\n            }\\n        } )( options );\\n\\n        if ( options.log !== undefined ) {\\n            var level = options.log.toLowerCase();\\n\\n            switch ( level ) {\\n            case \\'debug\\':\\n                Notify.setNotifyLevel( Notify.DEBUG );\\n                break;\\n            case \\'info\\':\\n                Notify.setNotifyLevel( Notify.INFO );\\n                break;\\n            case \\'notice\\':\\n                Notify.setNotifyLevel( Notify.NOTICE );\\n                break;\\n            case \\'warn\\':\\n                Notify.setNotifyLevel( Notify.WARN );\\n                break;\\n            case \\'error\\':\\n                Notify.setNotifyLevel( Notify.ERROR );\\n                break;\\n            case \\'html\\':\\n                ( function () {\\n                    var logContent = [];\\n                    var divLogger = document.createElement( \\'div\\' );\\n                    var codeElement = document.createElement( \\'pre\\' );\\n                    document.addEventListener( \\'DOMContentLoaded\\', function () {\\n                        document.body.appendChild( divLogger );\\n                        divLogger.appendChild( codeElement );\\n                    } );\\n                    var logFunc = function ( str ) {\\n                        logContent.unshift( str );\\n                        codeElement.innerHTML = logContent.join( \\'\\\\n\\' );\\n                    };\\n                    divLogger.style.overflow = \\'hidden\\';\\n                    divLogger.style.position = \\'absolute\\';\\n                    divLogger.style.zIndex = \\'10000\\';\\n                    divLogger.style.height = \\'100%\\';\\n                    divLogger.style.maxWidth = \\'600px\\';\\n                    codeElement.style.overflow = \\'scroll\\';\\n                    codeElement.style.width = \\'105%\\';\\n                    codeElement.style.height = \\'100%\\';\\n                    codeElement.style.fontSize = \\'10px\\';\\n\\n                    [ \\'log\\', \\'error\\', \\'warn\\', \\'info\\', \\'debug\\' ].forEach( function ( value ) {\\n                        window.console[ value ] = logFunc;\\n                    } );\\n                } )();\\n                break;\\n            }\\n        }\\n\\n        return options;\\n    } )();\\n\\n    var Viewer = function ( canvas, userOptions, error ) {\\n        View.call( this );\\n\\n        // use default options\\n        var options = new Options( OptionsDefault );\\n        if ( userOptions ) {\\n            // user options override by user options\\n            MACROUTILS.objectMix( options, userOptions );\\n        }\\n        // if url options override url options\\n        MACROUTILS.objectMix( options, OptionsURL );\\n\\n        this._options = options;\\n\\n        // #FIXME see tojiro\\'s blog for webgl lost context stuffs\\n        if ( options.get( \\'SimulateWebGLLostContext\\') ) {\\n            canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas( canvas );\\n            canvas.loseContextInNCalls( options.get( \\'SimulateWebGLLostContext\\' ) );\\n        }\\n\\n        var gl = WebGLUtils.setupWebGL( canvas, options, error );\\n        var self = this;\\n        canvas.addEventListener( \\'webglcontextlost\\', function ( event ) {\\n            self.contextLost();\\n            event.preventDefault();\\n        }, false );\\n\\n        canvas.addEventListener( \\'webglcontextrestored\\', function () {\\n            self.contextRestored();\\n        }, false );\\n\\n\\n        if ( Notify.reportWebGLError || options.get( \\'reportWebGLError\\') ) {\\n            gl = WebGLDebugUtils.makeDebugContext( gl );\\n        }\\n\\n        if ( gl ) {\\n            this.setGraphicContext( gl );\\n            this.initWebGLCaps( gl );\\n\\n            MACROUTILS.init();\\n            this._frameRate = 60.0;\\n            osgUtil.UpdateVisitor = UpdateVisitor;\\n            osgUtil.CullVisitor = CullVisitor;\\n\\n            // default argument for mouse binding\\n            var defaultMouseEventNode = options.mouseEventNode || canvas;\\n\\n            var eventsBackend = options.EventBackend || {};\\n            if ( !options.EventBackend )  options.EventBackend = eventsBackend;\\n            eventsBackend.StandardMouseKeyboard = options.EventBackend.StandardMouseKeyboard || {};\\n            var mouseEventNode = eventsBackend.StandardMouseKeyboard.mouseEventNode || defaultMouseEventNode;\\n            eventsBackend.StandardMouseKeyboard.mouseEventNode = mouseEventNode;\\n            eventsBackend.StandardMouseKeyboard.keyboardEventNode = eventsBackend.StandardMouseKeyboard.keyboardEventNode || document;\\n\\n            // hammer\\n            eventsBackend.Hammer = eventsBackend.Hammer || {};\\n            eventsBackend.Hammer.eventNode = eventsBackend.Hammer.eventNode || defaultMouseEventNode;\\n\\n            // gamepade\\n            eventsBackend.GamePad = eventsBackend.GamePad || {};\\n\\n            this.setUpView( gl.canvas );\\n        } else {\\n            throw \\'No WebGL implementation found\\';\\n        }\\n    };\\n\\n\\n    Viewer.prototype = MACROUTILS.objectInehrit( View.prototype, {\\n\\n        contextLost: function () {\\n            Notify.log( \\'webgl context lost\\' );\\n            window.cancelRequestAnimFrame( this._requestID );\\n        },\\n        contextRestored: function () {\\n            Notify.log( \\'webgl context restored, but not supported - reload the page\\' );\\n        },\\n\\n        init: function () {\\n            this._done = false;\\n            this._state = new State();\\n\\n            var gl = this.getGraphicContext();\\n            this._state.setGraphicContext( gl );\\n            gl.pixelStorei( gl.UNPACK_FLIP_Y_WEBGL, true );\\n\\n            this._updateVisitor = new osgUtil.UpdateVisitor();\\n            this._cullVisitor = new osgUtil.CullVisitor();\\n            // It should be done in RenderStage\\n            this._cullVisitor.setCamera( this.getCamera() );\\n            this._renderStage = new RenderStage();\\n            this._stateGraph = new StateGraph();\\n\\n            this.parseOptions();\\n\\n            this.getCamera().setClearColor( [ 0.0, 0.0, 0.0, 0.0 ] );\\n            this._eventProxy = this.initEventProxy( this._options );\\n        },\\n        getState: function () {\\n            // would have more sense to be in view\\n            // but I would need to put cull and draw on lower Object\\n            // in View or a new Renderer object\\n            return this._state;\\n        },\\n\\n        parseOptions: function () {\\n\\n            if ( this._options.stats ) {\\n                this.initStats( this._options );\\n            }\\n\\n        },\\n\\n        initStats: function ( options ) {\\n\\n            var maxMS = 35;\\n            var stepMS = 5;\\n            //var fontsize = 14;\\n\\n            if ( options.statsMaxMS !== undefined ) {\\n                maxMS = parseInt( options.statsMaxMS, 10 );\\n            }\\n            if ( options.statsStepMS !== undefined ) {\\n                stepMS = parseInt( options.statsStepMS, 10 );\\n            }\\n\\n            var createDomElements = function ( elementToAppend ) {\\n                var dom = [\\n                    \\'<div id=\\\"StatsDiv\\\" style=\\\"top: 0; position: absolute; width: 300px; height: 150px; z-index: 10;\\\">\\',\\n\\n                    \\'<div id=\\\"StatsCanvasDiv\\\" style=\\\"position: relative;\\\">\\',\\n                    \\'<canvas id=\\\"StatsCanvasGrid\\\" width=\\\"300\\\" height=\\\"150\\\" style=\\\"z-index:-1; position: absolute; background: rgba(14,14,14,0.8); \\\" ></canvas>\\',\\n                    \\'<canvas id=\\\"StatsCanvas\\\" width=\\\"300\\\" height=\\\"150\\\" style=\\\"z-index:8; position: absolute;\\\" ></canvas>\\',\\n                    \\'<canvas id=\\\"StatsCanvasText\\\" width=\\\"300\\\" height=\\\"150\\\" style=\\\"z-index:9; position: absolute;\\\" ></canvas>\\',\\n                    \\'</div>\\',\\n\\n                    \\'</div>\\'\\n                ].join( \\'\\\\n\\' );\\n                var parent;\\n                if ( elementToAppend === undefined ) {\\n                    parent = document.body;\\n                    //elementToAppend = \\'body\\';\\n                } else {\\n                    parent = document.getElementById( elementToAppend );\\n                }\\n\\n                //jQuery(dom).appendTo(elementToAppend);\\n                var mydiv = document.createElement( \\'div\\' );\\n                mydiv.innerHTML = dom;\\n                parent.appendChild( mydiv );\\n\\n                var grid = document.getElementById( \\'StatsCanvasGrid\\' );\\n                var ctx = grid.getContext( \\'2d\\' );\\n                ctx.clearRect( 0, 0, grid.width, grid.height );\\n\\n                var step = Math.floor( maxMS / stepMS ).toFixed( 0 );\\n                var r = grid.height / step;\\n                ctx.strokeStyle = \\'rgb(70,70,70)\\';\\n                for ( var i = 0, l = step; i < l; i++ ) {\\n                    ctx.beginPath();\\n                    ctx.moveTo( 0, i * r );\\n                    ctx.lineTo( grid.width, i * r );\\n                    ctx.stroke();\\n                }\\n\\n\\n                return {\\n                    graph: document.getElementById( \\'StatsCanvas\\' ),\\n                    text: document.getElementById( \\'StatsCanvasText\\' )\\n                };\\n            };\\n\\n            if ( this._canvasStats === undefined || this._canvasStats === null ) {\\n                var domStats = createDomElements();\\n                this._canvasStats = domStats.graph;\\n                this._canvasStatsText = domStats.text;\\n            }\\n            this._stats = new Stats.Stats( this._canvasStats, this._canvasStatsText );\\n            var that = this;\\n            this._frameRate = 1;\\n            this._frameTime = 0;\\n            this._updateTime = 0;\\n            this._cullTime = 0;\\n            this._drawTime = 0;\\n            this._stats.addLayer( \\'#ff0fff\\', 120,\\n                                  function ( /*t*/ ) {\\n                                      return ( 1000.0 / that._frameRate );\\n                                  },\\n                                  function ( a ) {\\n                                      return \\'FrameRate: \\' + ( a ).toFixed( 0 ) + \\' fps\\';\\n                                  } );\\n\\n            this._stats.addLayer( \\'#ffff00\\', maxMS,\\n                                  function ( /*t*/ ) {\\n                                      return that._frameTime;\\n                                  },\\n                                  function ( a ) {\\n                                      return \\'FrameTime: \\' + a.toFixed( 2 ) + \\' ms\\';\\n                                  } );\\n\\n            this._stats.addLayer( \\'#d07b1f\\', maxMS,\\n                                  function ( /*t*/ ) {\\n                                      return that._updateTime;\\n                                  },\\n                                  function ( a ) {\\n                                      return \\'UpdateTime: \\' + a.toFixed( 2 ) + \\' ms\\';\\n                                  } );\\n\\n            this._stats.addLayer( \\'#73e0ff\\', maxMS,\\n                                  function ( /*t*/ ) {\\n                                      return that._cullTime;\\n                                  },\\n                                  function ( a ) {\\n                                      return \\'CullTime: \\' + a.toFixed( 2 ) + \\' ms\\';\\n                                  } );\\n\\n            this._stats.addLayer( \\'#ff0000\\',\\n                                  maxMS,\\n                                  function ( /*t*/ ) {\\n                                      return that._drawTime;\\n                                  },\\n                                  function ( a ) {\\n                                      return \\'DrawTime: \\' + a.toFixed( 2 ) + \\' ms\\';\\n                                  } );\\n\\n            if ( window.performance && window.performance.memory && window.performance.memory.totalJSHeapSize )\\n                this._stats.addLayer( \\'#00ff00\\',\\n                                      window.performance.memory.totalJSHeapSize * 2,\\n                                      function ( /*t*/ ) {\\n                                          return that._memSize;\\n                                      },\\n                                      function ( a ) {\\n                                          return \\'Memory : \\' + a.toFixed( 0 ) + \\' b\\';\\n                                      } );\\n\\n        },\\n\\n        update: function () {\\n            this.getScene().accept( this._updateVisitor );\\n        },\\n        cull: function () {\\n            // this part of code should be called for each view\\n            // right now, we dont support multi view\\n            this._stateGraph.clean();\\n            this._renderStage.reset();\\n\\n            this._cullVisitor.reset();\\n            this._cullVisitor.setStateGraph( this._stateGraph );\\n            this._cullVisitor.setRenderStage( this._renderStage );\\n            var camera = this.getCamera();\\n            this._cullVisitor.pushStateSet( camera.getStateSet() );\\n            this._cullVisitor.pushProjectionMatrix( camera.getProjectionMatrix() );\\n\\n            // update bound\\n            camera.getBound();\\n\\n            var identity = Matrix.create();\\n            this._cullVisitor.pushModelviewMatrix( identity );\\n            switch ( this.getLightingMode() )\\n            {\\n                case View.LightingMode.HEADLIGHT:\\n                    if ( this._light ) {\\n                        this._cullVisitor.addPositionedAttribute( this._light );\\n                    }\\n                    break;\\n                case View.LightingMode.SKY_LIGHT:\\n                    if ( this._light ) {\\n                        this._cullVisitor.addPositionedAttribute( this._light, camera.getViewMatrix() );\\n                    }\\n                    break;\\n                default:\\n                    break;\\n            }\\n            this._cullVisitor.pushModelviewMatrix( camera.getViewMatrix() );\\n            this._cullVisitor.pushViewport( camera.getViewport() );\\n            this._cullVisitor.setCullSettings( camera );\\n\\n            this._renderStage.setClearDepth( camera.getClearDepth() );\\n            this._renderStage.setClearColor( camera.getClearColor() );\\n            this._renderStage.setClearMask( camera.getClearMask() );\\n            this._renderStage.setViewport( camera.getViewport() );\\n\\n            // Check if Frustum culling is enabled to calculate the clip planes\\n            if ( this._options.getBoolean( \\'enableFrustumCulling\\' ) === true ){\\n                this._cullVisitor.setEnableFrustumCulling ( true );\\n                var mvp = Matrix.create();\\n                Matrix.mult( camera.getProjectionMatrix(), camera.getViewMatrix(), mvp );\\n                this._cullVisitor.getFrustumPlanes( mvp, this._cullVisitor._frustum );\\n            }\\n            //CullVisitor.prototype.handleCullCallbacksAndTraverse.call(this._cullVisitor,camera);\\n            this.getScene().accept( this._cullVisitor );\\n\\n            // fix projection matrix if camera has near/far auto compute\\n            this._cullVisitor.popModelviewMatrix();\\n            this._cullVisitor.popProjectionMatrix();\\n            this._cullVisitor.popViewport();\\n            this._cullVisitor.popStateSet();\\n\\n            this._renderStage.sort();\\n        },\\n        draw: function () {\\n            var state = this.getState();\\n            this._renderStage.draw( state );\\n\\n            // noticed that we accumulate lot of stack, maybe because of the stateGraph\\n            state.popAllStateSets();\\n            state.applyWithoutProgram(); //state.apply(); // apply default state (global)\\n        },\\n\\n        frame: function () {\\n\\n            this.updateViewport();\\n\\n            var frameTime, beginFrameTime;\\n            frameTime = MACROUTILS.performance.now();\\n            if ( this._lastFrameTime === undefined ) {\\n                this._lastFrameTime = 0;\\n            }\\n            this._frameRate = frameTime - this._lastFrameTime;\\n            this._lastFrameTime = frameTime;\\n            beginFrameTime = frameTime;\\n\\n            var frameStamp = this.getFrameStamp();\\n\\n            if ( frameStamp.getFrameNumber() === 0 ) {\\n                frameStamp.setReferenceTime( frameTime / 1000.0 );\\n                this._numberFrame = 0;\\n            }\\n\\n            frameStamp.setSimulationTime( frameTime / 1000.0 - frameStamp.getReferenceTime() );\\n\\n            // setup framestamp\\n            this._updateVisitor.setFrameStamp( frameStamp );\\n            this._cullVisitor.setFrameStamp( frameStamp );\\n\\n            // update inputs devices\\n            this.updateEventProxy( this._eventProxy, frameStamp );\\n\\n            // Update Manipulator/Event\\n            // should be merged with the update of game pad below\\n            if ( this.getManipulator() ) {\\n                this.getManipulator().update( this._updateVisitor );\\n                Matrix.copy( this.getManipulator().getInverseMatrix(), this.getCamera().getViewMatrix() );\\n            }\\n\\n            if ( this._stats === undefined ) {\\n                // time the update\\n                this.update();\\n                this.cull();\\n                this.draw();\\n                frameStamp.setFrameNumber( frameStamp.getFrameNumber() + 1 );\\n                this._numberFrame++;\\n                this._frameTime = MACROUTILS.performance.now() - beginFrameTime;\\n            } else {\\n                this._updateTime = MACROUTILS.performance.now();\\n                this.update();\\n                this._updateTime = MACROUTILS.performance.now() - this._updateTime;\\n\\n\\n                this._cullTime = MACROUTILS.performance.now();\\n                this.cull();\\n                this._cullTime = MACROUTILS.performance.now() - this._cullTime;\\n\\n                this._drawTime = MACROUTILS.performance.now();\\n                this.draw();\\n                this._drawTime = MACROUTILS.performance.now() - this._drawTime;\\n\\n                frameStamp.setFrameNumber( frameStamp.getFrameNumber() + 1 );\\n\\n                this._numberFrame++;\\n                this._frameTime = MACROUTILS.performance.now() - beginFrameTime;\\n\\n                if ( window.performance && window.performance.memory && window.performance.memory.usedJSHeapSize )\\n                    this._memSize = window.performance.memory.usedJSHeapSize;\\n                this._stats.update();\\n            }\\n        },\\n\\n        setDone: function ( bool ) {\\n            this._done = bool;\\n        },\\n        done: function () {\\n            return this._done;\\n        },\\n\\n        run: function () {\\n            var self = this;\\n            var render = function () {\\n                if ( !self.done() ) {\\n                    self._requestID = window.requestAnimationFrame( render, self.canvas );\\n                    self.frame();\\n                }\\n            };\\n            render();\\n        },\\n\\n        setupManipulator: function ( manipulator /*, dontBindDefaultEvent */ ) {\\n            if ( manipulator === undefined ) {\\n                manipulator = new OrbitManipulator();\\n            }\\n\\n            if ( manipulator.setNode !== undefined ) {\\n                manipulator.setNode( this.getSceneData() );\\n            } else {\\n                // for backward compatibility\\n                manipulator.view = this;\\n            }\\n\\n            this.setManipulator( manipulator );\\n       },\\n\\n\\n        // updateViewport\\n        updateViewport: function() {\\n\\n            var gl = this.getGraphicContext();\\n            var canvas = gl.canvas;\\n\\n            this.computeCanvasSize( canvas );\\n\\n            var camera = this.getCamera();\\n            var vp = camera.getViewport();\\n\\n            var prevWidth = vp.width();\\n            var prevHeight = vp.height();\\n\\n            var widthChangeRatio = canvas.width / prevWidth;\\n            var heightChangeRatio = canvas.height / prevHeight;\\n            var aspectRatioChange = widthChangeRatio / heightChangeRatio;\\n            vp.setViewport( vp.x() * widthChangeRatio, vp.y() * heightChangeRatio, vp.width() * widthChangeRatio, vp.height() * heightChangeRatio );\\n\\n            if ( aspectRatioChange !== 1.0 ) {\\n                Matrix.preMult( camera.getProjectionMatrix(), Matrix.makeScale( 1.0 / aspectRatioChange, 1.0, 1.0, Matrix.create() ) );\\n            }\\n        },\\n\\n        // intialize all input devices\\n        initEventProxy: function ( argsObject ) {\\n            var args = argsObject || {};\\n            var deviceEnabled = {};\\n\\n            var lists = EventProxy;\\n            var argumentEventBackend = args.EventBackend;\\n            // loop on each devices and try to initialize it\\n            var keys = window.Object.keys( lists );\\n            for ( var i = 0, l = keys.length; i < l; i++ ) {\\n                var device = keys[ i ];\\n\\n                // check if the config has a require\\n                var initialize = true;\\n                var argDevice = {};\\n                if ( argumentEventBackend && ( argumentEventBackend[ device ] !== undefined ) ) {\\n                    initialize = argumentEventBackend[ device ].enable || true;\\n                    argDevice = argumentEventBackend[ device ];\\n                }\\n\\n                if ( initialize ) {\\n                    var inputDevice = new lists[ device ]( this );\\n                    inputDevice.init( argDevice );\\n                    deviceEnabled[ device ] = inputDevice;\\n                }\\n            }\\n            return deviceEnabled;\\n        },\\n        updateEventProxy: function ( list, frameStamp ) {\\n            var keys = window.Object.keys( list );\\n            keys.forEach( function ( key ) {\\n                var device = list[ key ];\\n                if ( device.update )\\n                    device.update( frameStamp );\\n            } );\\n        }\\n\\n    } );\\n\\n    return Viewer;\\n} );\\n\\n//# sourceURL=/osgViewer/Viewer.js\");\n\n",
    "eval(\"define( \\'osgViewer/osgViewer\\',[\\n    \\'osgViewer/View\\',\\n    \\'osgViewer/Viewer\\',\\n    \\'osgViewer/eventProxy/EventProxy\\'\\n], function ( View, Viewer, EventProxy ) {\\n\\n    var osgViewer = {};\\n\\n    osgViewer.View = View;\\n    osgViewer.Viewer = Viewer;\\n    osgViewer.EventProxy = EventProxy;\\n\\n    return osgViewer;\\n} );\\n\\n//# sourceURL=/osgViewer/osgViewer.js\");\n\n",
    "eval(\"define( \\'OSG\\',[\\n    \\'osgNameSpace\\',\\n    \\'osg/osg\\',\\n    \\'osgAnimation/osgAnimation\\',\\n    \\'osgDB/osgDB\\',\\n    \\'osgGA/osgGA\\',\\n    \\'osgUtil/osgUtil\\',\\n    \\'osgViewer/osgViewer\\'\\n], function ( osgNameSpace, osg, osgAnimation, osgDB, osgGA, osgUtil, osgViewer ) {\\n\\n\\n    /*jshint unused: true */\\n    var Q = require(\\'Q\\');\\n    /*jshint unused: false */\\n    var openSceneGraph = osgNameSpace;\\n\\n    openSceneGraph.osg = osg;\\n    openSceneGraph.osgAnimation = osgAnimation;\\n    openSceneGraph.osgDB = osgDB;\\n    openSceneGraph.osgGA = osgGA;\\n    openSceneGraph.osgUtil = osgUtil;\\n    openSceneGraph.osgViewer = osgViewer;\\n\\n    var namespaces = [ \\'osg\\', \\'osgAnimation\\', \\'osgDB\\', \\'osgGA\\', \\'osgUtil\\', \\'osgViewer\\' ];\\n\\n    // for backward compatibility\\n    openSceneGraph.globalify = function () {\\n        namespaces.forEach( function ( namespace ) {\\n            window[ namespace ] = openSceneGraph[ namespace ];\\n        } );\\n    };\\n\\n    return openSceneGraph;\\n} );\\n\\n//# sourceURL=/OSG.js\");\n\n"
  ]
}